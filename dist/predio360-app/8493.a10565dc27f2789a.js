"use strict";(self.webpackChunkpredio360_app=self.webpackChunkpredio360_app||[]).push([[8493],{44056:(x,z,U)=>{U.r(z),U.d(z,{default:()=>R});var l=U(62208),h=U(55713),D=U(48977),Z=U(56729),v=U(84161),T=U(14658),F=U(55915),P=U(65234),M=U(14471);class O{transform(d){const w=this._transform(d),n=[w.points.buffer,w.rgb.buffer];(0,l.pC)(w.pointIdFilterMap)&&n.push(w.pointIdFilterMap.buffer);for(const o of w.attributes)"buffer"in o.values&&(0,h.eP)(o.values.buffer)&&o.values.buffer!==w.rgb.buffer&&n.push(o.values.buffer);return Promise.resolve({result:w,transferList:n})}_transform(d){const w=(0,M.Ym)(d.schema,d.geometryBuffer);let n=w.length/3,o=null;const i=[],m=(0,M.dH)(d.primaryAttributeData,w,n);(0,l.pC)(d.primaryAttributeData)&&m&&i.push({attributeInfo:d.primaryAttributeData.attributeInfo,values:m});const y=(0,M.dH)(d.modulationAttributeData,w,n);(0,l.pC)(d.modulationAttributeData)&&y&&i.push({attributeInfo:d.modulationAttributeData.attributeInfo,values:y});let r=(0,M.aE)(d.rendererInfo,m,y,n);if(d.filterInfo&&d.filterInfo.length>0&&(0,l.pC)(d.filterAttributesData)){const b=d.filterAttributesData.filter(l.pC).map(f=>{const C=(0,M.dH)(f,w,n),e={attributeInfo:f.attributeInfo,values:C};return i.push(e),e});o=new Uint32Array(n),n=(0,M.hv)(w,r,o,d.filterInfo,b)}for(const b of d.userAttributesData){const f=(0,M.dH)(b,w,n);i.push({attributeInfo:b.attributeInfo,values:f})}3*n<r.length&&(r=new Uint8Array(r.buffer.slice(0,3*n))),this._applyElevationOffsetInPlace(w,n,d.elevationOffset);const g=this._transformCoordinates(w,n,d.obb,P.Z.fromJSON(d.inSR),P.Z.fromJSON(d.outSR));return{obb:d.obb,points:g,rgb:r,attributes:i,pointIdFilterMap:o}}_transformCoordinates(d,w,n,o,i){if(!(0,F.CM)(d,o,0,d,i,0,w))throw new Error("Can't reproject");const m=(0,T.f)(n.center[0],n.center[1],n.center[2]),y=(0,T.c)(),r=(0,T.c)();(0,D.c)(B,n.quaternion);const g=new Float32Array(3*w);for(let b=0;b<w;b++)y[0]=d[3*b]-m[0],y[1]=d[3*b+1]-m[1],y[2]=d[3*b+2]-m[2],(0,v.q)(r,y,B),n.halfSize[0]=Math.max(n.halfSize[0],Math.abs(r[0])),n.halfSize[1]=Math.max(n.halfSize[1],Math.abs(r[1])),n.halfSize[2]=Math.max(n.halfSize[2],Math.abs(r[2])),g[3*b]=y[0],g[3*b+1]=y[1],g[3*b+2]=y[2];return g}_applyElevationOffsetInPlace(d,w,n){if(0!==n)for(let o=0;o<w;o++)d[3*o+2]+=n}}const B=(0,Z.c)();function R(){return new O}},92852:(x,z,U)=>{U.d(z,{Es:()=>o,I_:()=>B,W7:()=>n,qM:()=>r});var l=U(26584),h=U(58817),D=U(63290),Z=U(61566),v=U(16396);const T=D.Z.getLogger("esri.views.3d.layers.i3s.I3SBinaryReader");function F(e,t,u){let s="",a=0;for(;a<u;){const c=e[t+a];if(c<128)s+=String.fromCharCode(c),a++;else if(c>=192&&c<224){if(a+1>=u)throw new l.Z("utf8-decode-error","UTF-8 Decode failed. Two byte character was truncated.");s+=String.fromCharCode((31&c)<<6|63&e[t+a+1]),a+=2}else if(c>=224&&c<240){if(a+2>=u)throw new l.Z("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");s+=String.fromCharCode((15&c)<<12|(63&e[t+a+1])<<6|63&e[t+a+2]),a+=3}else{if(!(c>=240&&c<248))throw new l.Z("utf8-decode-error","UTF-8 Decode failed. Invalid multi byte sequence.");{if(a+3>=u)throw new l.Z("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");const p=(7&c)<<18|(63&e[t+a+1])<<12|(63&e[t+a+2])<<6|63&e[t+a+3];s+=p>=65536?String.fromCharCode(55296+(p-65536>>10),56320+(1023&p)):String.fromCharCode(p),a+=4}}}return s}function P(e,t){const u={byteOffset:0,byteCount:0,fields:Object.create(null)};let s=0;for(let a=0;a<t.length;a++){const c=t[a],p=c.valueType||c.type;u.fields[c.property]=(0,b[p])(e,s),s+=g[p].BYTES_PER_ELEMENT}return u.byteCount=s,u}function O(e,t,u){const s=[];let a,c,p=0;for(c=0;c<e;c+=1){if(a=t[c],a>0){if(s.push(F(u,p,a-1)),0!==u[p+a-1])throw new l.Z("string-array-error","Invalid string array: missing null termination.")}else s.push(null);p+=a}return s}function B(e,t){return new g[t.valueType](e,t.byteOffset,t.count*t.valuesPerElement)}function d(e,t,u){if(t!==e&&T.error(`Invalid ${u} buffer size\n expected: ${e}, actual: ${t})`),t<e)throw new l.Z("buffer-too-small","Binary buffer is too small",{expectedSize:e,actualSize:t})}function n(e,t){const u=P(e,t&&t.header);let s=u.byteCount;const a={isDraco:!1,header:u,byteOffset:u.byteCount,byteCount:0,vertexAttributes:{}},c=u.fields,p=null!=c.vertexCount?c.vertexCount:c.count;for(const E of t.ordering){if(!t.vertexAttributes[E])continue;const A={...t.vertexAttributes[E],byteOffset:s,count:p};a.vertexAttributes[y[E]?y[E]:"_"+E]=A,s+=C(A.valueType)*A.valuesPerElement*p}const I=c.faceCount;if(t.faces&&I){a.faces={};for(const E of t.ordering){if(!t.faces[E])continue;const A={...t.faces[E],byteOffset:s,count:I};a.faces[E]=A,s+=C(A.valueType)*A.valuesPerElement*I}}const _=c.featureCount;if(t.featureAttributes&&t.featureAttributeOrder&&_){a.featureAttributes={};for(const E of t.featureAttributeOrder){if(!t.featureAttributes[E])continue;const A={...t.featureAttributes[E],byteOffset:s,count:_};a.featureAttributes[E]=A,s+=("UInt64"===A.valueType?8:C(A.valueType))*A.valuesPerElement*_}}return d(s,e.byteLength,"geometry"),a.byteCount=s-a.byteOffset,a}function o(e,t){return e&&e.compressedAttributes&&"draco"===e.compressedAttributes.encoding?function m(e){const t={isDraco:!0,isLegacy:!1,color:!1,normal:!1,uv0:!1,uvRegion:!1,featureIndex:!1};for(const u of e)switch(u){case"position":break;case"normal":t.normal=!0;break;case"uv0":t.uv0=!0;break;case"color":t.color=!0;break;case"uv-region":t.uvRegion=!0;break;case"feature-index":t.featureIndex=!0}return t}(e.compressedAttributes.attributes):e?function w(e){return{isDraco:!1,isLegacy:!1,color:null!=e.color,normal:null!=e.normal,uv0:null!=e.uv0,uvRegion:null!=e.uvRegion,featureIndex:null!=e.faceRange&&null!=e.featureId}}(e):function i(e){const t={isDraco:!1,isLegacy:!0,color:!1,normal:!1,uv0:!1,uvRegion:!1,featureIndex:!1};for(const u of e.ordering)if(e.vertexAttributes[u])switch(u){case"position":break;case"normal":t.normal=!0;break;case"color":t.color=!0;break;case"uv0":t.uv0=!0;break;case"region":t.uvRegion=!0}return e.featureAttributes&&e.featureAttributeOrder&&(t.featureIndex=!0),t}(t)}const y={position:v.T.POSITION,normal:v.T.NORMAL,color:v.T.COLOR,uv0:v.T.UV0,region:v.T.UVREGION};function r(e,t,u){if("lepcc-rgb"===e.encoding)return(0,Z.IT)(t);if("lepcc-intensity"===e.encoding)return(0,Z.ti)(t);if(null!=e.encoding&&""!==e.encoding)throw new l.Z("unknown-attribute-storage-info-encoding","Unknown Attribute Storage Info Encoding");e["attributeByteCounts "]&&!e.attributeByteCounts&&(T.warn("Warning: Trailing space in 'attributeByteCounts '."),e.attributeByteCounts=e["attributeByteCounts "]),"ObjectIds"===e.ordering[0]&&e.hasOwnProperty("objectIds")&&(T.warn("Warning: Case error in objectIds"),e.ordering[0]="objectIds");const s=function L(e,t,u){const s=null!=t.header?P(e,t.header):{byteOffset:0,byteCount:0,fields:{count:u}},a={header:s,byteOffset:s.byteCount,byteCount:0,entries:Object.create(null)};let c=s.byteCount;for(let p=0;p<t.ordering.length;p++){const I=t.ordering[p],_=(0,h.d9)(t[I]);if(_.count=s.fields.count??0,"String"===_.valueType){if(_.byteOffset=c,_.byteCount=s.fields[I+"ByteCount"],"UTF-8"!==_.encoding)throw new l.Z("unsupported-encoding","Unsupported String encoding.",{encoding:_.encoding});if(_.timeEncoding&&"ECMA_ISO8601"!==_.timeEncoding)throw new l.Z("unsupported-time-encoding","Unsupported time encoding.",{timeEncoding:_.timeEncoding})}else{if(!f(_.valueType))throw new l.Z("unsupported-value-type","Unsupported binary valueType",{valueType:_.valueType});{const E=C(_.valueType);c+=c%E!=0?E-c%E:0,_.byteOffset=c,_.byteCount=E*_.valuesPerElement*_.count}}c+=_.byteCount??0,a.entries[I]=_}return a.byteCount=c-a.byteOffset,a}(t,e,u);d(s.byteOffset+s.byteCount,t.byteLength,"attribute");const a=s.entries.attributeValues||s.entries.objectIds;if(a){if("String"===a.valueType){const c=s.entries.attributeByteCounts,p=B(t,c),I=function R(e,t){return new Uint8Array(e,t.byteOffset,t.byteCount)}(t,a);return a.timeEncoding?function M(e,t,u){return O(e,t,u).map(s=>{const a=s?Date.parse(s):null;return a&&!Number.isNaN(a)?a:null})}(c.count,p,I):O(c.count,p,I)}return B(t,a)}throw new l.Z("bad-attribute-storage-info","Bad attributeStorageInfo specification.")}const g={Float32:Float32Array,Float64:Float64Array,UInt8:Uint8Array,Int8:Int8Array,UInt16:Uint16Array,Int16:Int16Array,UInt32:Uint32Array,Int32:Int32Array},b={Float32:(e,t)=>new DataView(e,0).getFloat32(t,!0),Float64:(e,t)=>new DataView(e,0).getFloat64(t,!0),UInt8:(e,t)=>new DataView(e,0).getUint8(t),Int8:(e,t)=>new DataView(e,0).getInt8(t),UInt16:(e,t)=>new DataView(e,0).getUint16(t,!0),Int16:(e,t)=>new DataView(e,0).getInt16(t,!0),UInt32:(e,t)=>new DataView(e,0).getUint32(t,!0),Int32:(e,t)=>new DataView(e,0).getInt32(t,!0)};function f(e){return g.hasOwnProperty(e)}function C(e){return f(e)?g[e].BYTES_PER_ELEMENT:0}},61566:(x,z,U)=>{U.d(z,{Gi:()=>F,IT:()=>R,ti:()=>w});var l=U(26584);const h=!0,D={identifierOffset:0,identifierLength:10,versionOffset:10,checksumOffset:12,byteCount:16};function Z(n,o,i){return{identifier:String.fromCharCode.apply(null,new Uint8Array(n,i+D.identifierOffset,D.identifierLength)),version:o.getUint16(i+D.versionOffset,h),checksum:o.getUint32(i+D.checksumOffset,h)}}const v={sizeLo:0,sizeHi:4,minX:8,minY:16,minZ:24,maxX:32,maxY:40,maxZ:48,errorX:56,errorY:64,errorZ:72,count:80,reserved:84,byteCount:88};function F(n){const o=new DataView(n,0);let i=0;const{identifier:m,version:y}=Z(n,o,i);if(i+=D.byteCount,"LEPCC     "!==m)throw new l.Z("lepcc-decode-error","Bad identifier");if(y>1)throw new l.Z("lepcc-decode-error","Unknown version");const r=function T(n,o){return{sizeLo:n.getUint32(o+v.sizeLo,h),sizeHi:n.getUint32(o+v.sizeHi,h),minX:n.getFloat64(o+v.minX,h),minY:n.getFloat64(o+v.minY,h),minZ:n.getFloat64(o+v.minZ,h),maxX:n.getFloat64(o+v.maxX,h),maxY:n.getFloat64(o+v.maxY,h),maxZ:n.getFloat64(o+v.maxZ,h),errorX:n.getFloat64(o+v.errorX,h),errorY:n.getFloat64(o+v.errorY,h),errorZ:n.getFloat64(o+v.errorZ,h),count:n.getUint32(o+v.count,h),reserved:n.getUint32(o+v.reserved,h)}}(o,i);if(i+=v.byteCount,r.sizeHi*2**32+r.sizeLo!==n.byteLength)throw new l.Z("lepcc-decode-error","Bad size");const g=new Float64Array(3*r.count),b=[],f=[],C=[],e=[];if(i=P(n,i,b),i=P(n,i,f),i=P(n,i,C),i=P(n,i,e),i!==n.byteLength)throw new l.Z("lepcc-decode-error","Bad length");let t=0,u=0;for(let s=0;s<b.length;s++){u+=b[s];let a=0;for(let c=0;c<f[s];c++){a+=C[t];const p=e[t];g[3*t]=Math.min(r.maxX,r.minX+2*r.errorX*a),g[3*t+1]=Math.min(r.maxY,r.minY+2*r.errorY*u),g[3*t+2]=Math.min(r.maxZ,r.minZ+2*r.errorZ*p),t++}}return{errorX:r.errorX,errorY:r.errorY,errorZ:r.errorZ,result:g}}function P(n,o,i){const m=[];o=M(n,o,m);const y=[];for(let r=0;r<m.length;r++){y.length=0,o=M(n,o,y);for(let g=0;g<y.length;g++)i.push(y[g]+m[r])}return o}function M(n,o,i){const m=new DataView(n,o),y=m.getUint8(0),r=31&y,g=!!(32&y),b=(192&y)>>6;let f=0;if(0===b)f=m.getUint32(1,h),o+=5;else if(1===b)f=m.getUint16(1,h),o+=3;else{if(2!==b)throw new l.Z("lepcc-decode-error","Bad count type");f=m.getUint8(1),o+=2}if(g)throw new l.Z("lepcc-decode-error","LUT not implemented");const C=Math.ceil(f*r/8),e=new Uint8Array(n,o,C);let t=0,u=0,s=0;const a=-1>>>32-r;for(let c=0;c<f;c++){for(;u<r;)t|=e[s]<<u,u+=8,s+=1;i[c]=t&a,t>>>=r,u-=r,u+r>32&&(t|=e[s-1]>>8-u)}return o+s}const O={sizeLo:0,sizeHi:4,count:8,colorMapCount:12,lookupMethod:14,compressionMethod:15,byteCount:16};function R(n){const o=new DataView(n,0);let i=0;const{identifier:m,version:y}=Z(n,o,i);if(i+=D.byteCount,"ClusterRGB"!==m)throw new l.Z("lepcc-decode-error","Bad identifier");if(y>1)throw new l.Z("lepcc-decode-error","Unknown version");const r=function B(n,o){return{sizeLo:n.getUint32(o+O.sizeLo,h),sizeHi:n.getUint32(o+O.sizeHi,h),count:n.getUint32(o+O.count,h),colorMapCount:n.getUint16(o+O.colorMapCount,h),lookupMethod:n.getUint8(o+O.lookupMethod),compressionMethod:n.getUint8(o+O.compressionMethod)}}(o,i);if(i+=O.byteCount,r.sizeHi*2**32+r.sizeLo!==n.byteLength)throw new l.Z("lepcc-decode-error","Bad size");if((2===r.lookupMethod||1===r.lookupMethod)&&0===r.compressionMethod){if(3*r.colorMapCount+r.count+i!==n.byteLength||r.colorMapCount>256)throw new l.Z("lepcc-decode-error","Bad count");const g=new Uint8Array(n,i,3*r.colorMapCount),b=new Uint8Array(n,i+3*r.colorMapCount,r.count),f=new Uint8Array(3*r.count);for(let C=0;C<r.count;C++){const e=b[C];f[3*C]=g[3*e],f[3*C+1]=g[3*e+1],f[3*C+2]=g[3*e+2]}return f}if(0===r.lookupMethod&&0===r.compressionMethod){if(3*r.count+i!==n.byteLength||0!==r.colorMapCount)throw new l.Z("lepcc-decode-error","Bad count");return new Uint8Array(n,i).slice()}if(r.lookupMethod<=2&&1===r.compressionMethod){if(i+3!==n.byteLength||1!==r.colorMapCount)throw new l.Z("lepcc-decode-error","Bad count");const g=o.getUint8(i),b=o.getUint8(i+1),f=o.getUint8(i+2),C=new Uint8Array(3*r.count);for(let e=0;e<r.count;e++)C[3*e]=g,C[3*e+1]=b,C[3*e+2]=f;return C}throw new l.Z("lepcc-decode-error","Bad method "+r.lookupMethod+","+r.compressionMethod)}const L={sizeLo:0,sizeHi:4,count:8,scaleFactor:12,bitsPerPoint:14,reserved:15,byteCount:16};function w(n){const o=new DataView(n,0);let i=0;const{identifier:m,version:y}=Z(n,o,i);if(i+=D.byteCount,"Intensity "!==m)throw new l.Z("lepcc-decode-error","Bad identifier");if(y>1)throw new l.Z("lepcc-decode-error","Unknown version");const r=function d(n,o){return{sizeLo:n.getUint32(o+L.sizeLo,h),sizeHi:n.getUint32(o+L.sizeHi,h),count:n.getUint32(o+L.count,h),scaleFactor:n.getUint16(o+L.scaleFactor,h),bitsPerPoint:n.getUint8(o+L.bitsPerPoint),reserved:n.getUint8(o+L.reserved)}}(o,i);if(i+=L.byteCount,r.sizeHi*2**32+r.sizeLo!==n.byteLength)throw new l.Z("lepcc-decode-error","Bad size");const g=new Uint16Array(r.count);if(8===r.bitsPerPoint){if(r.count+i!==n.byteLength)throw new l.Z("lepcc-decode-error","Bad size");const b=new Uint8Array(n,i,r.count);for(let f=0;f<r.count;f++)g[f]=b[f]*r.scaleFactor}else if(16===r.bitsPerPoint){if(2*r.count+i!==n.byteLength)throw new l.Z("lepcc-decode-error","Bad size");const b=new Uint16Array(n,i,r.count);for(let f=0;f<r.count;f++)g[f]=b[f]*r.scaleFactor}else{const b=[];if(M(n,i,b)!==n.byteLength)throw new l.Z("lepcc-decode-error","Bad size");for(let f=0;f<r.count;f++)g[f]=b[f]*r.scaleFactor}return g}}}]);