"use strict";(self.webpackChunkpredio360_app=self.webpackChunkpredio360_app||[]).push([[3053],{24192:(oe,Ut,U)=>{U.d(Ut,{Z:()=>wt});var tt,et,Z=U(8314),Ot=U(27899);(et=tt||(tt={}))[et.varint=0]="varint",et[et.fixed64=1]="fixed64",et[et.delimited=2]="delimited",et[et.fixed32=5]="fixed32",et[et.unknown=99]="unknown";const O=4294967296,C=new TextDecoder("utf-8"),ht=(0,Z.Z)("safari")||(0,Z.Z)("ios")?6:(0,Z.Z)("ff")?12:32;class wt{constructor(T,E,v=0,V=(T?T.byteLength:0)){this._tag=0,this._dataType=tt.unknown,this._init(T,E,v,V)}_init(T,E,v,V){this._data=T,this._dataView=E,this._pos=v,this._end=V}asUnsafe(){return this}clone(){return new wt(this._data,this._dataView,this._pos,this._end)}pos(){return this._pos}move(T){this._pos=T}nextTag(T){for(;;){if(this._pos===this._end)return!1;const E=this._decodeVarint();if(this._tag=E>>3,this._dataType=7&E,!T||T===this._tag)break;this.skip()}return!0}next(){if(this._pos===this._end)return!1;const T=this._decodeVarint();return this._tag=T>>3,this._dataType=7&T,!0}empty(){return this._pos>=this._end}tag(){return this._tag}getInt32(){return this._decodeVarint()}getInt64(){return this._decodeVarint()}getUInt32(){let T=4294967295;if(T=(127&this._data[this._pos])>>>0,this._data[this._pos++]<128||(T=(T|(127&this._data[this._pos])<<7)>>>0,this._data[this._pos++]<128)||(T=(T|(127&this._data[this._pos])<<14)>>>0,this._data[this._pos++]<128)||(T=(T|(127&this._data[this._pos])<<21)>>>0,this._data[this._pos++]<128)||(T=(T|(15&this._data[this._pos])<<28)>>>0,this._data[this._pos++]<128))return T;throw new Error("Varint overflow")}getUInt64(){return this._decodeVarint()}getSInt32(){const T=this.getUInt32();return T>>>1^-(1&T)|0}getSInt64(){return this._decodeSVarint()}getBool(){const T=0!==this._data[this._pos];return this._skip(1),T}getEnum(){return this._decodeVarint()}getFixed64(){const T=this._dataView,E=this._pos,v=T.getUint32(E,!0)+T.getUint32(E+4,!0)*O;return this._skip(8),v}getSFixed64(){const T=this._dataView,E=this._pos,v=T.getUint32(E,!0)+T.getInt32(E+4,!0)*O;return this._skip(8),v}getDouble(){const T=this._dataView.getFloat64(this._pos,!0);return this._skip(8),T}getFixed32(){const T=this._dataView.getUint32(this._pos,!0);return this._skip(4),T}getSFixed32(){const T=this._dataView.getInt32(this._pos,!0);return this._skip(4),T}getFloat(){const T=this._dataView.getFloat32(this._pos,!0);return this._skip(4),T}getString(){const T=this._getLength(),E=this._pos,v=this._toString(this._data,E,E+T);return this._skip(T),v}getBytes(){const T=this._getLength(),E=this._pos,v=this._toBytes(this._data,E,E+T);return this._skip(T),v}getLength(){return this._getLengthUnsafe()}processMessageWithArgs(T,E,v,V){const z=this.getMessage(),S=T(z,E,v,V);return z.release(),S}processMessage(T){const E=this.getMessage(),v=T(E);return E.release(),v}getMessage(){const T=this._getLength(),E=wt.pool.acquire();return E._init(this._data,this._dataView,this._pos,this._pos+T),this._skip(T),E}release(){wt.pool.release(this)}dataType(){return this._dataType}skip(){switch(this._dataType){case tt.varint:this._decodeVarint();break;case tt.fixed64:this._skip(8);break;case tt.delimited:this._skip(this._getLength());break;case tt.fixed32:this._skip(4);break;default:throw new Error("Invalid data type!")}}skipLen(T){this._skip(T)}_skip(T){if(this._pos+T>this._end)throw new Error("Attempt to skip past the end of buffer!");this._pos+=T}_decodeVarint(){const T=this._data;let E=this._pos,v=0,V=0;if(this._end-E>=10)do{if(V=T[E++],v|=127&V,0==(128&V)||(V=T[E++],v|=(127&V)<<7,0==(128&V))||(V=T[E++],v|=(127&V)<<14,0==(128&V))||(V=T[E++],v|=(127&V)<<21,0==(128&V))||(V=T[E++],v+=268435456*(127&V),0==(128&V))||(V=T[E++],v+=34359738368*(127&V),0==(128&V))||(V=T[E++],v+=4398046511104*(127&V),0==(128&V))||(V=T[E++],v+=562949953421312*(127&V),0==(128&V))||(V=T[E++],v+=72057594037927940*(127&V),0==(128&V))||(V=T[E++],v+=0x8000000000000000*(127&V),0==(128&V)))break;throw new Error("Varint too long!")}while(0);else{let z=1;for(;E!==this._end&&(V=T[E],0!=(128&V));)++E,v+=(127&V)*z,z*=128;if(E===this._end)throw new Error("Varint overrun!");++E,v+=V*z}return this._pos=E,v}_decodeSVarint(){const T=this._data;let E,v=0,V=0;const z=1&T[this._pos];if(V=T[this._pos++],v|=127&V,0==(128&V)||(V=T[this._pos++],v|=(127&V)<<7,0==(128&V))||(V=T[this._pos++],v|=(127&V)<<14,0==(128&V))||(V=T[this._pos++],v|=(127&V)<<21,0==(128&V))||(V=T[this._pos++],v+=268435456*(127&V),0==(128&V))||(V=T[this._pos++],v+=34359738368*(127&V),0==(128&V))||(V=T[this._pos++],v+=4398046511104*(127&V),0==(128&V)))return z?-(v+1)/2:v/2;if(E=BigInt(v),V=T[this._pos++],E+=0x2000000000000n*BigInt(127&V),0==(128&V)||(V=T[this._pos++],E+=0x100000000000000n*BigInt(127&V),0==(128&V))||(V=T[this._pos++],E+=0x8000000000000000n*BigInt(127&V),0==(128&V)))return Number(z?-(E+1n)/2n:E/2n);throw new Error("Varint too long!")}_getLength(){if(this._dataType!==tt.delimited)throw new Error("Not a delimited data type!");return this._decodeVarint()}_getLengthUnsafe(){return this.getUInt32()}_toString(T,E,v){if((v=Math.min(this._end,v))-E>ht){const S=T.subarray(E,v);return C.decode(S)}let V="",z="";for(let S=E;S<v;++S){const I=T[S];128&I?z+="%"+I.toString(16):(V+=decodeURIComponent(z)+String.fromCharCode(I),z="")}return z.length&&(V+=decodeURIComponent(z)),V}_toBytes(T,E,v){return v=Math.min(this._end,v),new Uint8Array(T.buffer,E,v-E)}}wt.pool=new Ot.Z(wt,void 0,et=>{et._data=null,et._dataView=null})},58774:(oe,Ut,U)=>{U.d(Ut,{b:()=>v,j:()=>wt});var Z=U(15861),Ot=U(54346),tt=U(8314);const O=128e3;let C=null,ht=null;function wt(){return et.apply(this,arguments)}function et(){return et=(0,Z.Z)(function*(){return C||(C=function T(){return E.apply(this,arguments)}()),C}),et.apply(this,arguments)}function E(){return(E=(0,Z.Z)(function*(){ht=yield((0,tt.Z)("esri-csp-restrictions")?yield U.e(71).then(U.bind(U,10071)).then(z=>z.l):yield U.e(9507).then(U.bind(U,99507)).then(z=>z.l)).default({locateFile:z=>(0,Ot.V)(`esri/core/libs/libtess/${z}`)})})).apply(this,arguments)}function v(V,z){const S=Math.max(V.length,O);return ht.triangulate(V,z,S)}},3053:(oe,Ut,U)=>{U.r(Ut),U.d(Ut,{default:()=>kt});var Z=U(15861),Ot=U(10699),tt=U(919),O=U(13160),C=U(86575);function wt(u){return!(u<11904)&&(u>=12704&&u<=12735||u>=12544&&u<=12591||u>=65072&&u<=65103||u>=63744&&u<=64255||u>=13056&&u<=13311||u>=11904&&u<=12031||u>=12736&&u<=12783||u>=12288&&u<=12351||u>=13312&&u<=19903||u>=19968&&u<=40959||u>=12800&&u<=13055||u>=65280&&u<=65519||u>=12352&&u<=12447||u>=12272&&u<=12287||u>=12032&&u<=12255||u>=12784&&u<=12799||u>=12448&&u<=12543||u>=65040&&u<=65055||u>=42128&&u<=42191||u>=40960&&u<=42127)}function et(u){switch(u){case 10:case 32:case 38:case 40:case 41:case 43:case 45:case 47:case 173:case 183:case 8203:case 8208:case 8211:case 8231:return!0}return!1}function T(u){switch(u){case 9:case 10:case 11:case 12:case 13:case 32:return!0}return!1}var E=U(84439);const v=24;class z{constructor(e,t,n,i,o,a,r){this._glyphItems=e,this._maxWidth=t,this._lineHeight=n,this._letterSpacing=i,this._hAnchor=o,this._vAnchor=a,this._justify=r}getShaping(e,t,n){const i=this._letterSpacing,o=this._lineHeight,a=this._justify,r=this._maxWidth,l=[];let h=0,d=0;for(const p of e){const P=p.codePointAt(0);if(null==P)continue;const L=n&&(746===(u=P)||747===u||!(u<4352)&&(u>=12704&&u<=12735||u>=12544&&u<=12591||u>=65072&&u<=65103&&!(u>=65097&&u<=65103)||u>=63744&&u<=64255||u>=13056&&u<=13311||u>=11904&&u<=12031||u>=12736&&u<=12783||u>=12288&&u<=12351&&!(u>=12296&&u<=12305||u>=12308&&u<=12319||12336===u)||u>=13312&&u<=19903||u>=19968&&u<=40959||u>=12800&&u<=13055||u>=12592&&u<=12687||u>=43360&&u<=43391||u>=55216&&u<=55295||u>=4352&&u<=4607||u>=44032&&u<=55215||u>=12352&&u<=12447||u>=12272&&u<=12287||u>=12688&&u<=12703||u>=12032&&u<=12255||u>=12784&&u<=12799||u>=12448&&u<=12543&&12540!==u||u>=65280&&u<=65519&&!(65288===u||65289===u||65293===u||u>=65306&&u<=65310||65339===u||65341===u||65343===u||u>=65371&&u<=65503||65507===u||u>=65512&&u<=65519)||u>=65104&&u<=65135&&!(u>=65112&&u<=65118||u>=65123&&u<=65126)||u>=5120&&u<=5759||u>=6320&&u<=6399||u>=65040&&u<=65055||u>=19904&&u<=19967||u>=40960&&u<=42127||u>=42128&&u<=42191));let M;for(const B of this._glyphItems)if(M=B[P],M)break;l.push({codePoint:P,x:h,y:d,vertical:L,glyphMosaicItem:M}),M&&(h+=M.metrics.advance+i)}var u;let f=h;r>0&&(f=h/Math.max(1,Math.ceil(h/r)));const x=e.includes("\u200b"),c=[],g=l.length;for(let p=0;p<g-1;p++){const P=l[p].codePoint,L=wt(P);if(et(P)||L){let M=0;if(10===P)M-=1e4;else if(L&&x)M+=150;else{40!==P&&65288!==P||(M+=50);const B=l[p+1].codePoint;41!==B&&65289!==B||(M+=50)}c.push(this._buildBreak(p+1,l[p].x,f,c,M,!1))}}const _=this._optimalBreaks(this._buildBreak(g,h,f,c,0,!0));let D=0;const y=t?-o:o;let m=0;for(let p=0;p<_.length;p++){const P=_[p];let L=m;for(;L<P&&T(l[L].codePoint);)l[L].glyphMosaicItem=null,++L;let M=P-1;for(;M>L&&T(l[M].codePoint);)l[M].glyphMosaicItem=null,--M;if(L<=M){const B=l[L].x;for(let A=L;A<=M;A++)l[A].x-=B,l[A].y=d;let k=l[M].x;l[M].glyphMosaicItem&&(k+=l[M].glyphMosaicItem.metrics.advance),D=Math.max(k,D),a&&this._applyJustification(l,L,M)}m=P,d+=y}if(l.length>0){const p=_.length-1,P=(a-this._hAnchor)*D;let L=(-this._vAnchor*(p+1)+.5)*o;t&&p&&(L+=p*o);for(const M of l)M.x+=P,M.y+=L}return l.filter(p=>p.glyphMosaicItem)}static getTextBox(e,t){if(!e.length)return null;let n=1/0,i=1/0,o=0,a=0;for(const r of e){const h=r.x,d=r.y-17,f=h+r.glyphMosaicItem.metrics.advance,x=d+t;n=Math.min(n,h),o=Math.max(o,f),i=Math.min(i,d),a=Math.max(a,x)}return{x:n,y:i,width:o-n,height:a-i}}static getBox(e){if(!e.length)return null;let t=1/0,n=1/0,i=0,o=0;for(const a of e){const{height:r,left:l,top:h,width:d}=a.glyphMosaicItem.metrics,f=a.x,x=a.y-(r-Math.abs(h)),c=f+d+l,g=x+r;t=Math.min(t,f),i=Math.max(i,c),n=Math.min(n,x),o=Math.max(o,g)}return{x:t,y:n,width:i-t,height:o-n}}static addDecoration(e,t){const n=e.length;if(0===n)return;let o=e[0].x+e[0].glyphMosaicItem.metrics.left,a=e[0].y;for(let l=1;l<n;l++){const h=e[l];if(h.y!==a){const d=e[l-1].x+e[l-1].glyphMosaicItem.metrics.left+e[l-1].glyphMosaicItem.metrics.width;e.push({codePoint:0,x:o,y:a+t-3,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new E.Z(4,0,4,8),metrics:{width:d-o,height:8,left:0,top:0,advance:0},page:0,code:0}}),a=h.y,o=h.x+h.glyphMosaicItem.metrics.left}}const r=e[n-1].x+e[n-1].glyphMosaicItem.metrics.left+e[n-1].glyphMosaicItem.metrics.width;e.push({codePoint:0,x:o,y:a+t-3,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new E.Z(4,0,4,8),metrics:{width:r-o,height:8,left:0,top:0,advance:0},page:0,code:0}})}_breakScore(e,t,n,i){const o=(e-t)*(e-t);return i?e<t?o/2:2*o:o+Math.abs(n)*n}_buildBreak(e,t,n,i,o,a){let r=null,l=this._breakScore(t,n,o,a);for(const h of i){const f=this._breakScore(t-h.x,n,o,a)+h.score;f<=l&&(r=h,l=f)}return{index:e,x:t,score:l,previousBreak:r}}_optimalBreaks(e){return e?this._optimalBreaks(e.previousBreak).concat(e.index):[]}_applyJustification(e,t,n){const i=e[n],a=(i.x+(i.vertical?v:i.glyphMosaicItem?i.glyphMosaicItem.metrics.advance:0))*this._justify;for(let r=t;r<=n;r++)e[r].x-=a}}var S=U(47132),I=U(1268);class Dt{constructor(e,t,n=0,i=-1,o=.5){this.x=e,this.y=t,this.angle=n,this.segment=i,this.minzoom=o}}class It{constructor(e,t,n,i,o,a=.5,r=C.FM){this.anchor=e,this.labelAngle=t,this.glyphAngle=n,this.page=i,this.alternateVerticalGlyph=o,this.minzoom=a,this.maxzoom=r}}class bt{constructor(e,t,n,i,o,a,r,l,h,d,f,x){this.tl=e,this.tr=t,this.bl=n,this.br=i,this.mosaicRect=o,this.labelAngle=a,this.minAngle=r,this.maxAngle=l,this.anchor=h,this.minzoom=d,this.maxzoom=f,this.page=x}}class Bt{constructor(e){this.shapes=e}}class Et{getIconPlacement(e,t,n){const i=new O.E9(e.x,e.y),o=n.rotationAlignment===I.aF.MAP,a=n.keepUpright;let r=n.rotate*C.nF;o&&(r+=e.angle);const l=new Bt([]);return n.allowOverlap&&n.ignorePlacement||!S.R8||(l.iconColliders=[]),this._addIconPlacement(l,i,t,n,r),o&&a&&this._addIconPlacement(l,i,t,n,r+C.RD),l}_addIconPlacement(e,t,n,i,o){const a=n.rasterizationScale,r=n.width/a,l=n.height/a,h=i.offset;let d=h[0],f=h[1];switch(i.anchor){case I.nR.CENTER:d-=r/2,f-=l/2;break;case I.nR.LEFT:f-=l/2;break;case I.nR.RIGHT:d-=r,f-=l/2;break;case I.nR.TOP:d-=r/2;break;case I.nR.BOTTOM:d-=r/2,f-=l;break;case I.nR.TOP_LEFT:break;case I.nR.BOTTOM_LEFT:f-=l;break;case I.nR.TOP_RIGHT:d-=r;break;case I.nR.BOTTOM_RIGHT:d-=r,f-=l}const x=n.rect,c=2/a,g=d-c,_=f-c,D=g+x.width/a,y=_+x.height/a,m=new O.E9(g,_),p=new O.E9(D,y),P=new O.E9(g,y),L=new O.E9(D,_);if(0!==o){const B=Math.cos(o),k=Math.sin(o);m.rotate(B,k),p.rotate(B,k),P.rotate(B,k),L.rotate(B,k)}const M=new bt(m,L,P,p,x,o,0,256,t,.5,C.FM,0);if(e.shapes.push(M),(!i.allowOverlap||!i.ignorePlacement)&&S.R8){const B=i.size,k=i.padding;e.iconColliders.push({xTile:t.x,yTile:t.y,dxPixels:d*B-k,dyPixels:f*B-k,hard:!i.optional,partIndex:0,width:r*B+2*k,height:l*B+2*k,angle:o,minLod:.5,maxLod:C.FM})}}getTextPlacement(e,t,n,i){const o=new O.E9(e.x,e.y),a=i.rotate*C.nF,r=i.rotationAlignment===I.aF.MAP,l=i.keepUpright,h=i.padding;let d=.5;const f=r?e.angle:0,x=e.segment>=0&&r,c=i.allowOverlap&&i.ignorePlacement?null:[],g=[],D=!x;let y=Number.POSITIVE_INFINITY,m=Number.NEGATIVE_INFINITY,p=y,P=m;const L=(x||r)&&l,M=i.size/v;let B=!1;for(const R of t)if(R.vertical){B=!0;break}let k,A=0,F=0;if(!x&&B){const R=z.getTextBox(t,i.lineHeight*v);switch(i.anchor){case I.nR.LEFT:A=R.height/2,F=-R.width/2;break;case I.nR.RIGHT:A=-R.height/2,F=R.width/2;break;case I.nR.TOP:A=R.height/2,F=R.width/2;break;case I.nR.BOTTOM:A=-R.height/2,F=-R.width/2;break;case I.nR.TOP_LEFT:A=R.height;break;case I.nR.BOTTOM_LEFT:F=-R.width;break;case I.nR.TOP_RIGHT:F=R.width;break;case I.nR.BOTTOM_RIGHT:A=-R.height}}A+=i.offset[0]*v,F+=i.offset[1]*v;for(const R of t){const Q=R.glyphMosaicItem;if(!Q||Q.rect.isEmpty)continue;const Y=Q.rect,X=Q.metrics,_t=Q.page;if(c&&D){if(void 0!==k&&k!==R.y){let lt,Tt,Ct,Ft;B?(lt=-P+A,Tt=y+F,Ct=P-p,Ft=m-y):(lt=y+A,Tt=p+F,Ct=m-y,Ft=P-p),c.push({xTile:e.x,yTile:e.y,dxPixels:lt*M-h,dyPixels:Tt*M-h,hard:!i.optional,partIndex:1,width:Ct*M+2*h,height:Ft*M+2*h,angle:a,minLod:.5,maxLod:C.FM}),y=Number.POSITIVE_INFINITY,m=Number.NEGATIVE_INFINITY,p=y,P=m}k=R.y}const Yt=[];if(x){const Tt=(R.x+X.left-4+.5*Q.metrics.width)*M*8;if(d=this._placeGlyph(e,d,Tt,n,e.segment,1,R.vertical,_t,Yt),l&&(d=this._placeGlyph(e,d,Tt,n,e.segment,-1,R.vertical,_t,Yt)),d>=2)break}else Yt.push(new It(o,f,f,_t,!1)),r&&l&&Yt.push(new It(o,f+C.RD,f+C.RD,_t,!1));const vt=R.x+X.left,Ht=R.y-17-X.top,Xt=vt+X.width,ce=Ht+X.height;let mt,St,ee,se,Qt,ie,fe,de;!x&&B?R.vertical?(mt=new O.E9(-((Ht+ce)/2+X.width/2)-4+A,(vt+Xt)/2-X.height/2-4+F),St=new O.E9(mt.x+Y.width,mt.y+Y.height),ee=new O.E9(mt.x,St.y),se=new O.E9(St.x,mt.y)):(mt=new O.E9(4-Ht+A,vt-4+F),St=new O.E9(mt.x-Y.height,mt.y+Y.width),ee=new O.E9(St.x,mt.y),se=new O.E9(mt.x,St.y)):(mt=new O.E9(vt-4+A,Ht-4+F),St=new O.E9(mt.x+Y.width,mt.y+Y.height),ee=new O.E9(mt.x,St.y),se=new O.E9(St.x,mt.y));for(const lt of Yt){let Tt,Ct,Ft,Zt;lt.alternateVerticalGlyph?(Qt||(Qt=new O.E9((vt+Xt)/2+A-X.height/2-4,(Ht+ce)/2+F+X.width/2+4),ie=new O.E9(Qt.x+Y.height,Qt.y-Y.width),fe=new O.E9(ie.x,Qt.y),de=new O.E9(Qt.x,ie.y)),Tt=Qt,Ct=fe,Ft=de,Zt=ie):(Tt=mt,Ct=ee,Ft=se,Zt=St);const ne=Ht,ue=ce,re=lt.glyphAngle+a;if(0!==re){const Wt=Math.cos(re),ae=Math.sin(re);Tt=Tt.clone(),Ct=Ct?.clone(),Ft=Ft?.clone(),Zt=Zt?.clone(),Tt.rotate(Wt,ae),Zt?.rotate(Wt,ae),Ct?.rotate(Wt,ae),Ft?.rotate(Wt,ae)}let qt=0,te=256;x&&B?R.vertical?lt.alternateVerticalGlyph?(qt=32,te=96):(qt=224,te=32):(qt=224,te=96):(qt=192,te=64),g.push(new bt(Tt,Ft,Ct,Zt,Y,lt.labelAngle,qt,te,lt.anchor,lt.minzoom,lt.maxzoom,lt.page)),!c||L&&!this._legible(lt.labelAngle)||(D?(vt<y&&(y=vt),ne<p&&(p=ne),Xt>m&&(m=Xt),ue>P&&(P=ue)):lt.minzoom<2&&c.push({xTile:e.x,yTile:e.y,dxPixels:(vt+A)*M-h,dyPixels:(ne+A)*M-h,hard:!i.optional,partIndex:1,width:(Xt-vt)*M+2*h,height:(ue-ne)*M+2*h,angle:re,minLod:lt.minzoom,maxLod:lt.maxzoom}))}}if(d>=2)return null;if(c&&D){let R,Q,Y,X;B?(R=-P+A,Q=y+F,Y=P-p,X=m-y):(R=y+A,Q=p+F,Y=m-y,X=P-p),c.push({xTile:e.x,yTile:e.y,dxPixels:R*M-h,dyPixels:Q*M-h,hard:!i.optional,partIndex:1,width:Y*M+2*h,height:X*M+2*h,angle:a,minLod:.5,maxLod:C.FM})}const H=new Bt(g);return c&&c.length>0&&(H.textColliders=c),H}_legible(e){const t=(0,C.Or)(e);return t<65||t>=193}_placeGlyph(e,t,n,i,o,a,r,l,h){let d=a;const f=d<0?(0,C.DQ)(e.angle+C.RD,C.yF):e.angle;let x=0;n<0&&(d*=-1,n*=-1,x=C.RD),d>0&&++o;let c=new O.E9(e.x,e.y),g=i[o],_=C.FM;if(i.length<=o)return _;for(;;){const D=g.x-c.x,y=g.y-c.y,m=Math.sqrt(D*D+y*y),p=Math.max(n/m,t),M=(0,C.DQ)(Math.atan2(y/m,D/m)+x,C.yF);if(h.push(new It(c,f,M,l,!1,p,_)),r&&h.push(new It(c,f,M,l,!0,p,_)),p<=t)return p;c=g.clone();do{if(i.length<=(o+=d)||o<0)return p;g=i[o]}while(c.isEqual(g));let B=g.x-c.x,k=g.y-c.y;const A=Math.sqrt(B*B+k*k);B*=m/A,k*=m/A,c.x-=B,c.y-=k,_=p}}}var Mt=U(24192),at=U(58774),ft=U(35688),N=U(36243);class K extends N.Z{constructor(){super(12)}add(e,t,n){const i=this.array;i.push(e),i.push(t),i.push(n)}}var b=U(38320);class w extends N.Z{constructor(e){super(e)}add(e,t,n,i,o,a,r,l,h,d,f,x){const c=this.array;let g=N.Z.i1616to32(e,t);c.push(g);const _=31;g=N.Z.i8888to32(Math.round(_*n),Math.round(_*i),Math.round(_*o),Math.round(_*a)),c.push(g),g=N.Z.i8888to32(Math.round(_*r),Math.round(_*l),Math.round(_*h),Math.round(_*d)),c.push(g),g=N.Z.i1616to32(f,0),c.push(g),x&&c.push(...x)}}class zt extends N.Z{constructor(e){super(e)}add(e,t,n){const i=this.array;i.push(N.Z.i1616to32(e,t)),n&&i.push(...n)}}class At extends N.Z{constructor(e){super(e)}add(e,t,n,i,o,a,r){const l=this.array,h=this.index;let d=N.Z.i1616to32(e,t);return l.push(d),d=N.Z.i8888to32(Math.round(15*n),Math.round(15*i),o,a),l.push(d),r&&l.push(...r),h}}class j extends N.Z{constructor(e){super(e)}add(e,t,n,i,o,a,r,l,h,d,f,x){const c=this.array;let g=N.Z.i1616to32(e,t);c.push(g),g=N.Z.i1616to32(Math.round(8*n),Math.round(8*i)),c.push(g),g=N.Z.i8888to32(o/4,a/4,l,h),c.push(g),g=N.Z.i8888to32(0,(0,C.Or)(r),10*d,Math.min(10*f,255)),c.push(g),x&&c.push(...x)}}class nt extends N.Z{constructor(e){super(e)}add(e,t,n,i,o){const a=this.array,r=N.Z.i1616to32(2*e+n,2*t+i);a.push(r),o&&a.push(...o)}}class J{constructor(e,t,n){this.layerExtent=4096,this._features=[],this.layer=e,this.zoom=t,this._spriteInfo=n,this._filter=e.getFeatureFilter()}pushFeature(e){this._filter&&!this._filter.filter(e,this.zoom)||this._features.push(e)}hasFeatures(){return this._features.length>0}getResources(e,t,n){}}class Jt extends J{constructor(e,t,n,i,o){super(e,t,n),this.type=tt.al.CIRCLE,this._circleVertexBuffer=i,this._circleIndexBuffer=o}get circleIndexStart(){return this._circleIndexStart}get circleIndexCount(){return this._circleIndexCount}processFeatures(e){const t=this._circleVertexBuffer,n=this._circleIndexBuffer;this._circleIndexStart=3*n.index,this._circleIndexCount=0;const i=this.layer,o=this.zoom;e&&e.setExtent(this.layerExtent);for(const a of this._features){const r=a.getGeometry(e);if(!r)continue;const l=i.circleMaterial.encodeAttributes(a,o,i);for(const h of r)if(h)for(const d of h){const f=t.index;t.add(d.x,d.y,0,0,l),t.add(d.x,d.y,0,1,l),t.add(d.x,d.y,1,0,l),t.add(d.x,d.y,1,1,l),n.add(f,f+1,f+2),n.add(f+1,f+2,f+3),this._circleIndexCount+=6}}}serialize(){let e=6;e+=this.layerUIDs.length,e+=this._circleVertexBuffer.array.length,e+=this._circleIndexBuffer.array.length;const t=new Uint32Array(e),n=new Int32Array(t.buffer);let i=0;t[i++]=this.type,t[i++]=this.layerUIDs.length;for(let o=0;o<this.layerUIDs.length;o++)t[i++]=this.layerUIDs[o];t[i++]=this._circleIndexStart,t[i++]=this._circleIndexCount,t[i++]=this._circleVertexBuffer.array.length;for(let o=0;o<this._circleVertexBuffer.array.length;o++)n[i++]=this._circleVertexBuffer.array[o];t[i++]=this._circleIndexBuffer.array.length;for(let o=0;o<this._circleIndexBuffer.array.length;o++)t[i++]=this._circleIndexBuffer.array[o];return t.buffer}}var Kt=U(35575),ot=U(11915);class $ extends J{constructor(e,t,n,i,o,a,r){super(e,t,n),this.type=tt.al.FILL,this._patternMap=new Map,this._fillVertexBuffer=i,this._fillIndexBuffer=o,this._outlineVertexBuffer=a,this._outlineIndexBuffer=r}get fillIndexStart(){return this._fillIndexStart}get fillIndexCount(){return this._fillIndexCount}get outlineIndexStart(){return this._outlineIndexStart}get outlineIndexCount(){return this._outlineIndexCount}getResources(e,t,n){const o=this.zoom,a=this.layer.getPaintProperty("fill-pattern");if(a)if(a.isDataDriven)for(const r of this._features)t(a.getValue(o,r),!0);else t(a.getValue(o),!0)}processFeatures(e){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const t=this.layer,n=this.zoom,{fillMaterial:i,outlineMaterial:o,hasDataDrivenFill:a,hasDataDrivenOutline:r}=t;e&&e.setExtent(this.layerExtent);const l=t.getPaintProperty("fill-pattern"),h=l?.isDataDriven;let d=!l&&t.getPaintValue("fill-antialias",n);if(t.outlineUsesFillColor){if(d&&!t.hasDataDrivenOpacity){const c=t.getPaintValue("fill-opacity",n),g=t.getPaintValue("fill-opacity",n+1);c<1&&g<1&&(d=!1)}if(d&&!t.hasDataDrivenColor){const c=t.getPaintValue("fill-color",n),g=t.getPaintValue("fill-color",n+1);c[3]<1&&g[3]<1&&(d=!1)}}const f=this._features,x=e?.validateTessellation;if(h){const c=[];for(const g of f){const _=l.getValue(n,g),D=this._spriteInfo[_];if(!D?.rect)continue;const y=i.encodeAttributes(g,n,t,D),m=d&&r?o.encodeAttributes(g,n,t):[],p=g.getGeometry(e);c.push({ddFillAttributes:y,ddOutlineAttributes:m,page:D.page,geometry:p}),c.sort((P,L)=>P.page-L.page);for(const{ddFillAttributes:P,ddOutlineAttributes:L,page:M,geometry:B}of c)this._processFeature(B,d,t.outlineUsesFillColor,P,L,x,M)}}else for(const c of f){const g=a?i.encodeAttributes(c,n,t):null,_=d&&r?o.encodeAttributes(c,n,t):null,D=c.getGeometry(e);this._processFeature(D,d,t.outlineUsesFillColor,g,_,x)}}serialize(){let e=10;e+=this.layerUIDs.length,e+=this._fillVertexBuffer.array.length,e+=this._fillIndexBuffer.array.length,e+=this._outlineVertexBuffer.array.length,e+=this._outlineIndexBuffer.array.length,e+=3*this._patternMap.size+1;const t=new Uint32Array(e),n=new Int32Array(t.buffer);let i=0;t[i++]=this.type,t[i++]=this.layerUIDs.length;for(let r=0;r<this.layerUIDs.length;r++)t[i++]=this.layerUIDs[r];t[i++]=this._fillIndexStart,t[i++]=this._fillIndexCount,t[i++]=this._outlineIndexStart,t[i++]=this._outlineIndexCount;const o=this._patternMap,a=o.size;if(t[i++]=a,a>0)for(const[r,[l,h]]of o)t[i++]=r,t[i++]=l,t[i++]=h;t[i++]=this._fillVertexBuffer.array.length;for(let r=0;r<this._fillVertexBuffer.array.length;r++)n[i++]=this._fillVertexBuffer.array[r];t[i++]=this._fillIndexBuffer.array.length;for(let r=0;r<this._fillIndexBuffer.array.length;r++)t[i++]=this._fillIndexBuffer.array[r];t[i++]=this._outlineVertexBuffer.array.length;for(let r=0;r<this._outlineVertexBuffer.array.length;r++)n[i++]=this._outlineVertexBuffer.array[r];t[i++]=this._outlineIndexBuffer.array.length;for(let r=0;r<this._outlineIndexBuffer.array.length;r++)t[i++]=this._outlineIndexBuffer.array[r];return t.buffer}_processFeature(e,t,n,i,o,a,r){if(!e)return;const l=e.length;if(t&&(!n||!o||0===o.length))for(let x=0;x<l;x++)this._processOutline(e[x],o);let f;for(let x=0;x<l;x++){const c=$._area(e[x]);c>32?(void 0!==f&&this._processFill(e,f,i,a,r),f=[x]):c<-32&&void 0!==f&&f.push(x)}void 0!==f&&this._processFill(e,f,i,a,r)}_processOutline(e,t){const n=this._outlineVertexBuffer,i=this._outlineIndexBuffer,o=i.index;let a,r,l;const h=new O.E9(0,0),d=new O.E9(0,0),f=new O.E9(0,0);let x=-1,c=-1,g=-1,_=-1,D=-1,y=!1,p=e.length;if(p<2)return;const P=e[0];let L=e[p-1];for(;p&&L.isEqual(P);)--p,L=e[p-1];if(!(p-0<2)){for(let M=0;M<p;++M){0===M?(a=e[p-1],r=e[0],l=e[1],h.assignSub(r,a),h.normalize(),h.rightPerpendicular()):(a=r,r=l,l=M!==p-1?e[M+1]:e[0],h.assign(d));const B=this._isClipEdge(a,r);-1===_&&(y=B),d.assignSub(l,r),d.normalize(),d.rightPerpendicular();const k=h.x*d.y-h.y*d.x;f.assignAdd(h,d),f.normalize();const A=-f.x*-h.x+-f.y*-h.y;let F=Math.abs(0!==A?1/A:1);F>8&&(F=8),k>=0?(g=n.add(r.x,r.y,h.x,h.y,0,1,t),-1===_&&(_=g),x>=0&&c>=0&&g>=0&&!B&&i.add(x,c,g),c=n.add(r.x,r.y,F*-f.x,F*-f.y,0,-1,t),-1===D&&(D=c),x>=0&&c>=0&&g>=0&&!B&&i.add(x,c,g),x=c,c=g,g=n.add(r.x,r.y,f.x,f.y,0,1,t),x>=0&&c>=0&&g>=0&&!B&&i.add(x,c,g),c=n.add(r.x,r.y,d.x,d.y,0,1,t),x>=0&&c>=0&&g>=0&&!B&&i.add(x,c,g)):(g=n.add(r.x,r.y,F*f.x,F*f.y,0,1,t),-1===_&&(_=g),x>=0&&c>=0&&g>=0&&!B&&i.add(x,c,g),c=n.add(r.x,r.y,-h.x,-h.y,0,-1,t),-1===D&&(D=c),x>=0&&c>=0&&g>=0&&!B&&i.add(x,c,g),x=c,c=g,g=n.add(r.x,r.y,-f.x,-f.y,0,-1,t),x>=0&&c>=0&&g>=0&&!B&&i.add(x,c,g),x=n.add(r.x,r.y,-d.x,-d.y,0,-1,t),x>=0&&c>=0&&g>=0&&!B&&i.add(x,c,g))}x>=0&&c>=0&&_>=0&&!y&&i.add(x,c,_),x>=0&&_>=0&&D>=0&&!y&&i.add(x,D,_),this._outlineIndexCount+=3*(i.index-o)}}_processFill(e,t,n,i,o){let a;t.length>1&&(a=[]);let r=0;for(const f of t)0!==r&&a.push(r),r+=e[f].length;const l=2*r,h=Kt.Z.acquire();for(const f of t){const x=e[f],c=x.length;for(let g=0;g<c;++g)h.push(x[g].x,x[g].y)}const d=(0,ot.e)(h,a,2);if(ot.e.deviation(h,a,2,d)>0){const f=t.map(g=>e[g].length),{buffer:x,vertexCount:c}=(0,at.b)(h,f);if(c>0){const g=this._fillVertexBuffer.index;for(let _=0;_<c;_++)this._fillVertexBuffer.add(x[2*_],x[2*_+1],n);for(let _=0;_<c;_+=3){const D=g+_;this._fillIndexBuffer.add(D,D+1,D+2)}if(void 0!==o){const _=this._patternMap,D=_.get(o);D?D[1]+=c:_.set(o,[this._fillIndexStart+this._fillIndexCount,c])}this._fillIndexCount+=c}}else{const f=d.length;if(f>0){const x=this._fillVertexBuffer.index;let c=0;for(;c<l;)this._fillVertexBuffer.add(h[c++],h[c++],n);let g=0;for(;g<f;)this._fillIndexBuffer.add(x+d[g++],x+d[g++],x+d[g++]);if(void 0!==o){const _=this._patternMap,D=_.get(o);D?D[1]+=f:_.set(o,[this._fillIndexStart+this._fillIndexCount,f])}this._fillIndexCount+=f}}Kt.Z.release(h)}_isClipEdge(e,t){return e.x===t.x?e.x<=-64||e.x>=4160:e.y===t.y&&(e.y<=-64||e.y>=4160)}static _area(e){let t=0;const n=e.length-1;for(let i=0;i<n;i++)t+=(e[i].x-e[i+1].x)*(e[i].y+e[i+1].y);return t+=(e[n].x-e[0].x)*(e[n].y+e[0].y),.5*t}}var st=U(46519);class it extends J{constructor(e,t,n,i,o){super(e,t,n),this.type=tt.al.LINE,this._tessellationOptions={pixelCoordRatio:8,halfWidth:0,offset:0},this._patternMap=new Map,this.tessellationProperties={_lineVertexBuffer:null,_lineIndexBuffer:null,_ddValues:null},this.tessellationProperties._lineVertexBuffer=i,this.tessellationProperties._lineIndexBuffer=o,this._lineTessellator=new st.z(le(this.tessellationProperties),he(this.tessellationProperties),e.canUseThinTessellation)}get lineIndexStart(){return this._lineIndexStart}get lineIndexCount(){return this._lineIndexCount}getResources(e,t,n){const i=this.layer,o=this.zoom,a=i.getPaintProperty("line-pattern"),r=i.getPaintProperty("line-dasharray"),l=i.getLayoutProperty("line-cap");if(!a&&!r)return;const h=l?.getValue(o)||0,d=l?.isDataDriven,f=a?.isDataDriven,x=r?.isDataDriven;if(f||x)for(const c of this._features)t(f?a.getValue(o,c):this._getDashArrayKey(c,o,i,r,d,l,h));else if(a)t(a.getValue(o));else if(r){const c=r.getValue(o);t(i.getDashKey(c,h))}}processFeatures(e){this._lineIndexStart=3*this.tessellationProperties._lineIndexBuffer.index,this._lineIndexCount=0;const t=this.layer,n=this.zoom,i=this._features,o=this._tessellationOptions,{hasDataDrivenLine:a,lineMaterial:r}=t;e&&e.setExtent(this.layerExtent);const l=t.getPaintProperty("line-pattern"),h=t.getPaintProperty("line-dasharray"),d=l?.isDataDriven,f=h?.isDataDriven;let x;x=t.getLayoutProperty("line-cap");const c=x?.isDataDriven?x:null,g=c?null:t.getLayoutValue("line-cap",n),_=g||0,D=!!c;x=t.getLayoutProperty("line-join");const y=x?.isDataDriven?x:null,m=y?null:t.getLayoutValue("line-join",n);x=t.getLayoutProperty("line-miter-limit");const p=x?.isDataDriven?x:null,P=p?null:t.getLayoutValue("line-miter-limit",n);x=t.getLayoutProperty("line-round-limit");const L=x?.isDataDriven?x:null,M=L?null:t.getLayoutValue("line-round-limit",n);x=t.getPaintProperty("line-width");const B=x?.isDataDriven?x:null,k=B?null:t.getPaintValue("line-width",n);x=t.getPaintProperty("line-offset");const A=x?.isDataDriven?x:null,F=A?null:t.getPaintValue("line-offset",n);if(d||f){const H=[];for(const R of i){const Q=d?l.getValue(n,R):this._getDashArrayKey(R,n,t,h,D,c,_),Y=this._spriteInfo[Q];if(!Y?.rect)continue;const X=r.encodeAttributes(R,n,t,Y),_t=R.getGeometry(e);H.push({ddAttributes:X,page:Y.page,cap:c?c.getValue(n,R):g,join:y?y.getValue(n,R):m,miterLimit:p?p.getValue(n,R):P,roundLimit:L?L.getValue(n,R):M,halfWidth:.5*(B?B.getValue(n,R):k),offset:A?A.getValue(n,R):F,geometry:_t})}H.sort((R,Q)=>R.page-Q.page),o.textured=!0;for(const{ddAttributes:R,page:Q,cap:Y,join:X,miterLimit:_t,roundLimit:Yt,halfWidth:vt,offset:Ht,geometry:Xt}of H)o.capType=Y,o.joinType=X,o.miterLimit=_t,o.roundLimit=Yt,o.halfWidth=vt,o.offset=Ht,this._processFeature(Xt,R,Q)}else{if(l){const H=l.getValue(n);if(!this._spriteInfo[H]?.rect)return}o.textured=!(!l&&!h),o.capType=g,o.joinType=m,o.miterLimit=P,o.roundLimit=M,o.halfWidth=.5*k,o.offset=F;for(const H of i){const R=a?r.encodeAttributes(H,n,t):null;c&&(o.capType=c.getValue(n,H)),y&&(o.joinType=y.getValue(n,H)),p&&(o.miterLimit=p.getValue(n,H)),L&&(o.roundLimit=L.getValue(n,H)),B&&(o.halfWidth=.5*B.getValue(n,H)),A&&(o.offset=A.getValue(n,H));const Q=H.getGeometry(e);this._processFeature(Q,R)}}}serialize(){let e=6;e+=this.layerUIDs.length,e+=this.tessellationProperties._lineVertexBuffer.array.length,e+=this.tessellationProperties._lineIndexBuffer.array.length,e+=3*this._patternMap.size+1;const t=new Uint32Array(e),n=new Int32Array(t.buffer);let i=0;t[i++]=this.type,t[i++]=this.layerUIDs.length;for(let r=0;r<this.layerUIDs.length;r++)t[i++]=this.layerUIDs[r];t[i++]=this._lineIndexStart,t[i++]=this._lineIndexCount;const o=this._patternMap,a=o.size;if(t[i++]=a,a>0)for(const[r,[l,h]]of o)t[i++]=r,t[i++]=l,t[i++]=h;t[i++]=this.tessellationProperties._lineVertexBuffer.array.length;for(let r=0;r<this.tessellationProperties._lineVertexBuffer.array.length;r++)n[i++]=this.tessellationProperties._lineVertexBuffer.array[r];t[i++]=this.tessellationProperties._lineIndexBuffer.array.length;for(let r=0;r<this.tessellationProperties._lineIndexBuffer.array.length;r++)t[i++]=this.tessellationProperties._lineIndexBuffer.array[r];return t.buffer}_processFeature(e,t,n){if(!e)return;const i=e.length;for(let o=0;o<i;o++)this._processGeometry(e[o],t,n)}_processGeometry(e,t,n){if(e.length<2)return;let o,a,r=e[0],l=1;for(;l<e.length;)o=e[l].x-r.x,a=e[l].y-r.y,o*o+a*a<1e-6?e.splice(l,1):(r=e[l],++l);if(e.length<2)return;const h=this.tessellationProperties._lineIndexBuffer,d=3*h.index;this._tessellationOptions.initialDistance=0,this._tessellationOptions.wrapDistance=65535,this.tessellationProperties._ddValues=t,this._lineTessellator.tessellate(e,this._tessellationOptions);const f=3*h.index-d;if(void 0!==n){const x=this._patternMap,c=x.get(n);c?c[1]+=f:x.set(n,[d+this._lineIndexCount,f])}this._lineIndexCount+=f}_getDashArrayKey(e,t,n,i,o,a,r){const l=o?a.getValue(t,e):r,h=i.getValue(t,e);return n.getDashKey(h,l)}}const le=u=>(e,t,n,i,o,a,r,l,h,d,f)=>(u._lineVertexBuffer.add(e,t,r,l,n,i,o,a,h,d,f,u._ddValues),u._lineVertexBuffer.index-1),he=u=>(e,t,n)=>{u._lineIndexBuffer.add(e,t,n)};var dt,u,rt=U(6879),Gt=U(62208),Pt=U(77275),jt=U(77928);function yt(u,e){return u.iconMosaicItem&&e.iconMosaicItem?u.iconMosaicItem.page===e.iconMosaicItem.page?0:u.iconMosaicItem.page-e.iconMosaicItem.page:u.iconMosaicItem&&!e.iconMosaicItem?1:!u.iconMosaicItem&&e.iconMosaicItem?-1:0}class q extends J{constructor(e,t,n,i,o,a,r,l,h){super(t,n,h.getSpriteItems()),this.type=tt.al.SYMBOL,this._markerMap=new Map,this._glyphMap=new Map,this._glyphBufferDataStorage=new Map,this._isIconSDF=!1,this._sourceTileKey=e,this._iconVertexBuffer=i,this._iconIndexBuffer=o,this._textVertexBuffer=a,this._textIndexBuffer=r,this._placementEngine=l,this._workerTileHandler=h}get markerPageMap(){return this._markerMap}get glyphsPageMap(){return this._glyphMap}get symbolInstances(){return this._symbolInstances}getResources(e,t,n){const i=this.layer,o=this.zoom;e&&e.setExtent(this.layerExtent);const a=i.getLayoutProperty("icon-image"),r=i.getLayoutProperty("text-field");let l=i.getLayoutProperty("text-transform"),h=i.getLayoutProperty("text-font");const d=[];let f,x,c,g;a&&!a.isDataDriven&&(f=a.getValue(o)),r&&!r.isDataDriven&&(x=r.getValue(o)),l&&l.isDataDriven||(c=i.getLayoutValue("text-transform",o),l=null),h&&h.isDataDriven||(g=i.getLayoutValue("text-font",o),h=null);for(const _ of this._features){const D=_.getGeometry(e);if(!D||0===D.length)continue;let y,m;a&&(y=a.isDataDriven?a.getValue(o,_):this._replaceKeys(f,_.values),y&&t(y));let p=!1;if(r&&(m=r.isDataDriven?r.getValue(o,_):this._replaceKeys(x,_.values),m)){switch(m=m.replaceAll("\\n","\n"),l&&(c=l.getValue(o,_)),c){case I._5.LOWERCASE:m=m.toLowerCase();break;case I._5.UPPERCASE:m=m.toUpperCase()}if(q._bidiEngine.hasBidiChar(m)){let M;M="rtl"===q._bidiEngine.checkContextual(m)?"IDNNN":"ICNNN",m=q._bidiEngine.bidiTransform(m,M,"VLYSN"),p=!0}if(m.length>0){h&&(g=h.getValue(o,_));for(const M of g){let B=n[M];B||(B=n[M]=new Set);for(const k of m){const A=k.codePointAt(0);null!=A&&B.add(A)}}}}if(!y&&!m)continue;const P=i.getLayoutValue("symbol-sort-key",o,_),L={feature:_,sprite:y,label:m,rtl:p,geometry:D,hash:(m?(0,Pt.hP)(m):0)^(y?(0,Pt.hP)(y):0),priority:P,textFont:g};d.push(L)}this._symbolFeatures=d}processFeatures(e){e&&e.setExtent(this.layerExtent);const t=this.layer,n=this.zoom,i=t.getLayoutValue("symbol-placement",n),o=i!==I.R.POINT,a=8*t.getLayoutValue("symbol-spacing",n),r=t.getLayoutProperty("icon-image"),l=t.getLayoutProperty("text-field"),h=r?new jt._L(t,n,o):null,d=l?new jt.nj(t,n,o):null,f=this._workerTileHandler;let x;r&&(x=f.getSpriteItems()),this._iconIndexStart=3*this._iconIndexBuffer.index,this._textIndexStart=3*this._textIndexBuffer.index,this._iconIndexCount=0,this._textIndexCount=0,this._markerMap.clear(),this._glyphMap.clear();const c=[];let g=1;d&&d.size&&(g=d.size/v);const _=d?d.maxAngle*C.nF:0,D=d?8*d.size:0;for(const y of this._symbolFeatures){let m,p;h&&x&&y.sprite&&(m=x[y.sprite],m&&m.sdf&&(this._isIconSDF=!0)),m&&h.update(n,y.feature);let P=0;const L=y.label;if(L){(0,Gt.O3)(d),d.update(n,y.feature);const M=o&&d.rotationAlignment===I.aF.MAP?d.keepUpright:d.writingMode&&d.writingMode.includes(I.r1.VERTICAL);let B=.5;switch(d.anchor){case I.nR.TOP_LEFT:case I.nR.LEFT:case I.nR.BOTTOM_LEFT:B=0;break;case I.nR.TOP_RIGHT:case I.nR.RIGHT:case I.nR.BOTTOM_RIGHT:B=1}let k=.5;switch(d.anchor){case I.nR.TOP_LEFT:case I.nR.TOP:case I.nR.TOP_RIGHT:k=0;break;case I.nR.BOTTOM_LEFT:case I.nR.BOTTOM:case I.nR.BOTTOM_RIGHT:k=1}let A=.5;switch(d.justify){case I.vL.AUTO:A=B;break;case I.vL.LEFT:A=0;break;case I.vL.RIGHT:A=1}const F=d.letterSpacing*v,H=o?0:d.maxWidth*v,R=d.lineHeight*v,Q=y.textFont.map(Y=>f.getGlyphItems(Y));if(p=new z(Q,H,R,F,B,k,A).getShaping(L,y.rtl,M),p&&p.length>0){let Y=1e30,X=-1e30;for(const _t of p)Y=Math.min(Y,_t.x),X=Math.max(X,_t.x);P=(X-Y+48)*g*8}}for(let M of y.geometry){const B=[];if(i===I.R.LINE){if(p?.length&&d?.size){const k=8*d.size*(2+Math.min(2,4*Math.abs(d.offset[1])));M=q._smoothVertices(M,k)}q._pushAnchors(B,M,a,P)}else i===I.R.LINE_CENTER?q._pushCenterAnchor(B,M):y.feature.type===O.Vl.Polygon?q._pushCentroid(B,M):B.push(new Dt(M[0].x,M[0].y));for(const k of B){if(k.x<0||k.x>4096||k.y<0||k.y>4096||o&&P>0&&d?.rotationAlignment===I.aF.MAP&&!q._honorsTextMaxAngle(M,k,P,_,D))continue;const A={shaping:p,line:M,iconMosaicItem:m,anchor:k,symbolFeature:y,textColliders:[],iconColliders:[],textVertexRanges:[],iconVertexRanges:[]};c.push(A),this._processFeature(A,h,d)}}}c.sort(yt),this._addPlacedGlyphs(),this._symbolInstances=c}serialize(){let e=14;e+=this.layerUIDs.length,e+=3*this.markerPageMap.size,e+=3*this.glyphsPageMap.size,e+=q._symbolsSerializationLength(this._symbolInstances),e+=this._iconVertexBuffer.array.length,e+=this._iconIndexBuffer.array.length,e+=this._textVertexBuffer.array.length,e+=this._textIndexBuffer.array.length;const t=new Uint32Array(e),n=new Int32Array(t.buffer),i=new Float32Array(t.buffer),[o,a,r]=this._sourceTileKey.split("/");let l=0;t[l++]=this.type,t[l++]=this.layerUIDs.length;for(let h=0;h<this.layerUIDs.length;h++)t[l++]=this.layerUIDs[h];t[l++]=this._isIconSDF?1:0,t[l++]=parseFloat(o),t[l++]=parseFloat(a),t[l++]=parseFloat(r),t[l++]=this.markerPageMap.size;for(const[h,[d,f]]of this.markerPageMap)t[l++]=h,t[l++]=d,t[l++]=f;t[l++]=this.glyphsPageMap.size;for(const[h,[d,f]]of this.glyphsPageMap)t[l++]=h,t[l++]=d,t[l++]=f;t[l++]=this._iconVertexBuffer.index/4,t[l++]=this._textVertexBuffer.index/4,l=q.serializeSymbols(t,n,i,l,this._symbolInstances),t[l++]=this._iconVertexBuffer.array.length;for(let h=0;h<this._iconVertexBuffer.array.length;h++)n[l++]=this._iconVertexBuffer.array[h];t[l++]=this._iconIndexBuffer.array.length;for(let h=0;h<this._iconIndexBuffer.array.length;h++)t[l++]=this._iconIndexBuffer.array[h];t[l++]=this._textVertexBuffer.array.length;for(let h=0;h<this._textVertexBuffer.array.length;h++)n[l++]=this._textVertexBuffer.array[h];t[l++]=this._textIndexBuffer.array.length;for(let h=0;h<this._textIndexBuffer.array.length;h++)t[l++]=this._textIndexBuffer.array[h];return t.buffer}static _symbolsSerializationLength(e){let t=0;t+=1;for(const n of e||[]){t+=5,t+=1;for(const i of n.textColliders)t+=10;for(const i of n.iconColliders)t+=10;t+=1,t+=2*n.textVertexRanges.length,t+=1,t+=2*n.iconVertexRanges.length}return t}static serializeSymbols(e,t,n,i,o){t[i++]=(o=o||[]).length;for(const a of o){t[i++]=a.anchor.x,t[i++]=a.anchor.y,t[i++]=a.symbolFeature.hash,t[i++]=a.symbolFeature.priority,t[i++]=a.symbolFeature.feature.featureIndex,t[i++]=a.textColliders.length+a.iconColliders.length;for(const r of a.textColliders)t[i++]=r.xTile,t[i++]=r.yTile,t[i++]=r.dxPixels,t[i++]=r.dyPixels,t[i++]=r.hard?1:0,t[i++]=r.partIndex,n[i++]=r.minLod,n[i++]=r.maxLod,t[i++]=r.width,t[i++]=r.height;for(const r of a.iconColliders)t[i++]=r.xTile,t[i++]=r.yTile,t[i++]=r.dxPixels,t[i++]=r.dyPixels,t[i++]=r.hard?1:0,t[i++]=r.partIndex,n[i++]=r.minLod,n[i++]=r.maxLod,t[i++]=r.width,t[i++]=r.height;t[i++]=a.textVertexRanges.length;for(const[r,l]of a.textVertexRanges)t[i++]=r,t[i++]=l;t[i++]=a.iconVertexRanges.length;for(const[r,l]of a.iconVertexRanges)t[i++]=r,t[i++]=l}return i}_replaceKeys(e,t){return e.replaceAll(/{([^{}]+)}/g,(n,i)=>i in t?t[i]:"")}_processFeature(e,t,n){const{line:i,iconMosaicItem:o,shaping:a,anchor:r}=e,l=this.zoom,h=this.layer,d=!!o;let f=!0;d&&(f=t?.optional||!o);const x=a&&a.length>0,c=!x||n?.optional;let g,_;if(d&&(g=this._placementEngine.getIconPlacement(r,o,t)),(g||f)&&(x&&(_=this._placementEngine.getTextPlacement(r,a,i,n)),_||c)){if(g&&_||(c||f?c||_?f||g||(_=null):g=null:(g=null,_=null)),_){const D=h.hasDataDrivenText?h.textMaterial.encodeAttributes(e.symbolFeature.feature,l,h):null;if(this._storePlacedGlyphs(e,_.shapes,l,n.rotationAlignment,D),_.textColliders){e.textColliders=_.textColliders;for(const y of _.textColliders){y.minLod=Math.max(l+(0,C.k3)(y.minLod),0),y.maxLod=Math.min(l+(0,C.k3)(y.maxLod),25);const m=y.angle;if(m){const p=Math.cos(m),P=Math.sin(m),L=y.dxPixels*p-y.dyPixels*P,M=y.dxPixels*P+y.dyPixels*p,B=(y.dxPixels+y.width)*p-y.dyPixels*P,k=(y.dxPixels+y.width)*P+y.dyPixels*p,A=y.dxPixels*p-(y.dyPixels+y.height)*P,F=y.dxPixels*P+(y.dyPixels+y.height)*p,H=(y.dxPixels+y.width)*p-(y.dyPixels+y.height)*P,R=(y.dxPixels+y.width)*P+(y.dyPixels+y.height)*p,Q=Math.min(L,B,A,H),Y=Math.max(L,B,A,H),X=Math.min(M,k,F,R),_t=Math.max(M,k,F,R);y.dxPixels=Q,y.dyPixels=X,y.width=Y-Q,y.height=_t-X}}}}if(g){const D=h.hasDataDrivenIcon?h.iconMaterial.encodeAttributes(e.symbolFeature.feature,l,h):null;if(this._addPlacedIcons(e,g.shapes,l,o.page,t.rotationAlignment===I.aF.VIEWPORT,D),g.iconColliders){e.iconColliders=g.iconColliders;for(const y of g.iconColliders){y.minLod=Math.max(l+(0,C.k3)(y.minLod),0),y.maxLod=Math.min(l+(0,C.k3)(y.maxLod),25);const m=y.angle;if(m){const p=Math.cos(m),P=Math.sin(m),L=y.dxPixels*p-y.dyPixels*P,M=y.dxPixels*P+y.dyPixels*p,B=(y.dxPixels+y.width)*p-y.dyPixels*P,k=(y.dxPixels+y.width)*P+y.dyPixels*p,A=y.dxPixels*p-(y.dyPixels+y.height)*P,F=y.dxPixels*P+(y.dyPixels+y.height)*p,H=(y.dxPixels+y.width)*p-(y.dyPixels+y.height)*P,R=(y.dxPixels+y.width)*P+(y.dyPixels+y.height)*p,Q=Math.min(L,B,A,H),Y=Math.max(L,B,A,H),X=Math.min(M,k,F,R),_t=Math.max(M,k,F,R);y.dxPixels=Q,y.dyPixels=X,y.width=Y-Q,y.height=_t-X}}}}}}_addPlacedIcons(e,t,n,i,o,a){const r=Math.max(n-1,0),l=this._iconVertexBuffer,h=this._iconIndexBuffer,d=this._markerMap;for(const f of t){const x=o?0:Math.max(n+(0,C.k3)(f.minzoom),r),c=o?25:Math.min(n+(0,C.k3)(f.maxzoom),25);if(c<=x)continue;const g=f.tl,_=f.tr,D=f.bl,y=f.br,m=f.mosaicRect,p=f.labelAngle,P=f.minAngle,L=f.maxAngle,M=f.anchor,B=l.index,k=m.x,A=m.y,F=k+m.width,H=A+m.height,R=l.index;l.add(M.x,M.y,g.x,g.y,k,A,p,P,L,x,c,a),l.add(M.x,M.y,_.x,_.y,F,A,p,P,L,x,c,a),l.add(M.x,M.y,D.x,D.y,k,H,p,P,L,x,c,a),l.add(M.x,M.y,y.x,y.y,F,H,p,P,L,x,c,a),e.iconVertexRanges.length>0&&e.iconVertexRanges[0][0]+e.iconVertexRanges[0][1]===R?e.iconVertexRanges[0][1]+=4:e.iconVertexRanges.push([R,4]),h.add(B,B+1,B+2),h.add(B+1,B+2,B+3),d.has(i)?d.get(i)[1]+=6:d.set(i,[this._iconIndexStart+this._iconIndexCount,6]),this._iconIndexCount+=6}}_addPlacedGlyphs(){const e=this._textVertexBuffer,t=this._textIndexBuffer,n=this._glyphMap;for(const[i,o]of this._glyphBufferDataStorage)for(const a of o){const r=e.index,l=a.symbolInstance,h=a.ddAttributes,d=e.index;e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.tl[0],a.tl[1],a.xmin,a.ymin,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,h),e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.tr[0],a.tr[1],a.xmax,a.ymin,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,h),e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.bl[0],a.bl[1],a.xmin,a.ymax,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,h),e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.br[0],a.br[1],a.xmax,a.ymax,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,h),l.textVertexRanges.length>0&&l.textVertexRanges[0][0]+l.textVertexRanges[0][1]===d?l.textVertexRanges[0][1]+=4:l.textVertexRanges.push([d,4]),t.add(r,r+1,r+2),t.add(r+1,r+2,r+3),n.has(i)?n.get(i)[1]+=6:n.set(i,[this._textIndexStart+this._textIndexCount,6]),this._textIndexCount+=6}this._glyphBufferDataStorage.clear()}_storePlacedGlyphs(e,t,n,i,o){const a=Math.max(n-1,0),r=i===I.aF.VIEWPORT;let l,h,d,f,x,c,g,_,D,y,m;for(const p of t)l=r?0:Math.max(n+(0,C.k3)(p.minzoom),a),h=r?25:Math.min(n+(0,C.k3)(p.maxzoom),25),!(h<=l)&&(d=p.tl,f=p.tr,x=p.bl,c=p.br,g=p.labelAngle,_=p.minAngle,D=p.maxAngle,y=p.anchor,m=p.mosaicRect,this._glyphBufferDataStorage.has(p.page)||this._glyphBufferDataStorage.set(p.page,[]),this._glyphBufferDataStorage.get(p.page).push({glyphAnchor:[y.x,y.y],tl:[d.x,d.y],tr:[f.x,f.y],bl:[x.x,x.y],br:[c.x,c.y],xmin:m.x,ymin:m.y,xmax:m.x+m.width,ymax:m.y+m.height,labelAngle:g,minAngle:_,maxAngle:D,minLod:l,maxLod:h,placementLod:a,symbolInstance:e,ddAttributes:o}))}static _pushAnchors(e,t,n,i){n+=i;let o=0;const a=t.length-1;for(let x=0;x<a;x++)o+=O.E9.distance(t[x],t[x+1]);let r=i||n;if(r*=.5,o<=r)return;const l=r/o;let h=0,d=-(n=o/Math.max(Math.round(o/n),1))/2;const f=t.length-1;for(let x=0;x<f;x++){const c=t[x],g=t[x+1],_=g.x-c.x,D=g.y-c.y,y=Math.sqrt(_*_+D*D);let m;for(;d+n<h+y;){d+=n;const p=(d-h)/y,P=(0,C.sX)(c.x,g.x,p),L=(0,C.sX)(c.y,g.y,p);void 0===m&&(m=Math.atan2(D,_)),e.push(new Dt(P,L,m,x,l))}h+=y}}static _pushCenterAnchor(e,t){let n=0;const i=t.length-1;for(let l=0;l<i;l++)n+=O.E9.distance(t[l],t[l+1]);const o=n/2;let a=0;const r=t.length-1;for(let l=0;l<r;l++){const h=t[l],d=t[l+1],f=d.x-h.x,x=d.y-h.y,c=Math.sqrt(f*f+x*x);if(o<a+c){const g=(o-a)/c,_=(0,C.sX)(h.x,d.x,g),D=(0,C.sX)(h.y,d.y,g),y=Math.atan2(x,f);return void e.push(new Dt(_,D,y,l,0))}a+=c}}static _deviation(e,t,n){return Math.atan2((t.x-e.x)*(n.y-t.y)-(t.y-e.y)*(n.x-t.x),(t.x-e.x)*(n.x-t.x)+(t.y-e.y)*(n.y-t.y))}static _honorsTextMaxAngle(e,t,n,i,o){let a=0;const r=n/2;let l=new O.E9(t.x,t.y),h=t.segment+1;for(;a>-r;){if(--h,h<0)return!1;a-=O.E9.distance(e[h],l),l=e[h]}a+=O.E9.distance(e[h],e[h+1]);const d=[];let f=0;const x=e.length;for(;a<r;){const c=e[h];let g,_=h;do{if(++_,_===x)return!1;g=e[_]}while(g.isEqual(c));let D,y=_;do{if(++y,y===x)return!1;D=e[y]}while(D.isEqual(g));const m=this._deviation(c,g,D);for(d.push({deviation:m,distToAnchor:a}),f+=m;a-d[0].distToAnchor>o;)f-=d.shift().deviation;if(Math.abs(f)>i)return!1;a+=O.E9.distance(g,D),h=_}return!0}static _smoothVertices(e,t){if(t<=0)return e;let n=e.length;if(n<3)return e;const i=[];let o=0,a=0;i.push(0);for(let _=1;_<n;_++){const D=O.E9.distance(e[_],e[_-1]);D>0&&(o+=D,i.push(o),a++,a!==_&&(e[a]=e[_]))}if(n=a+1,n<3)return e;t=Math.min(t,.2*o);const r=e[0].x,l=e[0].y,h=e[n-1].x,d=e[n-1].y,f=O.E9.sub(e[0],e[1]);f.normalize(),e[0].x+=t*f.x,e[0].y+=t*f.y,f.assignSub(e[n-1],e[n-2]),f.normalize(),e[n-1].x+=t*f.x,e[n-1].y+=t*f.y,i[0]-=t,i[n-1]+=t;const x=[];x.push(new O.E9(r,l));const c=1e-6,g=.5*t;for(let _=1;_<n-1;_++){let D=0,y=0,m=0;for(let p=_-1;p>=0;p--){const P=g+i[p+1]-i[_];if(P<0)break;const L=i[p+1]-i[p],M=i[_]-i[p]<g?1:P/L;if(M<c)break;const B=M*M,k=M*P-.5*B*L,A=M*L/t,F=e[p+1],H=e[p].x-F.x,R=e[p].y-F.y;D+=A/k*(F.x*M*P+.5*B*(P*H-L*F.x)-B*M*L*H/3),y+=A/k*(F.y*M*P+.5*B*(P*R-L*F.y)-B*M*L*R/3),m+=A}for(let p=_+1;p<n;p++){const P=g-i[p-1]+i[_];if(P<0)break;const L=i[p]-i[p-1],M=i[p]-i[_]<g?1:P/L;if(M<c)break;const B=M*M,k=M*P-.5*B*L,A=M*L/t,F=e[p-1],H=e[p].x-F.x,R=e[p].y-F.y;D+=A/k*(F.x*M*P+.5*B*(P*H-L*F.x)-B*M*L*H/3),y+=A/k*(F.y*M*P+.5*B*(P*R-L*F.y)-B*M*L*R/3),m+=A}x.push(new O.E9(D/m,y/m))}return x.push(new O.E9(h,d)),e[0].x=r,e[0].y=l,e[n-1].x=h,e[n-1].y=d,x}static _pushCentroid(e,t){const r=t.length-1;let l=0,h=0,d=0,f=t[0].x,x=t[0].y;f>4096&&(f=4096),f<0&&(f=0),x>4096&&(x=4096),x<0&&(x=0);for(let c=1;c<r;c++){let g=t[c].x,_=t[c].y,D=t[c+1].x,y=t[c+1].y;g>4096&&(g=4096),g<0&&(g=0),_>4096&&(_=4096),_<0&&(_=0),D>4096&&(D=4096),D<0&&(D=0),y>4096&&(y=4096),y<0&&(y=0);const m=(g-f)*(y-x)-(D-f)*(_-x);l+=m*(f+g+D),h+=m*(x+_+y),d+=m}l/=3*d,h/=3*d,isNaN(l)||isNaN(h)||e.push(new Dt(l,h))}}q._bidiEngine=new rt.Z,(u=dt||(dt={}))[u.INITIALIZED=0]="INITIALIZED",u[u.NO_DATA=1]="NO_DATA",u[u.READY=2]="READY",u[u.MODIFIED=3]="MODIFIED",u[u.INVALID=4]="INVALID";class Lt{constructor(e,t,n,i,o,a){if(this._pbfTiles={},this._tileClippers={},this._client=n,this._tile=t,this._sourceDataMaxLOD=i,a){this._styleLayerUIDs=new Set;for(const f of a)this._styleLayerUIDs.add(f)}this._styleRepository=o,this._layers=this._styleRepository?.layers??[];const[r,l,h]=t.tileKey.split("/").map(parseFloat);this._level=r;const d=(0,C.KU)(this._level);for(const f of Object.keys(e)){const x=e[f];if(this._pbfTiles[f]=new Mt.Z(new Uint8Array(x.protobuff),new DataView(x.protobuff)),x.refKey){const[c]=x.refKey.split("/").map(parseFloat),g=r-c;if(g>0){const _=(1<<g)-1;this._tileClippers[f]=new O.bN(g,l&_,h&_,8,d)}}this._tileClippers[f]||(this._tileClippers[f]=new O.I6)}}_canParseStyleLayer(e){return!this._styleLayerUIDs||this._styleLayerUIDs.has(e)}parse(e){var t=this;return(0,Z.Z)(function*(){const n=(0,at.j)(),i=t._initialize(e),{returnedBuckets:o}=i;t._processLayers(i),t._linkReferences(i),t._filterFeatures(i);const a=[],r=new Set,l=(f,x)=>{r.has(f)||(a.push({name:f,repeat:x}),r.add(f))},h={};for(const f of o)f.getResources(f.tileClipper,l,h);if(t._tile.status===dt.INVALID)return[];const d=t._fetchResources(a,h,e);return Promise.all([...d,n]).then(()=>t._processFeatures(i.returnedBuckets))})()}_initialize(e){return{signal:e?.signal,sourceNameToTileData:this._parseTileData(this._pbfTiles),layers:this._layers,zoom:this._level,sourceNameToTileClipper:this._tileClippers,sourceNameToUniqueSourceLayerBuckets:{},sourceNameToUniqueSourceLayers:{},returnedBuckets:[],layerIdToBucket:{},referencerUIDToReferencedId:new Map}}_processLayers(e){const{sourceNameToTileData:t,zoom:n,layers:i,sourceNameToTileClipper:o,sourceNameToUniqueSourceLayerBuckets:a,sourceNameToUniqueSourceLayers:r,returnedBuckets:l,layerIdToBucket:h,referencerUIDToReferencedId:d}=e,f=this._sourceDataMaxLOD;for(let x=i.length-1;x>=0;x--){const c=i[x];if(n<f){if(c.minzoom&&n<Math.floor(c.minzoom)||c.maxzoom&&n>=c.maxzoom)continue}else if(c.maxzoom&&n>=c.maxzoom)continue;if(c.type===I.fR.BACKGROUND||!this._canParseStyleLayer(c.uid)||!t[c.source]||!o[c.source])continue;const _=o[c.source],D=c.sourceLayer,y=t[c.source][D];if(y){let m=r[c.source];if(m||(m=r[c.source]=new Set),m.add(c.sourceLayer),c.refLayerId)d.set(c.uid,c.refLayerId);else{const p=this._createBucket(c);if(p){p.layerUIDs=[c.uid],p.layerExtent=y.extent,p.tileClipper=_;let P=a[c.source];P||(P=a[c.source]={});let L=P[D];L||(L=P[D]=[]),L.push(p),l.push(p),h[c.id]=p}}}}}_linkReferences(e){const{layerIdToBucket:t,referencerUIDToReferencedId:n}=e;n.forEach((i,o)=>{t[i]&&t[i].layerUIDs.push(o)})}_filterFeatures(e){const{signal:t,sourceNameToTileData:n,sourceNameToUniqueSourceLayerBuckets:i,sourceNameToUniqueSourceLayers:o}=e,a=10*this._level,r=10*(this._level+1),l=[],h=[];for(const d of Object.keys(o))o[d].forEach(f=>{l.push(f),h.push(d)});for(let d=0;d<l.length;d++){const f=h[d],x=l[d];if(!n[f]||!i[f])continue;const c=n[f][x],g=i[f][x];if(!g||0===g.length)continue;if((0,Ot.Hc)(t))return;let _=0;const D=c.getData();for(;D.nextTag(2);){const y=D.getMessage(),m=new ft.Z(y,c,_++);y.release();const p=m.values;if(p){const P=p._minzoom;if(P&&P>=r)continue;const L=p._maxzoom;if(L&&L<=a)continue}for(const P of g)P.pushFeature(m)}}}_fetchResources(e,t,n){const i=[],o=this._tile.getWorkerTileHandler();let a,r;e.length>0&&(a=o.fetchSprites(e,this._client,n),i.push(a));for(const l in t){const h=t[l];h.size>0&&(r=o.fetchGlyphs(this._tile.tileKey,l,h,this._client,n),i.push(r))}return i}_processFeatures(e){const t=e.filter(n=>n.hasFeatures()||this._canParseStyleLayer(n.layer.uid));for(const n of t)n.processFeatures(n.tileClipper);return t}_parseTileData(e){const t={};for(const n of Object.keys(e)){const i=e[n],o={};for(;i.next();)switch(i.tag()){case 3:{const a=i.getMessage(),r=new b.Z(a);a.release(),o[r.name]=r;break}default:i.skip()}t[n]=o}return t}_createBucket(e){switch(e.type){case I.fR.BACKGROUND:return null;case I.fR.FILL:return this._createFillBucket(e);case I.fR.LINE:return this._createLineBucket(e);case I.fR.CIRCLE:return this._createCircleBucket(e);case I.fR.SYMBOL:return this._createSymbolBucket(e)}}_createFillBucket(e){return new $(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new zt(e.fillMaterial.getStride()),new K,new At(e.outlineMaterial.getStride()),new K)}_createLineBucket(e){return new it(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new w(e.lineMaterial.getStride()),new K)}_createCircleBucket(e){return new Jt(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new nt(e.circleMaterial.getStride()),new K)}_createSymbolBucket(e){const t=this._tile;return new q(t.tileKey,e,this._level,new j(e.iconMaterial.getStride()),new K,new j(e.textMaterial.getStride()),new K,t.placementEngine,t.getWorkerTileHandler())}}class W{constructor(e,t,n,i){this.status=dt.INITIALIZED,this.placementEngine=new Et,this.tileKey=e,this.refKeys=t,this._workerTileHandler=n,this._styleRepository=i}release(){this.tileKey="",this.refKeys=null,this.status=dt.INITIALIZED,this._workerTileHandler=null}parse(e,t){var n=this;return(0,Z.Z)(function*(){const i=t?.signal;if(null!=i){const f=()=>{i.removeEventListener("abort",f),n.status=dt.INVALID};i.addEventListener("abort",f)}let o;const a={bucketsWithData:[],emptyBuckets:null};try{o=yield n._parse(e,t)}catch(f){if((0,Ot.D_)(f))throw f;return{result:a,transferList:[]}}n.status=dt.READY;const r=a.bucketsWithData,l=[];for(const f of o)if(f.hasFeatures()){const x=f.serialize();r.push(x)}else l.push(f.layer.uid);const h=[...r];let d=null;return l.length>0&&(d=Uint32Array.from(l),h.push(d.buffer)),a.emptyBuckets=d,{result:a,transferList:h}})()}setObsolete(){this.status=dt.INVALID}getLayers(){return this._workerTileHandler.getLayers()}getWorkerTileHandler(){return this._workerTileHandler}_parse(e,t){var n=this;return(0,Z.Z)(function*(){const i=e.sourceName2DataAndRefKey;return 0===Object.keys(i).length?[]:(n.status=dt.MODIFIED,new Lt(i,n,t.client,e.sourceDataMaxLOD,n._styleRepository,e.styleLayerUIDs).parse(t))})()}}var xt=U(78364);class kt{constructor(){this._spriteInfo={},this._glyphInfo={},this._sourceDataMaxLOD=25}reset(){return this._spriteInfo={},this._glyphInfo={},Promise.resolve()}getLayers(){return this._styleRepository?.layers??[]}createTileAndParse(e,t){var n=this;return(0,Z.Z)(function*(){const{key:i}=e,o={};for(const r of Object.keys(e.sourceName2DataAndRefKey))o[r]=e.sourceName2DataAndRefKey[r].refKey;const a=new W(i,o,n,n._styleRepository);try{return yield a.parse({...e,sourceDataMaxLOD:n._sourceDataMaxLOD},t)}catch(r){if(a.setObsolete(),a.release(),!(0,Ot.D_)(r))throw r;return null}})()}updateStyle(e){if(!e||0===e.length||!this._styleRepository)return;const t=this._styleRepository;for(const n of e){const o=n.data;switch(n.type){case tt.Fr.PAINTER_CHANGED:t.setPaintProperties(o.layer,o.paint);break;case tt.Fr.LAYOUT_CHANGED:t.setLayoutProperties(o.layer,o.layout);break;case tt.Fr.LAYER_REMOVED:t.deleteStyleLayer(o.layer);break;case tt.Fr.LAYER_CHANGED:t.setStyleLayer(o.layer,o.index);break;case tt.Fr.SPRITES_CHANGED:this._spriteInfo={}}}}setStyle(e){const{style:t,sourceDataMaxLOD:n}=e;this._styleRepository=new xt.Z(t),this._sourceDataMaxLOD=n,this._spriteInfo={},this._glyphInfo={}}fetchSprites(e,t,n){const i=[],o=this._spriteInfo;for(const a of e)void 0===o[a.name]&&i.push(a);return 0===i.length?Promise.resolve():t.invoke("getSprites",i,{signal:n?.signal}).then(a=>{for(const r in a)o[r]=a[r]})}getSpriteItems(){return this._spriteInfo}fetchGlyphs(e,t,n,i,o){const a=[];let r=this._glyphInfo[t];return r?n.forEach(l=>{r[l]||a.push(l)}):(r=this._glyphInfo[t]=[],n.forEach(l=>a.push(l))),0===a.length?Promise.resolve():i.invoke("getGlyphs",{tileID:e,font:t,codePoints:a},o).then(l=>{for(let h=0;h<l.length;h++)l[h]&&(r[h]=l[h])})}getGlyphItems(e){return this._glyphInfo[e]}}},46519:(oe,Ut,U)=>{U.d(Ut,{z:()=>z});var Z=U(7547),Ot=U(39351);function tt(S,I){return S.x===I.x&&S.y===I.y}function C(S,I){return S.x=I.y,S.y=-I.x,S}function ht(S,I){return S.x=-I.y,S.y=I.x,S}function wt(S,I){return S.x=I.x,S.y=I.y,S}function et(S,I){return S.x=-I.x,S.y=-I.y,S}function T(S){return Math.sqrt(S.x*S.x+S.y*S.y)}function E(S,I){return S.x*I.y-S.y*I.x}function v(S,I){return S.x*I.x+S.y*I.y}function V(S,I,G,ct){return S.x=I.x*G+I.y*ct,S.y=I.x*ct-I.y*G,S}class z{constructor(I,G,ct){this._writeVertex=I,this._writeTriangle=G,this._canUseThinTessellation=ct,this._prevNormal={x:void 0,y:void 0},this._nextNormal={x:void 0,y:void 0},this._textureNormalLeft={x:0,y:1},this._textureNormalRight={x:0,y:-1},this._textureNormal={x:void 0,y:void 0},this._joinNormal={x:void 0,y:void 0},this._inner={x:void 0,y:void 0},this._outer={x:void 0,y:void 0},this._roundStart={x:void 0,y:void 0},this._roundEnd={x:void 0,y:void 0},this._startBreak={x:void 0,y:void 0},this._endBreak={x:void 0,y:void 0},this._innerPrev={x:void 0,y:void 0},this._innerNext={x:void 0,y:void 0},this._bevelStart={x:void 0,y:void 0},this._bevelEnd={x:void 0,y:void 0},this._bevelMiddle={x:void 0,y:void 0}}tessellate(I,G,ct=this._canUseThinTessellation){(function O(S){if(!S)return;const I=S.length;if(I<=1)return;let G=0;for(let ct=1;ct<I;ct++)tt(S[ct],S[G])||++G===ct||(S[G]=S[ct]);S.length=G+1})(I),ct&&G.halfWidth<Ot.do&&!G.offset?this._tessellateThin(I,G):this._tessellate(I,G)}_tessellateThin(I,G){if(I.length<2)return;const ct=G.wrapDistance||65535;let ut=G.initialDistance||0,pt=!1,Vt=I[0].x,Dt=I[0].y;const It=I.length;for(let bt=1;bt<It;++bt){pt&&(pt=!1,ut=0);let Bt=I[bt].x,Et=I[bt].y,Mt=Bt-Vt,at=Et-Dt,ft=Math.sqrt(Mt*Mt+at*at);if(Mt/=ft,at/=ft,ut+ft>ct){pt=!0;const w=(ct-ut)/ft;ft=ct-ut,Bt=(1-w)*Vt+w*Bt,Et=(1-w)*Dt+w*Et,--bt}const N=this._writeVertex(Vt,Dt,0,0,Mt,at,at,-Mt,0,-1,ut),K=this._writeVertex(Vt,Dt,0,0,Mt,at,-at,Mt,0,1,ut);ut+=ft;const Nt=this._writeVertex(Bt,Et,0,0,Mt,at,at,-Mt,0,-1,ut),b=this._writeVertex(Bt,Et,0,0,Mt,at,-at,Mt,0,1,ut);this._writeTriangle(N,K,Nt),this._writeTriangle(K,Nt,b),Vt=Bt,Dt=Et}}_tessellate(I,G){const ut=I[I.length-1],pt=tt(I[0],ut);if(I.length<(pt?3:2))return;const Dt=G.pixelCoordRatio,It=null!=G.capType?G.capType:Z.RL.BUTT,bt=null!=G.joinType?G.joinType:Z.AH.MITER,Bt=null!=G.miterLimit?Math.min(G.miterLimit,4):2,Et=null!=G.roundLimit?Math.min(G.roundLimit,1.05):1.05,Mt=null!=G.halfWidth?G.halfWidth:2,at=!!G.textured;let ft,N,K,Nt=null;const b=this._prevNormal,w=this._nextNormal;let zt=-1,At=-1;const j=this._joinNormal;let nt,J;const Jt=this._textureNormalLeft,Kt=this._textureNormalRight,ot=this._textureNormal;let $=-1,st=-1;const $t=G.wrapDistance||65535;let it=G.initialDistance||0;const le=this._writeVertex,he=this._writeTriangle,rt=(Pt,jt,Rt,yt,q,dt)=>{const Lt=le(N,K,nt,J,Rt,yt,Pt,jt,q,dt,it);return $>=0&&st>=0&&Lt>=0&&he($,st,Lt),$=st,st=Lt,Lt};pt&&(ft=I[I.length-2],w.x=ut.x-ft.x,w.y=ut.y-ft.y,At=T(w),w.x/=At,w.y/=At);let Gt=!1;for(let Pt=0;Pt<I.length;++Pt){if(Gt&&(Gt=!1,it=0),ft&&(b.x=-w.x,b.y=-w.y,zt=At,it+zt>$t&&(Gt=!0)),Gt){const W=($t-it)/zt;zt=$t-it,ft={x:(1-W)*ft.x+W*I[Pt].x,y:(1-W)*ft.y+W*I[Pt].y},--Pt}else ft=I[Pt];N=ft.x,K=ft.y;const jt=Pt<=0&&!Gt,Rt=Pt===I.length-1;if(jt||(it+=zt),Nt=Rt?pt?I[1]:null:I[Pt+1],Nt?(w.x=Nt.x-N,w.y=Nt.y-K,At=T(w),w.x/=At,w.y/=At):(w.x=void 0,w.y=void 0),!pt){if(jt){ht(j,w),nt=j.x,J=j.y,It===Z.RL.SQUARE&&(rt(-w.y-w.x,w.x-w.y,w.x,w.y,0,-1),rt(w.y-w.x,-w.x-w.y,w.x,w.y,0,1)),It===Z.RL.ROUND&&(rt(-w.y-w.x,w.x-w.y,w.x,w.y,-1,-1),rt(w.y-w.x,-w.x-w.y,w.x,w.y,-1,1)),It!==Z.RL.ROUND&&It!==Z.RL.BUTT||(rt(-w.y,w.x,w.x,w.y,0,-1),rt(w.y,-w.x,w.x,w.y,0,1));continue}if(Rt){C(j,b),nt=j.x,J=j.y,It!==Z.RL.ROUND&&It!==Z.RL.BUTT||(rt(b.y,-b.x,-b.x,-b.y,0,-1),rt(-b.y,b.x,-b.x,-b.y,0,1)),It===Z.RL.SQUARE&&(rt(b.y-b.x,-b.x-b.y,-b.x,-b.y,0,-1),rt(-b.y-b.x,b.x-b.y,-b.x,-b.y,0,1)),It===Z.RL.ROUND&&(rt(b.y-b.x,-b.x-b.y,-b.x,-b.y,1,-1),rt(-b.y-b.x,b.x-b.y,-b.x,-b.y,1,1));continue}}let yt,q,dt=-E(b,w);if(Math.abs(dt)<.01)v(b,w)>0?(j.x=b.x,j.y=b.y,dt=1,yt=Number.MAX_VALUE,q=!0):(ht(j,w),dt=1,yt=1,q=!1);else{j.x=(b.x+w.x)/dt,j.y=(b.y+w.y)/dt,yt=T(j);const W=(yt-1)*Mt*Dt;q=yt>4||W>zt&&W>At}nt=j.x,J=j.y;let Lt=bt;switch(bt){case Z.AH.BEVEL:yt<1.05&&(Lt=Z.AH.MITER);break;case Z.AH.ROUND:yt<Et&&(Lt=Z.AH.MITER);break;case Z.AH.MITER:yt>Bt&&(Lt=Z.AH.BEVEL)}switch(Lt){case Z.AH.MITER:if(rt(j.x,j.y,-b.x,-b.y,0,-1),rt(-j.x,-j.y,-b.x,-b.y,0,1),Rt)break;if(at){const W=Gt?0:it;$=this._writeVertex(N,K,nt,J,w.x,w.y,j.x,j.y,0,-1,W),st=this._writeVertex(N,K,nt,J,w.x,w.y,-j.x,-j.y,0,1,W)}break;case Z.AH.BEVEL:{const W=dt<0;let xt,gt,kt,u;if(W){const i=$;$=st,st=i,xt=Jt,gt=Kt}else xt=Kt,gt=Jt;if(q)kt=W?ht(this._innerPrev,b):C(this._innerPrev,b),u=W?C(this._innerNext,w):ht(this._innerNext,w);else{const i=W?et(this._inner,j):wt(this._inner,j);kt=i,u=i}const e=W?C(this._bevelStart,b):ht(this._bevelStart,b);rt(kt.x,kt.y,-b.x,-b.y,xt.x,xt.y);const t=rt(e.x,e.y,-b.x,-b.y,gt.x,gt.y);if(Rt)break;const n=W?ht(this._bevelEnd,w):C(this._bevelEnd,w);if(q){const i=this._writeVertex(N,K,nt,J,-b.x,-b.y,0,0,0,0,it);$=this._writeVertex(N,K,nt,J,w.x,w.y,u.x,u.y,xt.x,xt.y,it),st=this._writeVertex(N,K,nt,J,w.x,w.y,n.x,n.y,gt.x,gt.y,it),this._writeTriangle(t,i,st)}else{if(at){const i=this._bevelMiddle;i.x=(e.x+n.x)/2,i.y=(e.y+n.y)/2,V(ot,i,-b.x,-b.y),rt(i.x,i.y,-b.x,-b.y,ot.x,ot.y),V(ot,i,w.x,w.y),$=this._writeVertex(N,K,nt,J,w.x,w.y,i.x,i.y,ot.x,ot.y,it),st=this._writeVertex(N,K,nt,J,w.x,w.y,u.x,u.y,xt.x,xt.y,it)}else{const i=$;$=st,st=i}rt(n.x,n.y,w.x,w.y,gt.x,gt.y)}if(W){const i=$;$=st,st=i}break}case Z.AH.ROUND:{const W=dt<0;let xt,gt;if(W){const m=$;$=st,st=m,xt=Jt,gt=Kt}else xt=Kt,gt=Jt;const kt=W?et(this._inner,j):wt(this._inner,j);let u,e;q?(u=W?ht(this._innerPrev,b):C(this._innerPrev,b),e=W?C(this._innerNext,w):ht(this._innerNext,w)):(u=kt,e=kt);const t=W?C(this._roundStart,b):ht(this._roundStart,b),n=W?ht(this._roundEnd,w):C(this._roundEnd,w),i=rt(u.x,u.y,-b.x,-b.y,xt.x,xt.y),o=rt(t.x,t.y,-b.x,-b.y,gt.x,gt.y);if(Rt)break;const a=this._writeVertex(N,K,nt,J,-b.x,-b.y,0,0,0,0,it);q||this._writeTriangle($,st,a);const r=et(this._outer,kt),l=this._writeVertex(N,K,nt,J,w.x,w.y,n.x,n.y,gt.x,gt.y,it);let h,d;const f=yt>2;if(f){let m;yt!==Number.MAX_VALUE?(r.x/=yt,r.y/=yt,m=v(b,r),m=(yt*(m*m-1)+1)/m):m=-1,h=W?C(this._startBreak,b):ht(this._startBreak,b),h.x+=b.x*m,h.y+=b.y*m,d=W?ht(this._endBreak,w):C(this._endBreak,w),d.x+=w.x*m,d.y+=w.y*m}V(ot,r,-b.x,-b.y);const x=this._writeVertex(N,K,nt,J,-b.x,-b.y,r.x,r.y,ot.x,ot.y,it);V(ot,r,w.x,w.y);const c=at?this._writeVertex(N,K,nt,J,w.x,w.y,r.x,r.y,ot.x,ot.y,it):x,g=a,_=at?this._writeVertex(N,K,nt,J,w.x,w.y,0,0,0,0,it):a;let D=-1,y=-1;if(f&&(V(ot,h,-b.x,-b.y),D=this._writeVertex(N,K,nt,J,-b.x,-b.y,h.x,h.y,ot.x,ot.y,it),V(ot,d,w.x,w.y),y=this._writeVertex(N,K,nt,J,w.x,w.y,d.x,d.y,ot.x,ot.y,it)),at?f?(this._writeTriangle(g,o,D),this._writeTriangle(g,D,x),this._writeTriangle(_,c,y),this._writeTriangle(_,y,l)):(this._writeTriangle(g,o,x),this._writeTriangle(_,c,l)):f?(this._writeTriangle(a,o,D),this._writeTriangle(a,D,y),this._writeTriangle(a,y,l)):(this._writeTriangle(a,o,x),this._writeTriangle(a,c,l)),q?($=this._writeVertex(N,K,nt,J,w.x,w.y,e.x,e.y,xt.x,xt.y,it),st=l):($=at?this._writeVertex(N,K,nt,J,w.x,w.y,e.x,e.y,xt.x,xt.y,it):i,this._writeTriangle($,_,l),st=l),W){const m=$;$=st,st=m}break}}}}}}}]);