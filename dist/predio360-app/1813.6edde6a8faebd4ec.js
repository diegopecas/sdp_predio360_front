"use strict";(self.webpackChunkpredio360_app=self.webpackChunkpredio360_app||[]).push([[1813],{7547:(q,x,i)=>{var _,v,p,c,y,g,h,n,U,M,A,O,R,f,T,w,E,l,C,L,F,P,ee,ce,j,X,ne,Y,K,te,ie,oe,ae,b,J,H,z,re,le,W,se,D,fe,m,t,o,a,d,r,s,u,I,N,G,de,V,k,Q,$,me,S,e;i.d(x,{$y:()=>P,AH:()=>v,CS:()=>a,DD:()=>n,Dd:()=>K,Em:()=>F,JS:()=>t,Ky:()=>U,Lh:()=>d,Qb:()=>k,RL:()=>_,RS:()=>$,TF:()=>L,Tx:()=>y,UR:()=>E,UX:()=>V,bj:()=>o,eZ:()=>h,id:()=>j,kP:()=>H,of:()=>A,r4:()=>W,sj:()=>z,v2:()=>p,zQ:()=>Y,zV:()=>w}),(e=_||(_={}))[e.BUTT=0]="BUTT",e[e.ROUND=1]="ROUND",e[e.SQUARE=2]="SQUARE",e[e.UNKNOWN=4]="UNKNOWN",function(e){e[e.BEVEL=0]="BEVEL",e[e.ROUND=1]="ROUND",e[e.MITER=2]="MITER",e[e.UNKNOWN=4]="UNKNOWN"}(v||(v={})),function(e){e[e.SCREEN=0]="SCREEN",e[e.MAP=1]="MAP"}(p||(p={})),function(e){e[e.Tint=0]="Tint",e[e.Ignore=1]="Ignore",e[e.Multiply=99]="Multiply"}(c||(c={})),function(e){e.Both="Both",e.JustBegin="JustBegin",e.JustEnd="JustEnd",e.None="None"}(y||(y={})),function(e){e[e.Mosaic=0]="Mosaic",e[e.Centered=1]="Centered"}(g||(g={})),function(e){e[e.Normal=0]="Normal",e[e.Superscript=1]="Superscript",e[e.Subscript=2]="Subscript"}(h||(h={})),function(e){e[e.MSSymbol=0]="MSSymbol",e[e.Unicode=1]="Unicode"}(n||(n={})),function(e){e[e.Unspecified=0]="Unspecified",e[e.TrueType=1]="TrueType",e[e.PSOpenType=2]="PSOpenType",e[e.TTOpenType=3]="TTOpenType",e[e.Type1=4]="Type1"}(U||(U={})),function(e){e[e.Display=0]="Display",e[e.Map=1]="Map"}(M||(M={})),function(e){e.None="None",e.Loop="Loop",e.Oscillate="Oscillate"}(A||(A={})),function(e){e[e.Z=0]="Z",e[e.X=1]="X",e[e.Y=2]="Y"}(O||(O={})),function(e){e[e.XYZ=0]="XYZ",e[e.ZXY=1]="ZXY",e[e.YXZ=2]="YXZ"}(R||(R={})),function(e){e[e.Rectangle=0]="Rectangle",e[e.RoundedRectangle=1]="RoundedRectangle",e[e.Oval=2]="Oval"}(f||(f={})),function(e){e[e.None=0]="None",e[e.Alpha=1]="Alpha",e[e.Screen=2]="Screen",e[e.Multiply=3]="Multiply",e[e.Add=4]="Add"}(T||(T={})),function(e){e[e.TTB=0]="TTB",e[e.RTL=1]="RTL",e[e.BTT=2]="BTT"}(w||(w={})),function(e){e[e.None=0]="None",e[e.SignPost=1]="SignPost",e[e.FaceNearPlane=2]="FaceNearPlane"}(E||(E={})),function(e){e[e.Float=0]="Float",e[e.String=1]="String",e[e.Boolean=2]="Boolean"}(l||(l={})),function(e){e[e.Intersect=0]="Intersect",e[e.Subtract=1]="Subtract"}(C||(C={})),function(e){e.OpenEnded="OpenEnded",e.Block="Block",e.Crossed="Crossed"}(L||(L={})),function(e){e.FullGeometry="FullGeometry",e.PerpendicularFromFirstSegment="PerpendicularFromFirstSegment",e.ReversedFirstSegment="ReversedFirstSegment",e.PerpendicularToSecondSegment="PerpendicularToSecondSegment",e.SecondSegmentWithTicks="SecondSegmentWithTicks",e.DoublePerpendicular="DoublePerpendicular",e.OppositeToFirstSegment="OppositeToFirstSegment",e.TriplePerpendicular="TriplePerpendicular",e.HalfCircleFirstSegment="HalfCircleFirstSegment",e.HalfCircleSecondSegment="HalfCircleSecondSegment",e.HalfCircleExtended="HalfCircleExtended",e.OpenCircle="OpenCircle",e.CoverageEdgesWithTicks="CoverageEdgesWithTicks",e.GapExtentWithDoubleTicks="GapExtentWithDoubleTicks",e.GapExtentMidline="GapExtentMidline",e.Chevron="Chevron",e.PerpendicularWithArc="PerpendicularWithArc",e.ClosedHalfCircle="ClosedHalfCircle",e.TripleParallelExtended="TripleParallelExtended",e.ParallelWithTicks="ParallelWithTicks",e.Parallel="Parallel",e.PerpendicularToFirstSegment="PerpendicularToFirstSegment",e.ParallelOffset="ParallelOffset",e.OffsetOpposite="OffsetOpposite",e.OffsetSame="OffsetSame",e.CircleWithArc="CircleWithArc",e.DoubleJog="DoubleJog",e.PerpendicularOffset="PerpendicularOffset",e.LineExcludingLastSegment="LineExcludingLastSegment",e.MultivertexArrow="MultivertexArrow",e.CrossedArrow="CrossedArrow",e.ChevronArrow="ChevronArrow",e.ChevronArrowOffset="ChevronArrowOffset",e.PartialFirstSegment="PartialFirstSegment",e.Arch="Arch",e.CurvedParallelTicks="CurvedParallelTicks",e.Arc90Degrees="Arc90Degrees"}(F||(F={})),function(e){e.Mitered="Mitered",e.Bevelled="Bevelled",e.Rounded="Rounded",e.Square="Square",e.TrueBuffer="TrueBuffer"}(P||(P={})),function(e){e.ClosePath="ClosePath",e.ConvexHull="ConvexHull",e.RectangularBox="RectangularBox"}(ee||(ee={})),function(e){e.BeginningOfLine="BeginningOfLine",e.EndOfLine="EndOfLine"}(ce||(ce={})),function(e){e.Mitered="Mitered",e.Bevelled="Bevelled",e.Rounded="Rounded",e.Square="Square"}(j||(j={})),function(e){e.Fast="Fast",e.Accurate="Accurate"}(X||(X={})),function(e){e.BeginningOfLine="BeginningOfLine",e.EndOfLine="EndOfLine"}(ne||(ne={})),function(e){e.Sinus="Sinus",e.Square="Square",e.Triangle="Triangle",e.Random="Random"}(Y||(Y={})),function(e){e[e.None=0]="None",e[e.Default=1]="Default",e[e.Force=2]="Force"}(K||(K={})),function(e){e[e.Buffered=0]="Buffered",e[e.Left=1]="Left",e[e.Right=2]="Right",e[e.AlongLine=3]="AlongLine"}(te||(te={})),function(e){e[e.Linear=0]="Linear",e[e.Rectangular=1]="Rectangular",e[e.Circular=2]="Circular",e[e.Buffered=3]="Buffered"}(ie||(ie={})),function(e){e[e.Discrete=0]="Discrete",e[e.Continuous=1]="Continuous"}(oe||(oe={})),function(e){e[e.AcrossLine=0]="AcrossLine",e[e.AloneLine=1]="AloneLine"}(ae||(ae={})),function(e){e[e.Left=0]="Left",e[e.Right=1]="Right",e[e.Center=2]="Center",e[e.Justify=3]="Justify"}(b||(b={})),function(e){e[e.Base=0]="Base",e[e.MidPoint=1]="MidPoint",e[e.ThreePoint=2]="ThreePoint",e[e.FourPoint=3]="FourPoint",e[e.Underline=4]="Underline",e[e.CircularCW=5]="CircularCW",e[e.CircularCCW=6]="CircularCCW"}(J||(J={})),function(e){e.Butt="Butt",e.Round="Round",e.Square="Square"}(H||(H={})),function(e){e.NoConstraint="NoConstraint",e.HalfPattern="HalfPattern",e.HalfGap="HalfGap",e.FullPattern="FullPattern",e.FullGap="FullGap",e.Custom="Custom"}(z||(z={})),function(e){e[e.None=-1]="None",e[e.Custom=0]="Custom",e[e.Circle=1]="Circle",e[e.OpenArrow=2]="OpenArrow",e[e.ClosedArrow=3]="ClosedArrow",e[e.Diamond=4]="Diamond"}(re||(re={})),function(e){e[e.ExtraLeading=0]="ExtraLeading",e[e.Multiple=1]="Multiple",e[e.Exact=2]="Exact"}(le||(le={})),function(e){e.Bevel="Bevel",e.Round="Round",e.Miter="Miter"}(W||(W={})),function(e){e[e.Default=0]="Default",e[e.String=1]="String",e[e.Numeric=2]="Numeric"}(se||(se={})),function(e){e[e.InsidePolygon=0]="InsidePolygon",e[e.PolygonCenter=1]="PolygonCenter",e[e.RandomlyInsidePolygon=2]="RandomlyInsidePolygon"}(D||(D={})),function(e){e[e.Tint=0]="Tint",e[e.Replace=1]="Replace",e[e.Multiply=2]="Multiply"}(fe||(fe={})),function(e){e[e.ClipAtBoundary=0]="ClipAtBoundary",e[e.RemoveIfCenterOutsideBoundary=1]="RemoveIfCenterOutsideBoundary",e[e.DoNotTouchBoundary=2]="DoNotTouchBoundary",e[e.DoNotClip=3]="DoNotClip"}(m||(m={})),function(e){e.NoConstraint="NoConstraint",e.WithMarkers="WithMarkers",e.WithFullGap="WithFullGap",e.WithHalfGap="WithHalfGap",e.Custom="Custom"}(t||(t={})),function(e){e.Fixed="Fixed",e.Random="Random",e.RandomFixedQuantity="RandomFixedQuantity"}(o||(o={})),function(e){e.LineMiddle="LineMiddle",e.LineBeginning="LineBeginning",e.LineEnd="LineEnd",e.SegmentMidpoint="SegmentMidpoint"}(a||(a={})),function(e){e.OnPolygon="OnPolygon",e.CenterOfMass="CenterOfMass",e.BoundingBoxCenter="BoundingBoxCenter"}(d||(d={})),function(e){e[e.Low=0]="Low",e[e.Medium=1]="Medium",e[e.High=2]="High"}(r||(r={})),function(e){e[e.MarkerCenter=0]="MarkerCenter",e[e.MarkerBounds=1]="MarkerBounds"}(s||(s={})),function(e){e[e.None=0]="None",e[e.PropUniform=1]="PropUniform",e[e.PropNonuniform=2]="PropNonuniform",e[e.DifUniform=3]="DifUniform",e[e.DifNonuniform=4]="DifNonuniform"}(u||(u={})),function(e){e.Tube="Tube",e.Strip="Strip",e.Wall="Wall"}(I||(I={})),function(e){e[e.Random=0]="Random",e[e.Increasing=1]="Increasing",e[e.Decreasing=2]="Decreasing",e[e.IncreasingThenDecreasing=3]="IncreasingThenDecreasing"}(N||(N={})),function(e){e[e.Relative=0]="Relative",e[e.Absolute=1]="Absolute"}(G||(G={})),function(e){e[e.Normal=0]="Normal",e[e.LowerCase=1]="LowerCase",e[e.Allcaps=2]="Allcaps"}(de||(de={})),function(e){e[e.LTR=0]="LTR",e[e.RTL=1]="RTL"}(V||(V={})),function(e){e.Draft="Draft",e.Picture="Picture",e.Text="Text"}(k||(k={})),function(e){e[e.Top=0]="Top",e[e.Center=1]="Center",e[e.Baseline=2]="Baseline",e[e.Bottom=3]="Bottom"}(Q||(Q={})),function(e){e[e.Right=0]="Right",e[e.Upright=1]="Upright"}($||($={})),function(e){e[e.Small=0]="Small",e[e.Medium=1]="Medium",e[e.Large=2]="Large"}(me||(me={})),function(e){e[e.Calm=0]="Calm",e[e.Rippled=1]="Rippled",e[e.Slight=2]="Slight",e[e.Moderate=3]="Moderate"}(S||(S={}))},31656:(q,x,i)=>{i.d(x,{w:()=>y});const _={background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","background.vert":"precision mediump float;\nattribute vec2 a_pos;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},circle:{"circle.frag":"precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","circle.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},fill:{"fill.frag":"precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","fill.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},icon:{"icon.frag":"precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_tex = a_tex.xy / u_mosaicSize;\n}"},line:{"line.frag":"precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","line.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}","util.glsl":"float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}"}},c=new(i(7423).B)(function p(g){let h=_;return g.split("/").forEach(n=>{h&&(h=h[n])}),h});function y(g){return c.resolveIncludes(g)}},39351:(q,x,i)=>{i.d(x,{$0:()=>A,AI:()=>p,Al:()=>X,By:()=>oe,C1:()=>e,CQ:()=>B,CU:()=>N,D3:()=>j,Ex:()=>F,I_:()=>g,Ic:()=>ne,Ij:()=>te,Ip:()=>Q,Iv:()=>ge,Iw:()=>P,Jw:()=>H,MI:()=>S,QU:()=>J,SD:()=>he,Tz:()=>ue,Uh:()=>Z,V4:()=>I,XD:()=>xe,XJ:()=>k,Xj:()=>b,Zd:()=>a,_5:()=>le,_6:()=>ve,a:()=>G,aK:()=>D,dn:()=>u,e0:()=>_e,eF:()=>ee,eV:()=>O,f2:()=>ie,fL:()=>V,iJ:()=>Y,iV:()=>d,jk:()=>ye,kF:()=>z,lK:()=>m,m4:()=>t,mx:()=>ae,nM:()=>K,nb:()=>Se,oK:()=>pe,pU:()=>se,ru:()=>y,tQ:()=>s,u4:()=>Ce,uG:()=>o,vw:()=>Te,xl:()=>W,xm:()=>R,yP:()=>re});const p=1e-30,y=4294967295,g=512,A=8,O=10,R=29,F=24,P=8,ee={metrics:{width:15,height:17,left:0,top:-7,advance:14}},j=0,X=0,ne=0,Y=1,K=2,te=3,ie=4,oe=5,ae=6,b=12,J=5,H=6,z=5,re=6,le=0,W=1,se=2,D=3,m=4,t=2,o=1,a=2,d=4,s=1.05,u=3,I=5,N=6,G=1.15,V=2,k=8,Q=500,S=10,e=1024,Z=2,B=0,ue=1,pe=4,_e=8,ge=16,ve=4,he=1,ye=4,Te=8,Ce=128,Se=4,xe=2},39406:(q,x,i)=>{var _,v,p,c,y,g,h,n;i.d(x,{LW:()=>_,Un:()=>g,X:()=>c,jx:()=>v,mD:()=>h,mf:()=>y,pc:()=>p}),(n=_||(_={}))[n.FILL=0]="FILL",n[n.LINE=1]="LINE",n[n.MARKER=2]="MARKER",n[n.TEXT=3]="TEXT",n[n.LABEL=4]="LABEL",function(n){n[n.NONE=0]="NONE",n[n.MAP=1]="MAP",n[n.LABEL=2]="LABEL",n[n.LABEL_ALPHA=4]="LABEL_ALPHA",n[n.HITTEST=8]="HITTEST",n[n.HIGHLIGHT=16]="HIGHLIGHT",n[n.CLIP=32]="CLIP",n[n.DEBUG=64]="DEBUG",n[n.NUM_DRAW_PHASES=9]="NUM_DRAW_PHASES"}(v||(v={})),function(n){n[n.SIZE=0]="SIZE",n[n.COLOR=1]="COLOR",n[n.OPACITY=2]="OPACITY",n[n.ROTATION=3]="ROTATION"}(p||(p={})),function(n){n[n.NONE=0]="NONE",n[n.OPACITY=1]="OPACITY",n[n.COLOR=2]="COLOR",n[n.ROTATION=4]="ROTATION",n[n.SIZE_MINMAX_VALUE=8]="SIZE_MINMAX_VALUE",n[n.SIZE_SCALE_STOPS=16]="SIZE_SCALE_STOPS",n[n.SIZE_FIELD_STOPS=32]="SIZE_FIELD_STOPS",n[n.SIZE_UNIT_VALUE=64]="SIZE_UNIT_VALUE"}(c||(c={})),function(n){n[n.MINMAX_TARGETS_OUTLINE=128]="MINMAX_TARGETS_OUTLINE",n[n.SCALE_TARGETS_OUTLINE=256]="SCALE_TARGETS_OUTLINE",n[n.FIELD_TARGETS_OUTLINE=512]="FIELD_TARGETS_OUTLINE",n[n.UNIT_TARGETS_OUTLINE=1024]="UNIT_TARGETS_OUTLINE"}(y||(y={})),function(n){n[n.SPRITE=0]="SPRITE",n[n.GLYPH=1]="GLYPH"}(g||(g={})),function(n){n[n.DEFAULT=0]="DEFAULT",n[n.SIMPLE=1]="SIMPLE",n[n.DOT_DENSITY=2]="DOT_DENSITY",n[n.OUTLINE_FILL=3]="OUTLINE_FILL",n[n.OUTLINE_FILL_SIMPLE=4]="OUTLINE_FILL_SIMPLE",n[n.HEATMAP=5]="HEATMAP",n[n.PIE_CHART=6]="PIE_CHART"}(h||(h={}))},5254:(q,x,i)=>{i.d(x,{Au:()=>O,Jz:()=>T,UJ:()=>f});const _=new Float32Array(1);function O(l){return[255&l,(65280&l)>>>8,(16711680&l)>>>16,(4278190080&l)>>>24]}function f(l,C){return 65535&l|C<<16}function T(l,C,L,F){return 255&l|(255&C)<<8|(255&L)<<16|F<<24}new Uint32Array(_.buffer)},19702:(q,x,i)=>{i.d(x,{A:()=>A});var _=i(15861),v=i(17626),p=i(54024),c=i(10699),y=i(32917),g=i(77712),U=(i(90912),i(85931),i(76898)),M=i(36947);const A=O=>{let R=class extends O{constructor(){super(...arguments),this.slicePlaneEnabled=!1,this.supportsHeightUnitConversion=!1}postscript(f){super.postscript(f),(0,M.qC)(this.layer)&&this.addResolvingPromise(this._validateHeightModelInfo())}_validateHeightModelInfo(){var f=this;return(0,_.Z)(function*(){const T=new AbortController,w=T.signal;f.handles.add((0,p.kB)(()=>T.abort())),yield(0,y.N1)(()=>f.view.defaultsFromMap?.heightModelInfoReady,w),(0,c.k_)(w);const E=(0,M.Wt)(f.layer,f.view.heightModelInfo,f.supportsHeightUnitConversion);if(E)throw E})()}canResume(){const f=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return super.canResume()&&(!f||!f.minScale||!f.maxScale||f.minScale>=f.maxScale)}getSuspendInfo(){const f=super.getSuspendInfo(),T=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return T&&T.minScale&&T.maxScale&&T.minScale<T.maxScale&&(f.outsideScaleRange=!0),f}};return(0,v._)([(0,g.Cb)()],R.prototype,"view",void 0),(0,v._)([(0,g.Cb)()],R.prototype,"slicePlaneEnabled",void 0),R=(0,v._)([(0,U.j)("esri.views.3d.layers.LayerView3D")],R),R}},76522:(q,x,i)=>{i.r(x),i.d(x,{default:()=>fe});var _=i(15861),v=i(17626),p=i(26584),c=i(62208),y=i(10699),g=i(32917),h=i(77712),M=(i(90912),i(85931),i(76898));class A{constructor(t,o){this._lockedSchemaPixelSize=t,this._isGCS=o}getLevelRowColumn(t){return this._isGCS?[t[0],t[1]>>1,t[2]>>1]:256===this._lockedSchemaPixelSize&&t[0]>0?[t[0]-1,t[1]>>1,t[2]>>1]:t}adjustLevel(t){return this._isGCS?t:256===this._lockedSchemaPixelSize?t>0?t-1:0:t}getShift(t,o){let a=0,d=0;return(256===this._lockedSchemaPixelSize||this._isGCS)&&(t[2]%2&&(a=o),t[1]%2&&(d=o)),[a,d]}getScale(t){if(this._isGCS){if(512===this._lockedSchemaPixelSize)return 4}else if(256===this._lockedSchemaPixelSize&&0===t)return 1;return 2}}var O=i(1036),R=i(49966),f=i(65401),T=i(63631),w=i(40022),E=i(51200),l=i(78224),C=i(12378),L=i(59047),F=i(76763),P=i(1268),ce=i(92862),j=i(58098);class X extends T.m{constructor(t,o,a,d,r){super(t,o,a),this._memCache=d,this._loader=r,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map,this._tileInfoView=new ce.Z(t.tileInfo,t.fullExtent)}destroy(){super.destroy(),this._ongoingRequestToController.forEach(t=>t.abort()),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}getVectorTile(t,o,a,d){var r=this;return(0,_.Z)(function*(){const s=new j.Z(t,o,a,0);let u=r._memCache.get(s.id);if((0,c.pC)(u))return u.retain(),u;const I=yield r._getVectorTileData(s);if((0,y.k_)(d),!r._layer)return null;if(u=r._memCache.get(s.id),(0,c.pC)(u))return u.retain(),u;const N=r._layer.tileInfo.getTileBounds((0,f.Ue)(),s),G=r._tileInfoView.getTileResolution(t);return u=new w.i(s,G,N[0],N[3],512,512,r._styleRepository,r._memCache),(0,c.pC)(I)?(u.setData(I),u.retain(),r._memCache.put(s.id,u,u.memoryUsage*u.referenced,O.an)):u.setData(null),u.neededForCoverage=!0,u.transforms.tileUnitsToPixels=(0,R.f)(1/8,0,0,0,1/8,0,0,0,1),function ee(m,t){const o=[],a=new L.L(4096,o,()=>{const r=new E.J;return r.show=!1,r.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),r.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),r}),d=new C.g(o,a,(r,s,u)=>new l.f(r,s,u,m.styleRepository,m.key.level,0),(r,s)=>{(0,F.C$)(r,s,!1)},()=>0,r=>{const s=t.getStyleLayerByUID(r).getLayoutProperty("visibility");return!s||s.getValue()!==P.EE.NONE});o.push(m),a.add(m),d.setScreenSize(512,512),d.continue(1/0)}(u,r._styleRepository),u})()}_getVectorTileData(t){const o=t.id;if(this._ongoingTileRequests.has(o))return this._ongoingTileRequests.get(o);const a=new AbortController,r=this._getParsedVectorTileData(t,{signal:a.signal}).then(s=>(this._ongoingTileRequests.delete(o),this._ongoingRequestToController.delete(o),s)).catch(()=>(this._ongoingTileRequests.delete(o),this._ongoingRequestToController.delete(o),null));return this._ongoingTileRequests.set(o,r),this._ongoingRequestToController.set(o,a),r}_getParsedVectorTileData(t,o){return this.fetchTileData(t,o).then(a=>this.parseTileData({key:t,data:a},o))}request(t,o){return this._loader.request(t,"binary",o)}}var ne=i(66420),Y=i(68109),K=i(11099),te=i(69172),ie=i(86406);const oe={vtlBackground:ne.J,vtlFill:K.R,vtlLine:te.z,vtlCircle:Y.j,vtlSymbol:ie.e};var ae=i(47326),b=i(67969);const J=1e-6;class H{constructor(t,o){this.spriteMosaic=t,this.glyphMosaic=o,this._brushCache=new Map,this._vtlMaterialManager=new ae.Z}dispose(){this._brushCache&&(this._brushCache.forEach(t=>t.dispose()),this._brushCache=null),this._vtlMaterialManager=(0,c.M2)(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawTile(t,o,a){const{context:d}=t,r=a.layers;a.backgroundBucketIds.length>0&&(t.renderPass="background",a.backgroundBucketIds.forEach(s=>this._renderStyleLayer(a.getLayerById(s),t,o,!0))),d.setBlendingEnabled(!1),d.setDepthTestEnabled(!0),d.setDepthWriteEnabled(!0),d.setDepthFunction(b.wb.LEQUAL),t.renderPass="opaque";for(let s=r.length-1;s>=0;s--)this._renderStyleLayer(r[s],t,o,!1);d.setDepthWriteEnabled(!1),d.setBlendingEnabled(!0),d.setBlendFunctionSeparate(b.zi.ONE,b.zi.ONE_MINUS_SRC_ALPHA,b.zi.ONE,b.zi.ONE_MINUS_SRC_ALPHA),t.renderPass="translucent";for(let s=0;s<r.length;s++)this._renderStyleLayer(r[s],t,o,!1);d.setDepthTestEnabled(!1),d.bindVAO()}_renderStyleLayer(t,o,a,d=!1){if(!(d||t&&a.layerData.has(t.uid)))return;const r=t.getLayoutProperty("visibility");if(r&&r.getValue()===P.EE.NONE)return;const{renderPass:s}=o;let u;switch(t.type){case P.fR.BACKGROUND:if("background"!==s)return;u="vtlBackground";break;case P.fR.FILL:if("opaque"!==s&&"translucent"!==o.renderPass)return;u="vtlFill";break;case P.fR.LINE:if("translucent"!==s)return;u="vtlLine";break;case P.fR.CIRCLE:if("translucent"!==s)return;u="vtlCircle";break;case P.fR.SYMBOL:if("translucent"!==s)return;u="vtlSymbol"}const I=o.displayLevel;void 0!==t.minzoom&&t.minzoom>I+J||void 0!==t.maxzoom&&t.maxzoom<=I-J||(o.styleLayerUID=t.uid,o.styleLayer=t,this._drawWithBrush(o,a,u))}_drawWithBrush(t,o,a){this._brushCache.has(a)||this._brushCache.set(a,new(0,oe[a])),this._brushCache.get(a).drawMany(t,[o])}}var z=i(78364),re=i(19702),le=i(50916),W=i(61779),se=i(45611);let D=class extends((0,le.r)((0,re.A)(se.Z))){constructor(){super(...arguments),this._tileHandlerController=null,this.type="vector-tile-3d"}initialize(){if((0,c.Wi)(this.layer.fullExtent))return void this.addResolvingPromise(Promise.reject(new p.Z("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const{basemapTerrain:m,spatialReference:t,state:o,viewingMode:a}=this.view,s="local"===a&&!(0,W.jO)(t)||W.Bu.force512VTL?this.layer.tileInfo:this.layer.tileInfo.getOrCreateCompatible(256,this.layer.tileInfo.spatialReference.isGeographic?1:2),u=this._getTileInfoSupportError(s,this.layer.fullExtent);if((0,c.pC)(u))return this.addResolvingPromise(Promise.reject(u));const I=(0,g.N1)(()=>this.view?.basemapTerrain?.tilingSchemeLocked).then(()=>{const S=m.tilingScheme,e=S.pixelSize;let Z;this.schemaHelper=new A(e,(0,c.pC)(m.spatialReference)&&m.spatialReference.isGeographic),Z=256===e?this.layer.tileInfo.getOrCreateCompatible(256,this.layer.tileInfo.spatialReference.isGeographic?1:2):this.view.spatialReference?.isGeographic?this.layer.tileInfo.getOrCreateCompatible(512,.5):this.layer.tileInfo;const B=this._getTileInfoCompatibilityError(Z,S);if(B)throw B;this.tileInfo=Z});this._tileHandlerController=new AbortController;const N=this.view.resourceController;this._memCache=N.memoryController.newCache(this.layer.uid,S=>{S.release()});const G=new z.Z(this.layer.currentStyleInfo.style),de=m.mapTileRequester;this._tileHandler=new X(this.layer,G,o.contentPixelRatio,this._memCache,de);const V=this._tileHandlerController.signal,k=S=>N.immediate.schedule(S),Q=this._tileHandler.start({signal:V,schedule:k}),$=this._tileHandler.spriteMosaic;$.then(S=>{!(0,y.Hc)(V)&&this._tileHandler&&(this.painter=new H(S,this._tileHandler.glyphMosaic))}),Q.then(()=>this._tileHandlerController=null),this.updatingHandles.add(()=>({style:this.layer.currentStyleInfo.style,pixelRatio:this.view.state?.contentPixelRatio}),({style:S,pixelRatio:e})=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const Z=new z.Z(S),B=new X(this.layer,Z,e,this._memCache,de),ue=B.start({signal:this._tileHandlerController.signal,schedule:k}),pe=B.spriteMosaic;ue.then(()=>this._tileHandlerController=null),this.updatingHandles.addPromise(Promise.all([ue,pe]).then(([,_e])=>{const ge=this._tileHandler,ve=this.painter;this.painter=new H(_e,B.glyphMosaic),this._tileHandler=B,this.emit("data-changed"),ge.destroy(),ve&&ve.dispose()}))});const me=Promise.all([I,Q,$]);this.addResolvingPromise(me)}destroy(){this.painter=(0,c.M2)(this.painter),this._tileHandlerController=(0,c.IM)(this._tileHandlerController),(0,c.SC)(this._tileHandler),this._memCache=(0,c.SC)(this._memCache),this._tileHandler=null}get dataLevelRange(){const m=this.tileInfo.lods,a=this.levelRangeFromScaleRange(m[0].scale,m[m.length-1].scale);return 1===a.minLevel&&256===this.tileInfo.size[0]&&(a.minLevel=0),a}fetchTile(m,t,o,a){var d=this;return(0,_.Z)(function*(){return d._tileHandler.getVectorTile(m,t,o,a)})()}};(0,v._)([(0,h.Cb)()],D.prototype,"layer",void 0),(0,v._)([(0,h.Cb)()],D.prototype,"dataLevelRange",null),(0,v._)([(0,h.Cb)()],D.prototype,"updatingProgressValue",void 0),D=(0,v._)([(0,M.j)("esri.views.3d.layers.VectorTileLayerView3D")],D);const fe=D}}]);