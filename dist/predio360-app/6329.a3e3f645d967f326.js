"use strict";(self.webpackChunkpredio360_app=self.webpackChunkpredio360_app||[]).push([[6329],{86329:(ur,Ke,w)=>{w.r(Ke),w.d(Ke,{default:()=>lr});var D=w(15861),T=w(17626),pt=w(73281),Be=w(90885),J=w(26584),We=w(63290),S=w(62208),ht=w(99959),Re=w(10699),yt=w(32917),M=w(77712),Le=w(90912),gt=(w(85931),w(55342)),xt=w(68653),ie=w(76898),It=w(44917),vt=w(65088),bt=w(552),Rt=w(50107),Qe=(w(29132),w(84792)),St=w(37053),qe=w(38305),Ae=w(13812),et=w(25982),Ct=w(11354),_e=w(40495),Tt=w(9548),Se=w(2584),wt=w(86810),Ft=w(60330),tt=w(72258),Ce=w(27497),re=w(79781),_=w(28594),Y=w(72642);const se=new Map,le=new class Pt{constructor(t=15e3,c=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=t,this._interval=Math.min(t,c)}decreaseRefCount(t,c){const i=t+"/"+c,a=this._cachedBlocks;if(a.has(i)){const f=a.get(i);return f.refCount--,f.refCount<=0&&(a.delete(i),f.controller&&f.controller.abort()),f.refCount}return 0}getBlock(t,c){const i=t+"/"+c,a=this._cachedBlocks;if(a.has(i)){const f=a.get(i);return f.ts=Date.now(),f.refCount++,a.delete(i),a.set(i,f),f.block}return null}putBlock(t,c,i,a){const f=this._cachedBlocks,u=t+"/"+c;if(f.has(u)){const m=f.get(u);m.ts=Date.now(),m.refCount++}else f.set(u,{block:i,ts:Date.now(),refCount:1,controller:a});this._trim(),this._updateTimer()}deleteBlock(t,c){const i=this._cachedBlocks,a=t+"/"+c;i.has(a)&&i.delete(a)}updateMaxSize(t){this._size=t,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(null!=this._timer)return;const t=this._cachedBlocks;this._timer=setInterval(()=>{const c=Array.from(t),i=Date.now();for(let a=0;a<c.length&&c[a][1].ts<=i-this._duration;a++)t.delete(c[a][0]);0===t.size&&this._clearTimer()},this._interval)}_trim(){const t=this._cachedBlocks;if(-1===this._size||this._size>=t.size)return;const c=Array.from(t);for(let i=0;i<c.length-this._size;i++)t.delete(c[i][0])}_clearTimer(){null!=this._timer&&(clearInterval(this._timer),this._timer=null)}};function rt(s,t){return null==t?s:`${s}?sliceId=${t}`}function nt(s,t,c){const i=se.get(s);if(!i)return null==t?le.getBlock(s,c):null;if(null==t||null==i[t]){for(let f=0;f<i.length;f++){const u=i[f]?.cache.get(c);if(u)return u.refCount++,u.block}return le.getBlock(s,c)}const a=i[t]?.cache.get(c);if(a)return a.refCount++,a.block;for(let f=0;f<i.length;f++){if(f===t||!i[f])continue;const u=i[f]?.cache,m=u?.get(c);if(u&&m)return m.refCount++,u.set(c,m),m.block}return null}function it(s,t,c,i,a=null){const f=se.get(s);if(!f)return void(null==t&&le.putBlock(s,c,i,a));if(null==t||null==f[t])return void le.putBlock(s,c,i,a);const u={refCount:1,block:i,isResolved:!1,isRejected:!1,controller:a};i.then(()=>u.isResolved=!0).catch(()=>u.isRejected=!0),f[t]?.cache.set(c,u)}var Bt=w(67313),st=w(8614),fe=w(79751),Ue=w(30994),q=w(2004);let ee=class extends((0,Ft.v)(wt.wq)){constructor(){super(...arguments),this.rasterJobHandler=null,this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}init(){var s=this;return(0,D.Z)(function*(){const t=(0,_.zD)();s.addResolvingPromise(t),yield s.when()})()}normalizeCtorArgs(s){return s&&s.ioConfig&&(s={...s,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:Se.Z.create(),...s.ioConfig}}),s}get _isGlobalWrappableSource(){const{rasterInfo:s}=this,t=(0,_.ut)(s.spatialReference);return(0,S.pC)(t)&&s.extent.width>=t/2}set url(s){this._set("url",(0,qe.Nm)(s,We.Z.getLogger(this.declaredClass)))}open(s){return(0,D.Z)(function*(){throw new J.Z("BaseRaster:open-not-implemented","open() is not implemented")})()}fetchTile(s,t,c,i={}){var a=this;return(0,D.Z)(function*(){const f=i.tileInfo||a.rasterInfo.storageInfo.tileInfo,u=a.getTileExtentFromTileInfo(s,t,c,f);return a.fetchPixels(u,f.size[0],f.size[1],i)})()}identify(s,t={}){var c=this;return(0,D.Z)(function*(){s=(0,Le.TJ)(Y.Z,s).clone().normalize();const{multidimensionalDefinition:i,timeExtent:a}=t,{rasterInfo:f}=c,{hasMultidimensionalTranspose:u,multidimensionalInfo:m}=f;let{transposedVariableName:d}=t;const p=(0,S.pC)(m)&&u&&(null!=a||(0,re.WU)(i));p&&!d&&(d=(0,S.pC)(i)&&i.length>0?i[0].variableName??void 0:m.variables[0].name,t={...t,transposedVariableName:d}),t=c._getRequestOptionsWithSliceId(t);const{spatialReference:h,extent:g}=f,{datumTransformation:y}=t;let x=(0,_.nF)(s,h,y);if(!g.intersects(x))return{location:x,value:null};if((0,S.pC)(f.transform)){const N=f.transform.inverseTransform(x);if(!f.nativeExtent.intersects(N))return{location:N,value:null};x=N}let v=0;const R=(0,S.pC)(d)&&(0,S.pC)(m)&&f.hasMultidimensionalTranspose;if("Function"===c.datasetFormat){const N=c.primaryRasters.rasters[0];if(R)return N.identify(x,t);const{pixelSize:W}=f,U=3,j=W.x*U/2,G=W.y*U/2,$=new q.Z({xmin:x.x-j,xmax:x.x+j,ymin:x.y-G,ymax:x.y+G,spatialReference:h}),L={interpolation:"nearest"},{pixelBlock:V}=yield N.fetchPixels($,U,U,L),{pixelBlock:Q}=yield c.fetchPixels($,U,U,L);if((0,S.Wi)(V))return{location:x,value:null};const oe=Math.floor(U*U*.5),ve=!V.mask||V.mask[oe]?V.pixels.map(be=>be[oe]):null;let Oe;return(0,S.pC)(Q)&&(Oe=!Q.mask||Q.mask[oe]?Q.pixels.map(be=>be[oe]):void 0),{location:x,value:ve,processedValue:Oe,pyramidLevel:0}}if(!R)if(t.srcResolution)v=(0,_.kr)(t.srcResolution,f,c.ioConfig.sampling).pyramidLevel;else if(v=yield c.computeBestPyramidLevelForLocation(s,t),null==v)return{location:x,value:null};const b=c.identifyPixelLocation(x,v,null,R);if(null===b)return{location:x,value:null};const{row:I,col:C,rowOffset:F,colOffset:Z,blockWidth:B}=b,E=d??(0,S.Wg)(t.sliceId),O=rt(c.url,E),k=`${v}/${I}/${C}`;let H=nt(O,null,k);(0,S.Wi)(H)&&(H=c.fetchRawTile(v,I,C,t),it(O,null,k,H));const P=yield H;return(0,S.Wi)(P)||!P.pixels?.length?{location:x,value:null}:c._processIdentifyResult(P,{srcLocation:x,position:F*B+Z,pyramidLevel:v,useTransposedTile:!!R,requestSomeSlices:p,identifyOptions:t})})()}fetchPixels(s,t,c,i={}){var a=this;return(0,D.Z)(function*(){if(s=(0,_.kZ)(s),(i=a._getRequestOptionsWithSliceId(i)).requestRawData)return a._fetchPixels(s,t,c,i);const f=(0,_.ut)(s.spatialReference),u=(0,_.Hq)(s);if((0,S.Wi)(f)||0===u||1===u&&a._isGlobalWrappableSource)return a._fetchPixels(s,t,c,i);if(u>=3)return{extent:s,pixelBlock:null};const m=[],{xmin:d,xmax:p}=s,h=Math.round(f/(p-d)*t),g=h-Math.round((f/2-d)/(p-d)*t);let y=0;const x=[];for(let I=0;I<=u;I++){const C=new q.Z({xmin:0===I?d:-f/2,xmax:I===u?p-f*I:f/2,ymin:s.ymin,ymax:s.ymax,spatialReference:s.spatialReference}),F=0===I?h-g:I===u?t-y:h;y+=F,x.push(F);const Z=i.disableWrapAround&&I>0?null:a._fetchPixels(C,F,c,i);m.push(Z)}const v=(yield Promise.all(m)).map(I=>I?.pixelBlock);let R=null;const b={width:t,height:c};return R=a.rasterJobHandler?(yield a.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:v,srcMosaicSize:b,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:x},i)).pixelBlock:(0,fe.us)(v,b,{blockWidths:x}),{extent:s,srcExtent:(0,_.tB)(s,a.rasterInfo.spatialReference,i.datumTransformation),pixelBlock:R}})()}fetchRawPixels(s,t,c,i={}){var a=this;return(0,D.Z)(function*(){t={x:Math.floor(t.x),y:Math.floor(t.y)};const f=yield a._fetchRawTiles(s,t,c,i),{nativeExtent:u,nativePixelSize:m,storageInfo:d}=a.rasterInfo,p=2**s,h=m.x*p,g=m.y*p,y=new q.Z({xmin:u.xmin+h*t.x,xmax:u.xmin+h*(t.x+c.width-1),ymin:u.ymax-g*(t.y+c.height-1),ymax:u.ymax-g*t.y,spatialReference:u.spatialReference});if(!f)return{extent:y,srcExtent:y,pixelBlock:null};const{pixelBlocks:x,mosaicSize:v}=f;if(1===x.length&&(0,S.pC)(x[0])&&x[0].width===c.width&&x[0].height===c.height)return{extent:y,srcExtent:y,pixelBlock:f.pixelBlocks[0]};const I={x:t.x%(s>0?d.pyramidBlockWidth:d.blockWidth),y:t.y%(s>0?d.pyramidBlockHeight:d.blockHeight)};let C;return C=a.rasterJobHandler?(yield a.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:x,srcMosaicSize:v,destDimension:c,clipOffset:I,clipSize:c,coefs:null,sampleSpacing:null,interpolation:i.interpolation,alignmentInfo:null,blockWidths:null},i)).pixelBlock:(0,fe.us)(x,v,{clipOffset:I,clipSize:c}),{extent:y,srcExtent:y,pixelBlock:C}})()}fetchRawTile(s,t,c,i){throw new J.Z("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(s){return(0,_.tB)(this.rasterInfo.extent,s)}decodePixelBlock(s,t){return!this.rasterJobHandler||t.useCanvas?(0,st.J)(s,t):this.rasterJobHandler.decode({data:s,options:t})}request(s,t,c=0){var i=this;return(0,D.Z)(function*(){const{customFetchParameters:a}=i.ioConfig,{range:f,query:u,headers:m}=t;c=c??t.retryCount??i.ioConfig.retryCount;const d=f?{Range:`bytes=${f.from}-${f.to}`}:null;try{return yield(0,Qe.default)(s,{...t,query:{...u,...a},headers:{...m,...d}})}catch(p){if(c>0)return c--,i.request(s,t,c);throw p}})()}getSliceIndex(s){const{multidimensionalInfo:t}=this.rasterInfo;return(0,S.Wi)(t)||(0,S.Wi)(s)||0===s.length?null:(0,re.gk)(s,t)}getTileExtentFromTileInfo(s,t,c,i){const a=(0,S.s3)(i.lodAt(s));return this.getTileExtent({x:a.resolution,y:a.resolution},t,c,i.origin,i.spatialReference,i.size)}updateTileInfo(){const{storageInfo:s,spatialReference:t,extent:c,pixelSize:i}=this.rasterInfo;if(!s.tileInfo){const a=[],f=s.maximumPyramidLevel||0;let u=Math.max(i.x,i.y),m=1/.0254*96*u;for(let p=0;p<=f;p++)a.push(new tt.Z({level:f-p,resolution:u,scale:m})),u*=2,m*=2;const d=new Y.Z({x:c.xmin,y:c.ymax,spatialReference:t});s.tileInfo=new Se.Z({origin:d,size:[s.blockWidth,s.blockHeight],spatialReference:t,lods:a}),s.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(s,t=512,c=512,i){const{width:a,height:f,nativeExtent:u,pixelSize:m,spatialReference:d}=s,p=new Y.Z({x:u.xmin,y:u.ymax,spatialReference:d});null==i&&(i=Math.max(0,Math.round(Math.log(Math.max(a,f))/Math.LN2-8)));const h=this.computeBlockBoundary(u,512,512,{x:u.xmin,y:u.ymax},[m],i);s.storageInfo=new Ce.Z({blockWidth:t,blockHeight:c,pyramidBlockWidth:t,pyramidBlockHeight:c,origin:p,firstPyramidLevel:1,maximumPyramidLevel:i,blockBoundary:h})}computeBestPyramidLevelForLocation(s,t={}){return(0,D.Z)(function*(){return 0})()}computeBlockBoundary(s,t,c,i,a,f=0,u=2){if(1===a.length&&f>0){a=[...a];let{x:h,y:g}=a[0];for(let y=0;y<f;y++)h*=u,g*=u,a.push({x:h,y:g})}const m=[],{x:d,y:p}=i;for(let h=0;h<a.length;h++){const{x:g,y}=a[h];m.push({minCol:Math.floor((s.xmin-d+.1*g)/t/g),maxCol:Math.floor((s.xmax-d-.1*g)/t/g),minRow:Math.floor((p-s.ymax+.1*y)/c/y),maxRow:Math.floor((p-s.ymin-.1*y)/c/y)})}return m}getPyramidPixelSize(s){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:c,pyramidScalingFactor:i}=this.rasterInfo.storageInfo;if(0===s)return t;if((0,S.pC)(c)&&c.length)return c[s-1];const a=i**s;return{x:t.x*a,y:t.y*a}}identifyPixelLocation(s,t,c,i){const{spatialReference:a,nativeExtent:f,storageInfo:u}=this.rasterInfo,{maximumPyramidLevel:m,origin:d,transposeInfo:p}=u,h=i&&(0,S.pC)(p)?p.tileSize[0]:u.blockWidth,g=i&&(0,S.pC)(p)?p.tileSize[1]:u.blockHeight,y=(0,_.nF)(s,a,c);if(!f.intersects(y)||t<0||t>m)return null;const x=this.getPyramidPixelSize(t),{x:v,y:R}=x,b=(d.y-y.y)/R/g,I=(y.x-d.x)/v/h,C=Math.min(g-1,Math.floor((b-Math.floor(b))*g)),F=Math.min(h-1,Math.floor((I-Math.floor(I))*h));return{pyramidLevel:t,row:Math.floor(b),col:Math.floor(I),rowOffset:C,colOffset:F,blockWidth:h,srcLocation:y}}getTileExtent(s,t,c,i,a,f){const[u,m]=f,d=i.x+c*u*s.x,h=i.y-t*m*s.y;return new q.Z({xmin:d,xmax:d+u*s.x,ymin:h-m*s.y,ymax:h,spatialReference:a})}getBlockWidthHeight(s){return{blockWidth:s>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:s>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(s,t,c){const i=this.rasterInfo.storageInfo.blockBoundary[s];return!i||i.maxRow<t||i.maxCol<c||i.minRow>t||i.minCol>c}_fetchPixels(s,t,c,i={}){var a=this;return(0,D.Z)(function*(){let f=(0,_.Hq)(s);if(f>=2)return{extent:s,pixelBlock:null};const u=a._getSourceDataInfo(s,t,c,i),{pyramidLevel:m,pyramidResolution:d,srcResolution:p,srcExtent:h,srcWidth:g,srcHeight:y}=u;if(0===g||0===y)return{extent:s,srcExtent:h,pixelBlock:null};const x=(0,S.Wg)(a.rasterInfo.transform),v="gcs-shift"===x?.type,R=(0,S.pC)((0,_.ut)(s.spatialReference));!v&&R||(f=(0,_.Hq)(u.srcExtent,v));const b=a.rasterInfo.storageInfo,I={x:Math.floor((h.xmin-b.origin.x)/d.x+.1),y:Math.floor((b.origin.y-h.ymax)/d.y+.1)},C=yield a._fetchRawTiles(m,I,{width:g,height:y,wrapCount:f},i);if(!C)return{extent:s,srcExtent:h,pixelBlock:null};const F=m>0?b.pyramidBlockWidth:b.blockWidth,Z=m>0?b.pyramidBlockHeight:b.blockHeight,B=F===g&&Z===y&&I.x%F==0&&I.y%Z==0,E=new Y.Z({x:(s.xmax-s.xmin)/t,y:(s.ymax-s.ymin)/c,spatialReference:s.spatialReference}),O=!s.spatialReference.equals(a.rasterInfo.spatialReference),{datumTransformation:k}=i;if(!O&&B&&1===C.pixelBlocks.length&&F===t&&Z===c&&p.x===E.x&&p.y===E.y)return{extent:s,srcExtent:h,pixelBlock:C.pixelBlocks[0]};const H=R&&(0,S.pC)((0,_.ut)(h.spatialReference)),P=i.requestProjectedLocalDirections&&a.rasterInfo.dataType.startsWith("vector");P&&!a.rasterJobHandler&&(yield(0,_.zD)());const z=a.rasterJobHandler?yield a.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:s,srcBufferExtent:C.extent,pixelSize:E.toJSON(),datumTransformation:k,rasterTransform:x,hasWrapAround:f>0||H,isAdaptive:!1!==a.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:P},i):(0,_.Qp)({projectedExtent:s,srcBufferExtent:C.extent,pixelSize:E,datumTransformation:k,rasterTransform:x,hasWrapAround:f>0||H,isAdaptive:!1,includeGCSGrid:P});let N;const W=!i.requestRawData,U={rows:z.spacing[0],cols:z.spacing[1]},j=(0,S.Wg)(a._getRasterTileAlignmentInfo(m,C.extent.xmin)),{pixelBlocks:G,mosaicSize:$,isPartiallyFilled:L}=C;let V=null;if(a.rasterJobHandler)({pixelBlock:N,localNorthDirections:V}=yield a.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:G,srcMosaicSize:$,destDimension:W?{width:t,height:c}:null,coefs:W?z.coefficients:null,sampleSpacing:W?U:null,projectDirections:P,gcsGrid:P?z.gcsGrid:null,isUV:"vector-uv"===a.rasterInfo.dataType,interpolation:i.interpolation,alignmentInfo:j,blockWidths:null},i));else{const Q=(0,fe.us)(G,$,{alignmentInfo:j});N=W?(0,fe.Uk)(Q,{width:t,height:c},z.coefficients,U,i.interpolation):Q,P&&z.gcsGrid&&(V=(0,fe.Qh)({width:t,height:c},z.gcsGrid),N=(0,Ue.xQ)(N,a.rasterInfo.dataType,V))}return i.requestRawData||P?{srcExtent:h,pixelBlock:N,transformGrid:z,localNorthDirections:V,extent:s,isPartiallyFilled:L}:{srcExtent:h,extent:s,pixelBlock:N}})()}_fetchRawTiles(s,t,c,i){var a=this;return(0,D.Z)(function*(){const{origin:f,blockBoundary:u}=a.rasterInfo.storageInfo,{blockWidth:m,blockHeight:d}=a.getBlockWidthHeight(s);let{x:p,y:h}=t,{width:g,height:y,wrapCount:x}=c;const v=a._getRasterTileAlignmentInfo(s,0);i.buffer&&(p-=i.buffer.cols,h-=i.buffer.rows,g+=2*i.buffer.cols,y+=2*i.buffer.rows);let R=0,b=0,I=0;x&&(0,S.pC)(v)&&(({worldColumnCountFromOrigin:b,originColumnOffset:I,rightPadding:R}=v),b*v.blockWidth-R>=p+g&&(R=0));const C=Math.floor(p/m),F=Math.floor(h/d),Z=Math.floor((p+g+R-1)/m),B=Math.floor((h+y+R-1)/d),E=u[s];if(!E)return null;const{minRow:O,minCol:k,maxCol:H,maxRow:P}=E;if(0===x&&(B<O||Z<k||F>P||C>H))return null;const z=new Array;let N=!1;const W=null==a.ioConfig.allowPartialFill?i.allowPartialFill:a.ioConfig.allowPartialFill;for(let Q=F;Q<=B;Q++)for(let oe=C;oe<=Z;oe++){let ve=oe;if(!i.disableWrapAround&&x&&(0,S.pC)(v)&&b<=oe&&(ve=oe-b-I),Q>=O&&ve>=k&&P>=Q&&H>=ve){const Oe=a._fetchRawTile(s,Q,ve,i);z.push(W?new Promise(be=>{Oe.then(cr=>be(cr)).catch(()=>{N=!0,be(null)})}):Oe)}else z.push(Promise.resolve(null))}if(0===z.length)return null;const U=yield Promise.all(z),j={height:(B-F+1)*d,width:(Z-C+1)*m},{spatialReference:G}=a.rasterInfo,$=a.getPyramidPixelSize(s),{x:L,y:V}=$;return{extent:new q.Z({xmin:f.x+C*m*L,xmax:f.x+(Z+1)*m*L,ymin:f.y-(B+1)*d*V,ymax:f.y-F*d*V,spatialReference:G}),pixelBlocks:U,mosaicSize:j,isPartiallyFilled:N}})()}_fetchRawTile(s,t,c,i){const a=this.rasterInfo.storageInfo.blockBoundary[s];if(!a)return Promise.resolve(null);const{minRow:f,minCol:u,maxCol:m,maxRow:d}=a;if(t<f||c<u||t>d||c>m)return Promise.resolve(null);const p=rt(this.url,i.sliceId),h=`${s}/${t}/${c}`;let g=nt(p,i.registryId,h);if((0,S.Wi)(g)){const y=new AbortController;g=this.fetchRawTile(s,t,c,{...i,signal:y.signal}),it(p,i.registryId,h,g,y),g.catch(()=>function kt(s,t,c){const i=se.get(s);i?null!=t&&null!=i[t]?i[t]?.cache.delete(c):le.deleteBlock(s,c):null==t&&le.deleteBlock(s,c)}(p,i.registryId,h))}return i.signal&&(0,Re.fu)(i,()=>{!function Mt(s,t,c){const i=se.get(s);if(!i)return null==t?le.decreaseRefCount(s,c):0;if(null==t||null==i[t])return le.decreaseRefCount(s,c);const a=i[t]?.cache,f=a?.get(c);if(a&&f){if(f.refCount--,0===f.refCount){a.delete(c);for(let u=0;u<i.length;u++)i[u]?.cache.delete(c);f.controller&&f.controller.abort()}return f.refCount}}(p,i.registryId,h)}),g}_computeMagDirValues(s){const{bandCount:t,dataType:c}=this.rasterInfo;if((2!==t||"vector-magdir"!==c)&&"vector-uv"!==c||2!==s?.length||!s[0]?.length)return null;const i=s[0].length;if("vector-magdir"===c){const d=s[1].map(p=>(p+360)%360);return[s[0],d]}const[a,f]=s,u=[],m=[];for(let d=0;d<i;d++){const[p,h]=(0,Ue.Tg)([a[d],f[d]]);u.push(p),m.push(h)}return[u,m]}_getRasterTileAlignmentInfo(s,t){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=(0,_.P_)(this.rasterInfo)),(0,S.Wi)(this._rasterTileAlighmentInfo.pyramidsInfo)?null:{startX:t,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[s]}}_getSourceDataInfo(s,t,c,i={}){const a={datumTransformation:i.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0};i.srcResolution&&(a.srcResolution=i.srcResolution,this._updateSourceDataInfo(s,a));const f=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:u,srcHeight:m,pyramidLevel:d}=a,p=u/t,h=m/c,g=d<f&&p*h>=16,y=d===f&&this._requireTooManySrcTiles(u,m,t,c);if(g||y||0===u||0===m){const x=new Y.Z({x:(s.xmax-s.xmin)/t,y:(s.ymax-s.ymin)/c,spatialReference:s.spatialReference});let v=(0,_.VO)(x,this.rasterInfo.spatialReference,s,a.datumTransformation);if(g&&i.srcResolution&&(!v||i.srcResolution&&v.x+v.y<i.srcResolution.x+i.srcResolution.y)){const b=Math.round(Math.log(Math.max(p,h))/Math.LN2)-1;if(f-d+3>=b){const I=2**b;v={x:i.srcResolution.x*I,y:i.srcResolution.y*I}}}v&&(a.srcResolution=v,this._updateSourceDataInfo(s,a))}return this._requireTooManySrcTiles(a.srcWidth,a.srcHeight,t,c)&&(a.srcWidth=0,a.srcHeight=0),a}_requireTooManySrcTiles(s,t,c,i){const{tileInfo:a}=this.rasterInfo.storageInfo;return Math.ceil(s/a.size[0])*Math.ceil(t/a.size[1])>=256||s/c>8||t/i>8}_updateSourceDataInfo(s,t){t.srcWidth=0,t.srcHeight=0;const c=this.rasterInfo.spatialReference,{srcResolution:i,datumTransformation:a}=t,{pyramidLevel:f,pyramidResolution:u,excessiveReading:m}=(0,_.kr)(i,this.rasterInfo,this.ioConfig.sampling);if(m)return;let d=t.srcExtent||(0,_.tB)(s,c,a);if(null==d)return;const p=(0,S.Wg)(this.rasterInfo.transform);p&&(d=p.inverseTransform(d)),t.srcExtent=d;const h=Math.ceil((d.xmax-d.xmin)/u.x-.1),g=Math.ceil((d.ymax-d.ymin)/u.y-.1);t.pyramidLevel=f,t.pyramidResolution=u,t.srcWidth=h,t.srcHeight=g}_getRequestOptionsWithSliceId(s){return(0,S.pC)(this.rasterInfo.multidimensionalInfo)&&null==s.sliceId&&(s={...s,sliceId:this.getSliceIndex(s.multidimensionalDefinition)}),s}_processIdentifyResult(s,t){const{srcLocation:c,position:i,pyramidLevel:a,useTransposedTile:f}=t,u=s.pixels[0].length/s.width/s.height;if(s.mask&&!s.mask[i])return{location:c,value:null};const{multidimensionalInfo:m}=this.rasterInfo;if((0,S.Wi)(m)||!f){const b=s.pixels.map(F=>F[i]),I={location:c,value:b,pyramidLevel:a},C=this._computeMagDirValues(b.map(F=>[F]));return C?.length&&(I.magdirValue=C.map(F=>F[0])),I}let d=s.pixels.map(b=>b.slice(i*u,i*u+u)),p=this._computeMagDirValues(d);const{requestSomeSlices:h,identifyOptions:g}=t;let y=(0,re.MO)(m,g.transposedVariableName);if(h){const b=(0,re.Ur)(y,(0,S.Wg)(g.multidimensionalDefinition),(0,S.Wg)(g.timeExtent));d=d.map(I=>b.map(C=>I[C])),p=p?.map(I=>b.map(C=>I[C])),y=b.map(I=>y[I])}const x=s.noDataValues||this.rasterInfo.noDataValue,v={pixels:d,pixelType:s.pixelType};let R;return(0,S.pC)(x)&&((0,Bt.A)(v,x),R=v.mask),{location:c,value:null,dataSeries:y.map((b,I)=>{const C={value:0===R?.[I]?null:d.map(F=>F[I]),multidimensionalDefinition:b.multidimensionalDefinition.map(F=>new et.Z({...F,isSlice:!0}))};return p?.length&&(C.magdirValue=[p[0][I],p[1][I]]),C}),pyramidLevel:a}}};(0,T._)([(0,M.Cb)()],ee.prototype,"_rasterTileAlighmentInfo",void 0),(0,T._)([(0,M.Cb)({readOnly:!0})],ee.prototype,"_isGlobalWrappableSource",null),(0,T._)([(0,M.Cb)(Ae.HQ)],ee.prototype,"url",null),(0,T._)([(0,M.Cb)({type:String,json:{write:!0}})],ee.prototype,"datasetName",void 0),(0,T._)([(0,M.Cb)({type:String,json:{write:!0}})],ee.prototype,"datasetFormat",void 0),(0,T._)([(0,M.Cb)()],ee.prototype,"hasUniqueSourceStorageInfo",void 0),(0,T._)([(0,M.Cb)()],ee.prototype,"rasterInfo",void 0),(0,T._)([(0,M.Cb)()],ee.prototype,"ioConfig",void 0),(0,T._)([(0,M.Cb)()],ee.prototype,"sourceJSON",void 0),ee=(0,T._)([(0,ie.j)("esri.layers.support.rasterDatasets.BaseRaster")],ee);const de=ee;let me=class extends de{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null}open(s){var t=this;return(0,D.Z)(function*(){yield t.init();const{rasterFunction:c}=t;t.primaryRasters?.rasters?.length?c.sourceRasters=t.primaryRasters.rasters:t.primaryRasters=c.getPrimaryRasters();const{rasters:i,rasterIds:a}=t.primaryRasters,f=i.map(p=>p.rasterInfo?void 0:p.open(s));yield Promise.all(f);const u=i.map(({rasterInfo:p})=>p),m=c.bind({rasterInfos:u,rasterIds:a});if(!m.success||0===u.length)throw new J.Z("raster-function:open",`cannot bind the function: ${m.error??""}`);yield t.syncJobHandler();const d=u[0];t.hasUniqueSourceStorageInfo=1===u.length||u.slice(1).every(p=>t._hasSameStorageInfo(p,d)),t.set("sourceJSON",i[0].sourceJSON),t.set("rasterInfo",c.rasterInfo)})()}syncJobHandler(){var s=this;return(0,D.Z)(function*(){return s.rasterJobHandler?.updateRasterFunction(s.rasterFunction)})()}fetchPixels(s,t,c,i={}){var a=this;return(0,D.Z)(function*(){const{rasters:f,rasterIds:u}=a.primaryRasters,m=f.map(y=>y.fetchPixels(s,t,c,i)),d=yield Promise.all(m),p=d.map(y=>y.pixelBlock);if(i.skipRasterFunction||p.every(y=>(0,S.Wi)(y)))return d[0];const h=d.find(y=>(0,S.pC)(y.pixelBlock))?.extent??s,g=a.rasterJobHandler?yield a.rasterJobHandler.process({extent:h,primaryPixelBlocks:p,primaryRasterIds:u}):a.rasterFunction.process({extent:h,primaryPixelBlocks:p,primaryRasterIds:u});return{...d[0],pixelBlock:g}})()}_hasSameStorageInfo(s,t){const{storageInfo:c,pixelSize:i,spatialReference:a,extent:f}=s,{storageInfo:u,pixelSize:m,spatialReference:d,extent:p}=t;return i.x===m.x&&i.y===m.y&&a.equals(d)&&f.equals(p)&&c.blockHeight===u.blockHeight&&c.blockWidth===u.blockWidth&&c.maximumPyramidLevel===u.maximumPyramidLevel}};(0,T._)([(0,M.Cb)({type:String,json:{write:!0}})],me.prototype,"datasetFormat",void 0),(0,T._)([(0,M.Cb)()],me.prototype,"tileType",void 0),(0,T._)([(0,M.Cb)()],me.prototype,"rasterFunction",void 0),(0,T._)([(0,M.Cb)()],me.prototype,"primaryRasters",void 0),me=(0,T._)([(0,ie.j)("esri.layers.support.rasterDatasets.FunctionRaster")],me);const je=me;var De=w(74829),ce=w(8341),Zt=w(99033),zt=w(37084),X=w(65234);const ot=We.Z.getLogger("esri.layers.mixins.ImageryTileMixin"),Et=s=>{let t=class extends s{constructor(...i){super(...i),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation="nearest",this.multidimensionalSubset=null,this.raster=null,this.rasterFunction=null,this.rasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster="Function"===i[0]?.raster?.datasetFormat}get fullExtent(){return this.rasterInfo?.extent}set multidimensionalDefinition(i){this._set("multidimensionalDefinition",i),this.updateRenderer()}get tileInfo(){return this.rasterInfo?.storageInfo.tileInfo}set url(i){this._set("url",(0,qe.Nm)(i,ot))}set renderer(i){this._set("renderer",i),this.updateRenderer()}convertVectorFieldData(i,a){var f=this;return(0,D.Z)(function*(){if((0,S.Wi)(i)||!f.rasterInfo)return null;const u=f._rasterJobHandler.instance,m=f.rasterInfo.dataType;return u?u.convertVectorFieldData({pixelBlock:i,dataType:m},a):(0,Ue.KC)(i,m)})()}createFlowMesh(i,a){var f=this;return(0,D.Z)(function*(){const u=f._rasterJobHandler.instance;return u?u.createFlowMesh(i,a):(0,zt.GE)(i.meshType,i.simulationSettings,i.flowData,(0,S.pC)(a.signal)?a.signal:(new AbortController).signal)})()}normalizeRasterFetchOptions(i){const{multidimensionalInfo:a}=this.rasterInfo??{};if((0,S.Wi)(a))return i;let f=i.multidimensionalDefinition||this.multidimensionalDefinition;!(0,S.Wi)(f)&&f.length||(f=(0,re.Tj)(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}));const u=i.timeExtent||this.timeExtent;if((0,S.pC)(f)&&(0,S.pC)(u)&&((0,S.pC)(u.start)||(0,S.pC)(u.end))){f=f.map(R=>R.clone());const m=a.variables.find(({name:R})=>R===f[0].variableName)?.dimensions?.find(({name:R})=>"StdTime"===R),d=f.find(({dimensionName:R})=>"StdTime"===R);if(!m||!d)return{...i,multidimensionalDefinition:null};const{start:p,end:h}=u,g=(0,S.Wi)(p)?null:p.getTime(),y=(0,S.Wi)(h)?null:h.getTime(),x=g??y,v=y??g;if((0,S.pC)(m.values)){const R=m.values.filter(b=>Array.isArray(b)?x===v?b[0]<=x&&b[1]>=x:b[0]<=x&&b[1]>x||b[0]<v&&b[1]>=v||b[0]>=x&&b[1]<=v||b[0]<x&&b[1]>v:x===v?b===x:b>=x&&b<=v);if(R.length){const b=R.sort((I,C)=>x===v?(I[0]??I)-(C[0]??C):Math.abs((I[1]??I)-v)-Math.abs((C[1]??C)-v))[0];d.values=[b]}else f=null}else if(m.hasRegularIntervals&&m.extent){const[R,b]=m.extent;x>b||v<R?f=null:d.values=x===v?[x]:[Math.max(R,x),Math.min(b,v)]}}return(0,S.pC)(f)&&(0,re.nb)(f,this.multidimensionalSubset)?{...i,multidimensionalDefinition:null}:{...i,multidimensionalDefinition:f}}updateRasterFunction(){var i=this;return(0,D.Z)(function*(){if("imagery-tile"!==i.type||!i.rasterFunction&&!i._cachedRasterFunctionJson||JSON.stringify(i.rasterFunction)===JSON.stringify(i._cachedRasterFunctionJson))return;if(i._isConstructedFromFunctionRaster&&"Function"===i.raster.datasetFormat){const g=i.raster.rasterFunction.toJSON();return!i.rasterFunction&&g&&i._set("rasterFunction",_e.Z.fromJSON(g)),void(i._cachedRasterFunctionJson=i.rasterFunction?.toJSON())}let a,f=i.raster,u=!1;"Function"===f.datasetFormat?(a=f.primaryRasters.rasters,f=a[0],u=!0):a=[f];const{rasterFunction:m}=i;if(m){const g={raster:f};a.length>1&&a.forEach(v=>g[v.url]=v);const y=(0,De.Ue)(m.rasterFunctionDefinition??m.toJSON(),g),x=new je({rasterFunction:y});x.rasterJobHandler=i._rasterJobHandler.instance,yield x.open(),i._cachedRasterFunctionJson=i.rasterFunction?.toJSON(),i.raster=x}else i.raster=f,i._cachedRasterFunctionJson=null;if(i._cachedRendererJson=null,!u&&!m)return;const{bandIds:d}=i,{bandCount:p}=i.raster.rasterInfo,h=d?.length?d.some(g=>g>=p):p>=3;d&&(h||"raster-stretch"!==i.renderer.type)&&i._set("bandIds",null),i._configDefaultRenderer("auto")})()}updateRenderer(){var i=this;return(0,D.Z)(function*(){const{loaded:a,symbolizer:f}=i;if(!a||!f)return;const{rasterInfo:u}=i.raster,m=(0,re.WY)(u,{multidimensionalDefinition:i.multidimensionalDefinition,multidimensionalSubset:i.multidimensionalSubset})?.name,d=(0,ce.ol)({...i.renderer.toJSON(),variableName:m});if(JSON.stringify(i._cachedRendererJson)===JSON.stringify(d))return;const p=i._rasterJobHandler.instance;p&&(f.rasterInfo=(0,ce.FI)(u,m),f.rendererJSON=d,f.bind(),yield p.updateSymbolizer(f),i._cachedRendererJson=d)})()}applyRenderer(i,a){var f=this;return(0,D.Z)(function*(){const u=i&&i.pixelBlock;if(!((0,S.pC)(u)&&u.pixels&&u.pixels.length>0))return null;let m;yield f.updateRenderer();const d=f._rasterJobHandler.instance,p=f.bandIds??[];return m=d?yield d.symbolize({...i,simpleStretchParams:a,bandIds:p}):f.symbolizer.symbolize({...i,simpleStretchParams:a,bandIds:p}),m})()}getTileUrl(i,a,f){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${i}/${a}/${f}`:""}getCompatibleTileInfo(i,a,f=!1){if(!this.loaded||(0,S.Wi)(a))return null;if(f&&i.equals(this.spatialReference))return this.tileInfo;const u=(0,St.C5)(i);return Se.Z.create({size:256,spatialReference:i,origin:u?{x:u.origin[0],y:u.origin[1]}:{x:a.xmin,y:a.ymax}})}getCompatibleFullExtent(i){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(i)||(this._compatibleFullExtent=this.raster.computeExtent(i)),this._compatibleFullExtent):null}fetchTile(i,a,f,u={}){var m=this;return(0,D.Z)(function*(){if(c(m),u.requestAsImageElement){const p=m.getTileUrl(i,a,f);return(0,Qe.default)(p,{responseType:"image",query:{...m.refreshParameters,...m.raster.ioConfig.customFetchParameters},signal:u.signal}).then(h=>h.data)}const{rasterInfo:d}=m;return(0,S.pC)(d.multidimensionalInfo)&&(u=m.normalizeRasterFetchOptions(u),(0,S.Wi)(u.multidimensionalDefinition))?{extent:m.raster.getTileExtentFromTileInfo(i,a,f,u.tileInfo||d.storageInfo.tileInfo),pixelBlock:null}:(yield m._initJobHandler(),yield m.updateRasterFunction(),"raster-shaded-relief"===m.renderer.type&&(u={...u,buffer:{cols:1,rows:1}}),m.raster.fetchTile(i,a,f,u))})()}fetchPixels(i,a,f,u={}){var m=this;return(0,D.Z)(function*(){return(0,S.pC)(m.rasterInfo.multidimensionalInfo)&&(u=m.normalizeRasterFetchOptions(u),(0,S.Wi)(u.multidimensionalDefinition))?{extent:i,pixelBlock:null}:(yield m._initJobHandler(),yield m.updateRasterFunction(),m.raster.fetchPixels(i,a,f,u))})()}identify(i,a={}){var f=this;return(0,D.Z)(function*(){const{raster:u,rasterInfo:m}=f;if((0,S.pC)(m.multidimensionalInfo)&&(!m.hasMultidimensionalTranspose||!((0,re.WU)(a.multidimensionalDefinition)||a.transposedVariableName||a.timeExtent))&&(a=f.normalizeRasterFetchOptions(a),(0,S.Wi)(a.multidimensionalDefinition)))return{location:i,value:null};const d=f.multidimensionalSubset?.areaOfInterest;if(d&&!d.contains(i))throw new J.Z("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return u.identify(i,a)})()}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const i=this.rasterInfo?.multidimensionalInfo;if((0,S.Wi)(i)||"standard-time"!==this.rasterInfo?.dataType)return!1;const a=this.multidimensionalDefinition,f=a?.[0]?.variableName;return i.variables.some(u=>u.name===f&&(!a?.[0].dimensionName||u.dimensions.some(m=>"StdTime"===m.name)))}getStandardTimeValue(i){return new Date(24*(i-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(i){return(0,re.jj)(this.multidimensionalSubset,i??this.rasterInfo?.multidimensionalInfo)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=(0,re.Tj)(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const i=new Tt.Z;return this._rasterJobHandler.connectionPromise=i.initialize().then(()=>{c(this),this._rasterJobHandler.instance=i,this.raster.rasterJobHandler=i,this.renderer&&this.updateRenderer(),"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler()}).catch(()=>{}),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){c(this);const{raster:i}=this,a=(0,ce.In)(i.rasterInfo,i.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",a)}}_configDefaultRenderer(i="no"){c(this);const{rasterInfo:a}=this.raster;!this.bandIds&&a.bandCount>1&&(this.bandIds=(0,ce.YD)(a));const f=(0,re.WY)(a,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset})?.name;if(!this.renderer||"override"===i){const p=(0,ce.Ob)(a,{bandIds:this.bandIds,variableName:f});"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===p.type&&((a.statistics?.[0].max??0)>1e24||(a.statistics?.[0].min??0)<-1e24)&&(p.dynamicRangeAdjustment=!0,p.statistics=null,"none"===p.stretchType&&(p.stretchType="min-max")),this.renderer=p}const u=(0,ce.ol)({...this.renderer.toJSON(),variableName:f}),m=(0,ce.FI)(a,f);this.symbolizer?(this.symbolizer.rendererJSON=u,this.symbolizer.rasterInfo=m):this.symbolizer=new Zt.Z({rendererJSON:u,rasterInfo:m});const d=this.symbolizer.bind();if(d.success){if("auto"===i){const{colormap:p}=this.raster.rasterInfo,h=this.renderer;if((0,S.pC)(p))if("raster-colormap"!==h.type)this._configDefaultRenderer("override");else{const g=(0,ce.Ob)(this.raster.rasterInfo);JSON.stringify(g)!==JSON.stringify(h)&&this._configDefaultRenderer("override")}else if("raster-stretch"===h.type){const g=this.bandIds?.length,y=h.statistics?.length;!h.dynamicRangeAdjustment&&y&&g&&y!==g&&this._configDefaultRenderer("override")}}}else ot.warn("imagery-tile-mixin",d.error||"The given renderer is not supported by the layer."),"auto"===i&&this._configDefaultRenderer("override")}};function c(i){if(!i.raster||!i.rasterInfo)throw new J.Z("imagery-tile","no raster")}return(0,T._)([(0,M.Cb)()],t.prototype,"_cachedRendererJson",void 0),(0,T._)([(0,M.Cb)()],t.prototype,"_cachedRasterFunctionJson",void 0),(0,T._)([(0,M.Cb)()],t.prototype,"_compatibleFullExtent",void 0),(0,T._)([(0,M.Cb)()],t.prototype,"_isConstructedFromFunctionRaster",void 0),(0,T._)([(0,M.Cb)()],t.prototype,"_rasterJobHandler",void 0),(0,T._)([(0,M.Cb)()],t.prototype,"bandIds",void 0),(0,T._)([(0,M.Cb)({json:{origins:{service:{read:{source:"copyrightText"}}}}})],t.prototype,"copyright",void 0),(0,T._)([(0,M.Cb)({json:{read:!1}})],t.prototype,"fullExtent",null),(0,T._)([(0,M.Cb)()],t.prototype,"interpolation",void 0),(0,T._)([(0,M.Cb)()],t.prototype,"ioConfig",void 0),(0,T._)([(0,M.Cb)({type:[et.Z],json:{write:!0}})],t.prototype,"multidimensionalDefinition",null),(0,T._)([(0,M.Cb)({type:Ct.Z,json:{write:!0}})],t.prototype,"multidimensionalSubset",void 0),(0,T._)([(0,M.Cb)()],t.prototype,"raster",void 0),(0,T._)([(0,M.Cb)({type:_e.Z})],t.prototype,"rasterFunction",void 0),(0,T._)([(0,M.Cb)()],t.prototype,"rasterInfo",void 0),(0,T._)([(0,M.Cb)()],t.prototype,"sourceJSON",void 0),(0,T._)([(0,M.Cb)({readOnly:!0,type:X.Z,json:{read:!1}})],t.prototype,"spatialReference",void 0),(0,T._)([(0,M.Cb)({json:{read:!1}})],t.prototype,"tileInfo",null),(0,T._)([(0,M.Cb)(Ae.HQ)],t.prototype,"url",null),(0,T._)([(0,M.Cb)({types:Be.dr})],t.prototype,"renderer",null),(0,T._)([(0,M.Cb)()],t.prototype,"symbolizer",void 0),t=(0,T._)([(0,ie.j)("esri.layers.ImageryTileMixin")],t),t};var Ht=w(49286),Nt=w(6647),Jt=w(30346),Wt=w(99555),Lt=w(97941),Te=w(36255),At=w(2939),we=w(79645),lt=w(15365);function _t(s){const t=s.fields,c=s.records,i=t.some(p=>"oid"===p.name.toLowerCase())?"OBJECTID":"OID",a=[{name:i,type:"esriFieldTypeOID",alias:"OID"}].concat(t.map(p=>({name:p.name,type:"esriFieldType"+p.typeName,alias:p.name}))),f=a.map(p=>p.name),u=[];let m=0,d=0;return c.forEach(p=>{const h={};for(h[i]=m++,d=1;d<f.length;d++)h[f[d]]=p[d-1];u.push({attributes:h})}),{displayFieldName:"",fields:a,features:u}}class ct{static get supportedVersions(){return[5]}static parse(t){const c=new DataView(t),i=3&c.getUint8(0);if(3!==i)return{header:{version:i},recordSet:null};const a=c.getUint32(4,!0),f=c.getUint16(8,!0),u=c.getUint16(10,!0),m={version:i,recordCount:a,headerByteCount:f,recordByteCount:u};let d=32;const p=[],h=[];let g;if(3===i){for(;13!==c.getUint8(d);)g=String.fromCharCode(c.getUint8(d+11)).trim(),p.push({name:(0,lt.f)(new Uint8Array(t,d,11)),type:g,typeName:["String","Date","Double","Boolean","String","Integer"][["C","D","F","L","M","N"].indexOf(g)],length:c.getUint8(d+16)}),d+=32;if(d+=1,p.length>0)for(;h.length<a&&t.byteLength-d>u;){const y=[];32===c.getUint8(d)?(d+=1,p.forEach(x=>{if("C"===x.type)y.push((0,lt.f)(new Uint8Array(t,d,x.length)).trim());else if("N"===x.type)y.push(parseInt(String.fromCharCode.apply(null,new Uint8Array(t,d,x.length)).trim(),10));else if("F"===x.type)y.push(parseFloat(String.fromCharCode.apply(null,new Uint8Array(t,d,x.length)).trim()));else if("D"===x.type){const v=String.fromCharCode.apply(null,new Uint8Array(t,d,x.length)).trim();y.push(new Date(parseInt(v.substring(0,4),10),parseInt(v.substring(4,6),10)-1,parseInt(v.substring(6,8),10)))}d+=x.length}),h.push(y)):d+=u}}return{header:m,fields:p,records:h,recordSet:_t({fields:p,records:h})}}}var ut=w(46572),ft=w(17253);const pe=new Map;pe.set("int16","esriFieldTypeSmallInteger"),pe.set("int32","esriFieldTypeInteger"),pe.set("int64","esriFieldTypeInteger"),pe.set("float32","esriFieldTypeSingle"),pe.set("float64","esriFieldTypeDouble"),pe.set("text","esriFieldTypeString");let Fe=class extends de{constructor(){super(...arguments),this.storageInfo=null,this.datasetFormat="CRF"}open(s){var t=this;return(0,D.Z)(function*(){yield t.init();const{data:c}=yield t.request(t.url+"/conf.json",{signal:s?.signal});if(!t._validateHeader(c))throw new J.Z("cloudraster:open","Invalid or unsupported conf.json.");t.datasetName=t.url.slice(t.url.lastIndexOf("/")+1);const{storageInfo:i,rasterInfo:a}=t._parseHeader(c);if("thematic"===a.dataType){const f=yield t._fetchAuxiliaryInformation();a.attributeTable=f}t._set("storageInfo",i),t._set("rasterInfo",a),t.ioConfig.retryCount=t.ioConfig.retryCount||0})()}fetchRawTile(s,t,c,i={}){var a=this;return(0,D.Z)(function*(){const{transposeInfo:f}=a.rasterInfo.storageInfo,{transposedVariableName:u}=i,m=!(!f||!u),d=m?0:a.rasterInfo.storageInfo.maximumPyramidLevel-s;if(d<0)return null;const p=a._buildCacheFilePath(d,t,c,i.multidimensionalDefinition,u),h=a._getIndexRecordFromBundle(t,c,m),g=yield a.request(p,{range:{from:0,to:a.storageInfo.headerSize-1},responseType:"array-buffer",signal:i.signal});if(!g)return null;const y=new Uint8Array(g.data),x=a._getTileEndAndContentType(y,h);if(0===x.recordSize)return null;const v=yield a.request(p,{range:{from:x.position,to:x.position+x.recordSize},responseType:"array-buffer",signal:i.signal});if(!v)return null;const[R,b]=a._getTileSize(m);return a.decodePixelBlock(v.data,{width:R,height:b,planes:null,pixelType:null,returnInterleaved:m})})()}_validateHeader(s){return s&&"RasterInfo"===s.type&&!["origin","extent","geodataXform","LODInfos","blockWidth","blockHeight","bandCount","pixelType","pixelSizeX","pixelSizeY","format","packetSize"].some(c=>!s[c])}_parseHeader(s){const t=["u1","u2","u4","u8","s8","u16","s16","u32","s32","f32","f64"][s.pixelType],{bandCount:c,histograms:i,colormap:a,blockWidth:f,blockHeight:u,firstPyramidLevel:m,maximumPyramidLevel:d}=s,p=s.statistics&&s.statistics.map(L=>({min:L.min,max:L.max,avg:L.mean,stddev:L.standardDeviation,median:L.median,mode:L.mode})),h=s.extent.spatialReference,g=s.geodataXform?.spatialReference,y=new X.Z(h?.wkid||h?.wkt?h:g);let x=new q.Z({xmin:s.extent.xmin,ymin:s.extent.ymin,xmax:s.extent.xmax,ymax:s.extent.ymax,spatialReference:y});const v=new Y.Z({x:s.pixelSizeX,y:s.pixelSizeY,spatialReference:y}),R=Math.round((x.xmax-x.xmin)/v.x),b=Math.round((x.ymax-x.ymin)/v.y),I=this._parseTransform(s.geodataXform),C=I?x:null;I&&(x=I.forwardTransform(x),v.x=(x.xmax-x.xmin)/R,v.y=(x.ymax-x.ymin)/b);const F=s.properties??{},Z=s.format.toLowerCase().replace("cache/",""),B=new Y.Z(s.origin.x,s.origin.y,y);let E,O,k,H;if(a&&a.colors)for(E=[],O=0;O<a.colors.length;O++)k=a.colors[O],H=a.values?a.values[O]:O,E.push([H,255&k,k<<16>>>24,k<<8>>>24,k>>>24]);const P=s.LODInfos,z=[];for(O=0;O<P.levels.length;O++)z.push(new tt.Z({level:P.levels[O],resolution:P.resolutions[O],scale:96/.0254*P.resolutions[O]}));const N=new Se.Z({dpi:96,lods:z,format:Z,origin:B,size:[f,u],spatialReference:y}),W={recordSize:8,packetSize:s.packetSize,headerSize:s.packetSize*s.packetSize*8+64},U=[{maxCol:Math.ceil(R/f)-1,maxRow:Math.ceil(b/u)-1,minCol:0,minRow:0}];let j=2;if(d>0)for(O=0;O<d;O++)U.push({maxCol:Math.ceil(R/j/f)-1,maxRow:Math.ceil(b/j/u)-1,minCol:0,minRow:0}),j*=2;const G=s.mdInfo;let $=null;if(G&&F._yxs){const L=F._yxs;$={packetSize:L.PacketSize,tileSize:[L.TileXSize,L.TileYSize]}}return{storageInfo:W,rasterInfo:new we.Z({width:R,height:b,pixelType:t,bandCount:c,extent:x,nativeExtent:C,transform:I,spatialReference:y,pixelSize:v,keyProperties:F,statistics:p,histograms:i,multidimensionalInfo:G,colormap:E,storageInfo:new Ce.Z({blockWidth:f,blockHeight:u,pyramidBlockWidth:f,pyramidBlockHeight:u,origin:B,tileInfo:N,transposeInfo:$,firstPyramidLevel:m,maximumPyramidLevel:d,blockBoundary:U})})}}_parseTransform(s){if(!(0,ut.j)(s))throw new J.Z("cloudraster:open","the data contains unsupported geodata transform types");const t=(0,ut.c)(s);if("identity"===t.type)return null;if("polynomial"!==t.type||!t.forwardCoefficients?.length||!t.inverseCoefficients?.length)throw new J.Z("cloudraster:open","the data contains unsupported geodata transforms - both forward and inverse coefficients are required currently");return t}_fetchAuxiliaryInformation(s){var t=this;return(0,D.Z)(function*(){const c=t.request(t.url+"/conf.vat.json",{signal:s}).then(u=>u.data).catch(()=>null),i=t.request(t.url+"/conf.vat.dbf",{responseType:"array-buffer",signal:s}).then(u=>u.data).catch(()=>null),a=yield Promise.all([c,i]);let f;if(a[0]){let u=a[0].fields;const m=a[0].values;if(u&&m){u=u.map(p=>({type:"OID"===p.name?"esriFieldTypeOID":pe.get(p.type),name:p.name,alias:p.alias||p.name}));const d=m.map(p=>({attributes:p}));u&&m&&(f={fields:u,features:d})}}return!f&&a[1]&&(f=ct.parse(a[1]).recordSet),ft.Z.fromJSON(f)})()}_buildCacheFilePath(s,t,c,i,a){const f=this._getPackageSize(!!a),u=Math.floor(t/f)*f,m=Math.floor(c/f)*f,d="R"+this._toHexString4(u)+"C"+this._toHexString4(m);let p="L";p+=s>=10?s.toString():"0"+s.toString();const{multidimensionalInfo:h}=this.rasterInfo,g=i?.[0];if((0,S.Wi)(h)||!g)return`${this.url}/_alllayers/${p}/${d}.bundle`;let y="_yxs";if(!a){y=h.variables.find(R=>R.name===g.variableName).dimensions[0].values.indexOf(g.values[0]).toString(16);const v=4-y.length;for(let R=0;R<v;R++)y="0"+y;y="S"+y}const x=this._getVariableFolderName(a||g.variableName);return`${this.url}/_alllayers/${x}/${y}/${p}/${d}.bundle`}_getPackageSize(s=!1){const{transposeInfo:t}=this.rasterInfo.storageInfo;return s&&(0,S.pC)(t)?t.packetSize??0:this.storageInfo.packetSize}_getTileSize(s=!1){const{storageInfo:t}=this.rasterInfo,{transposeInfo:c}=t;return s&&(0,S.pC)(c)?c.tileSize:t.tileInfo.size}_getVariableFolderName(s){return""===(s=s.trim())?"_v":s.replace(/[\{|\}\-]/g,"_").replace("\\*","_v")}_getIndexRecordFromBundle(s,t,c=!1){const i=this._getPackageSize(c),a=i*(s%i)+t%i;if(a<0)throw new Error("Invalid level / row / col");return 20+a*this.storageInfo.recordSize+44}_getTileEndAndContentType(s,t){const c=s.subarray(t,t+8);let i,a=0;for(i=0;i<5;i++)a|=(255&c[i])<<8*i;const f=0xffffffffff&a;for(a=0,i=5;i<8;i++)a|=(255&c[i])<<8*(i-5);return{position:f,recordSize:0xffffffffff&a}}_toHexString4(s){let t=s.toString(16);if(4!==t.length){let c=4-t.length;for(;c-- >0;)t="0"+t}return t}};(0,T._)([(0,M.Cb)({readOnly:!0})],Fe.prototype,"storageInfo",void 0),(0,T._)([(0,M.Cb)({type:String,json:{write:!0}})],Fe.prototype,"datasetFormat",void 0),Fe=(0,T._)([(0,ie.j)("esri.layers.support.rasterDatasets.CloudRaster")],Fe);const Ut=Fe;var jt=w(8314),Ze=w(17057);let Pe=class extends de{constructor(){super(...arguments),this.datasetFormat="MEMORY",this.data=null}open(s){var t=this;return(0,D.Z)(function*(){yield t.init();const c=t.data,{pixelBlock:i,statistics:a,histograms:f,name:u,keyProperties:m,nativeExtent:d,transform:p}=t.data,{width:h,height:g,pixelType:y}=i,x=c.extent??new q.Z({xmin:-.5,ymin:.5,xmax:h-.5,ymax:g-.5,spatialReference:new X.Z({wkid:3857})}),b=new we.Z({width:h,height:g,pixelType:y,extent:x,nativeExtent:d,transform:p,pixelSize:{x:x.width/h,y:x.height/g},spatialReference:x.spatialReference,bandCount:i.pixels.length,keyProperties:m||{},statistics:a,isPseudoSpatialReference:c.isPseudoSpatialReference??!c.extent,histograms:f});t.createRemoteDatasetStorageInfo(b,512,512),t._set("rasterInfo",b),t.updateTileInfo(),yield t._buildInMemoryRaster(i,{width:512,height:512},s),t.datasetName=u,t.url="/InMemory/"+u})()}fetchRawTile(s,t,c,i={}){const a=this._pixelBlockTiles.get(`${s}/${t}/${c}`);return Promise.resolve(a)}_buildInMemoryRaster(s,t,c){var i=this;return(0,D.Z)(function*(){const a=i.rasterInfo.storageInfo.maximumPyramidLevel,f=i.rasterJobHandler?i.rasterJobHandler.split({pixelBlock:s,tileSize:t,maximumPyramidLevel:a},c):Promise.resolve((0,fe.Vl)(s,t,a)),u=(0,S.pC)(i.rasterInfo.statistics),m=(0,S.pC)(i.rasterInfo.histograms),d=u?Promise.resolve({statistics:null,histograms:null}):i.rasterJobHandler?i.rasterJobHandler.estimateStatisticsHistograms({pixelBlock:s},c):Promise.resolve((0,Ze.Hv)(s)),p=yield(0,Re.as)([f,d]);if(!p[0].value&&p[1].value)throw new J.Z("inmemory-raster:open","failed to build in memory raster");i._pixelBlockTiles=p[0].value,u||(i.rasterInfo.statistics=p[1].value?.statistics),m||(i.rasterInfo.histograms=p[1].value?.histograms)})()}};(0,T._)([(0,M.Cb)({type:String,json:{write:!0}})],Pe.prototype,"datasetFormat",void 0),(0,T._)([(0,M.Cb)()],Pe.prototype,"data",void 0),Pe=(0,T._)([(0,ie.j)("esri.layers.support.rasterDatasets.InMemoryRaster")],Pe);const Gt=Pe;function xe(s,t){if(!s||!t)return[];let c=t;t.includes("/")?(c=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const i=[];if(t){const f=xe(s,c);for(let u=0;u<f.length;u++)xe(f[u],t).forEach(m=>i.push(m));return i}const a=s.getElementsByTagNameNS("*",c);if(!a||0===a.length)return[];for(let f=0;f<a.length;f++)i.push(a[f]||a.item[f]);return i}function te(s,t){if(!s||!t)return null;let c=t;t.includes("/")?(c=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const i=xe(s,c);return i.length>0?t?te(i[0],t):i[0]:null}function ne(s,t=null){const c=t?te(s,t):s;let i;return c?(i=c.textContent||c.nodeValue,i?i.trim():null):null}function ze(s,t){return function $t(s,t){const c=xe(s,t),i=[];let a;for(let f=0;f<c.length;f++)a=c[f].textContent||c[f].nodeValue,a&&(a=a.trim(),""!==a&&i.push(a));return i}(s,t).map(c=>Number(c))}function he(s,t){const c=ne(s,t);return Number(c)}function Ge(s,t){const c=s?.nodeName?.toLowerCase(),i=t.toLowerCase();return c.slice(c.lastIndexOf(":")+1)===i}var $e=w(85374);function mt(s,t){if(!s||!t)return null;const c=[];for(let i=0;i<s.length;i++)c.push(s[i]),c.push(t[i]);return c}function Ee(s){if(!s)return null;let t=Number(s);if(!isNaN(t)&&0!==t)return new X.Z({wkid:t});if((s=String(s)).startsWith("COMPD_CS")){if(!s.includes("VERTCS")||!s.includes("GEOGCS")&&!s.startsWith("PROJCS"))return null;const c=s.indexOf("VERTCS"),i=s.indexOf("PROJCS"),a=i>-1?i:s.indexOf("GEOGCS");if(-1===a)return null;const f=s.slice(a,s.lastIndexOf("]",c)+1).trim(),u=s.slice(c,s.lastIndexOf("]")).trim();t=Ve(f);const m=new X.Z(t?{wkid:t}:{wkt:f}),d=Ve(u);return d&&(m.vcsWkid=d),m}return s.startsWith("GEOGCS")||s.startsWith("PROJCS")?(t=Ve(s),new X.Z(0!==t?{wkid:t}:{wkt:s})):null}function Ve(s){const t=s.replace(/\]/g,"[").replace(/\"/g,"").split("[").map(a=>a.trim()).filter(a=>""!==a),c=t[t.length-1].split(","),i=c[0]?.toLowerCase();if(("epsg"===i||"esri"===i)&&s.endsWith('"]]')){const a=Number(c[1]);if(!isNaN(a)&&0!==a)return a}return 0}function Ye(s){if("pamdataset"!==s?.documentElement.tagName?.toLowerCase())return{};const t={spatialReference:null,transform:null,metadata:{},rasterBands:[],statistics:null,histograms:null};s.documentElement.childNodes.forEach(i=>{if(1===i.nodeType)if(Ge(i,"SRS")){if(!t.spatialReference){const a=ne(i);t.spatialReference=Ee(a)}}else if(Ge(i,"Metadata"))if("xml:ESRI"===i.getAttribute("domain")){const{spatialReference:a,transform:f}=function Vt(s){const t=te(s,"GeodataXform"),c=Ee(he(t,"SpatialReference/WKID")||ne(t,"SpatialReference/WKT"));if("typens:PolynomialXform"!==t.getAttribute("xsi:type"))return{spatialReference:c,transform:null};const i=he(t,"PolynomialOrder")??1,a=ze(t,"CoeffX/Double"),f=ze(t,"CoeffY/Double"),u=ze(t,"InverseCoeffX/Double"),m=ze(t,"InverseCoeffY/Double"),d=mt(a,f),p=mt(u,m);return{spatialReference:c,transform:d&&p&&d.length&&p.length?new $e.Z({spatialReference:c,polynomialOrder:i,forwardCoefficients:d,inverseCoefficients:p}):null}}(i);t.transform=f,t.spatialReference||(t.spatialReference=a)}else xe(i,"MDI").forEach(a=>t.metadata[a.getAttribute("key")]=ne(a));else if(Ge(i,"PAMRasterBand")){const a=function Yt(s){const t=he(s,"NoDataValue"),c=te(s,"Histograms/HistItem"),i=he(c,"HistMin"),a=he(c,"HistMax"),f=he(c,"BucketCount"),u=ne(c,"HistCounts")?.split("|").map(y=>Number(y));let m,d,p,h;xe(s,"Metadata/MDI").forEach(y=>{const x=Number(y.textContent??y.nodeValue);switch(y.getAttribute("key").toUpperCase()){case"STATISTICS_MINIMUM":m=x;break;case"STATISTICS_MAXIMUM":d=x;break;case"STATISTICS_MEAN":p=x;break;case"STATISTICS_STDDEV":h=x}});const g=he(s,"Metadata/SourceBandIndex");return{noDataValue:t,histogram:u?.length&&null!=i&&null!=a?{min:i,max:a,size:f||u.length,counts:u}:null,sourceBandIndex:g,statistics:null!=m&&null!=d?{min:m,max:d,avg:p,stddev:h}:null}}(i);null!=a.sourceBandIndex&&null==t.rasterBands[a.sourceBandIndex]?t.rasterBands[a.sourceBandIndex]=a:t.rasterBands.push(a)}});const c=t.rasterBands;return c.length&&(t.statistics=c[0].statistics?c.map(f=>f.statistics).filter(S.pC):null,t.histograms=c[0].histogram?c.map(f=>f.histogram).filter(S.pC):null),t}let He=class extends de{open(s){var t=this;return(0,D.Z)(function*(){yield t.init();const c=yield t._fetchData(s);let{spatialReference:i,statistics:a,histograms:f,transform:u}=yield t._fetchAuxiliaryData(s);const m=!i;m&&(i=new X.Z({wkid:3857})),f?.length&&null==a&&(a=(0,Ze.Oh)(f));const{width:d,height:p}=c;let h=new q.Z({xmin:-.5,ymin:.5-p,xmax:d-.5,ymax:.5,spatialReference:i});const g=u?u.forwardTransform(h):h;let y=!0;if(u){const v=u.forwardCoefficients;y=v&&0===v[1]&&0===v[2],y&&(u=null,h=g)}const x=new Gt({data:{extent:g,nativeExtent:h,transform:u,pixelBlock:c,statistics:a,histograms:f,keyProperties:{DateType:"Processed"},isPseudoSpatialReference:m}});yield x.open(),x.data=null,t._set("rasterInfo",x.rasterInfo),t._inMemoryRaster=x})()}fetchRawTile(s,t,c,i={}){return this._inMemoryRaster.fetchRawTile(s,t,c,i)}_fetchData(s){var t=this;return(0,D.Z)(function*(){const{data:c}=yield t.request(t.url,{responseType:"array-buffer",signal:s?.signal}),i=(0,st.y)(c).toUpperCase();if("JPG"!==i&&"PNG"!==i&&"GIF"!==i&&"BMP"!==i)throw new J.Z("image-aux-raster:open","the data is not a supported format");t._set("datasetFormat",i);const a=i.toLowerCase(),f="gif"===a||"bmp"===a||!(0,jt.Z)("ios"),u=yield t.decodePixelBlock(c,{format:a,useCanvas:f,hasNoZlibMask:!0});if(null==u)throw new J.Z("image-aux-raster:open","the data cannot be decoded");return u})()}_fetchAuxiliaryData(s){var t=this;return(0,D.Z)(function*(){const c=(0,S.Wg)(s?.signal),i=t.ioConfig.skipExtensions??[],a=i.includes("aux.xml")?null:t.request(t.url+".aux.xml",{responseType:"xml",signal:c}),f=t.datasetFormat,u="JPG"===f?"jgw":"PNG"===f?"pgw":"BMP"===f?"bpw":null,m=u&&i.includes(u)?null:t.request(t.url.slice(0,t.url.lastIndexOf("."))+"."+u,{responseType:"text",signal:c}),d=yield(0,Re.as)([a,m]);if(c?.aborted)throw(0,Re.zE)();const p=Ye(d[0].value?.data);if(!p.transform){const h=d[1].value?d[1].value.data.split("\n").slice(0,6).map(g=>Number(g)):null;p.transform=6===h?.length?new $e.Z({forwardCoefficients:[h[4],h[5],h[0],-h[1],h[2],-h[3]]}):null}return p})()}};(0,T._)([(0,M.Cb)({type:String,json:{write:!0}})],He.prototype,"datasetFormat",void 0),He=(0,T._)([(0,ie.j)("esri.layers.support.rasterDatasets.ImageAuxRaster")],He);const Ne=He;var Xt=w(21726),Kt=w(51026),Qt=w(28930),qt=w(76671),er=w(99208);let Me=class extends de{constructor(){super(...arguments),this._levelOffset=0,this._tilemapCache=null,this._slices=null,this.datasetFormat="RasterTileServer",this.tileType=null}open(s){var t=this;return(0,D.Z)(function*(){yield t.init();const c=s&&s.signal,i=t.sourceJSON?{data:t.sourceJSON}:yield t.request(t.url,{query:{f:"json"},signal:c});i.ssl&&(t.url=t.url.replace(/^http:/i,"https:"));const a=i.data;if(t.sourceJSON=a,!a)throw new J.Z("imageserverraster:open","cannot initialize tiled image service, missing service info");if(!a.tileInfo)throw new J.Z("imageserverraster:open","use ImageryLayer to open non-tiled image services");t._fixScaleInServiceInfo(),t.tileType=a.cacheType,null==t.tileType&&(t.tileType=["jpg","jpeg","png","png8","png24","png32","mixed"].includes(a.tileInfo.format.toLowerCase())?"Map":"lerc"===a.tileInfo.format.toLowerCase()?"Elevation":"Raster"),t.datasetName=a.name?.slice(a.name.indexOf("/")+1)??"";const u=yield t._fetchRasterInfo({signal:c});if((0,S.Wi)(u))throw new J.Z("image-server-raster:open","cannot initialize image service");const m="Map"===t.tileType?(0,Kt.d)(a.tileInfo,a):Se.Z.fromJSON(a.tileInfo);(0,S.O3)(m);const[d,p]=t._computeMinMaxLOD(u,m),{extent:h,pixelSize:g}=u,y=.5/u.width*g.x,x=Math.max(g.x,g.y),{lods:v}=m;("Map"!==t.tileType&&0!==a.maxScale||Math.abs(g.x-g.y)>y||!v.some(k=>Math.abs(k.resolution-x)<y))&&(g.x=g.y=d.resolution,u.width=Math.ceil((h.xmax-h.xmin)/g.x-.1),u.height=Math.ceil((h.ymax-h.ymin)/g.y-.1));const R=d.level-p.level,[b,I]=m.size,C=[],F=[];v.forEach((k,H)=>{k.level>=p.level&&k.level<=d.level&&C.push({x:k.resolution,y:k.resolution}),H<v.length-1&&F.push(Math.round(10*k.resolution/v[H+1].resolution)/10)}),C.sort((k,H)=>k.x-H.x);const Z=t.computeBlockBoundary(h,b,I,m.origin,C,R),B=C.length>1?C.slice(1):null;let E;a.transposeInfo&&(E={tileSize:[a.transposeInfo.rows,a.transposeInfo.cols],packetSize:u.keyProperties?._yxs.PacketSize??0});const O=F.length<=1||F.length>=3&&F.slice(0,F.length-1).every(k=>k===F[0])?F[0]??2:Math.round(10/(p.resolution/d.resolution)**(-1/R))/10;if(u.storageInfo=new Ce.Z({blockWidth:m.size[0],blockHeight:m.size[1],pyramidBlockWidth:m.size[0],pyramidBlockHeight:m.size[1],pyramidResolutions:B,pyramidScalingFactor:O,compression:m.format,origin:m.origin,firstPyramidLevel:1,maximumPyramidLevel:R,tileInfo:m,transposeInfo:E,blockBoundary:Z}),t._fixGCSShift(u),t._set("rasterInfo",u),a.capabilities.toLowerCase().includes("tilemap")){const k={tileInfo:u.storageInfo.tileInfo,parsedUrl:(0,Xt.mN)(t.url),url:t.url,tileServers:[],type:"tile"};t._tilemapCache=new Qt.y({layer:k})}})()}fetchRawTile(s,t,c,i={}){var a=this;return(0,D.Z)(function*(){const{storageInfo:f,extent:u}=a.rasterInfo,{transposeInfo:m}=f,d=(0,S.pC)(m)&&!!i.transposedVariableName;if(a._slices&&!d&&null==i.sliceId)return null;const h=`${a.url}/tile/${d?0:f.maximumPyramidLevel-s+a._levelOffset}/${t}/${c}`,g=a._slices?d?{variable:i.transposedVariableName}:{sliceId:i.sliceId||0}:null,{data:y}=yield a.request(h,{query:g,responseType:"array-buffer",signal:i.signal});if(!y)return null;const x=d?m.tileSize:f.tileInfo.size,v=yield a.decodePixelBlock(y,{width:x[0],height:x[1],planes:null,pixelType:null,isPoint:"Elevation"===a.tileType,returnInterleaved:d,noDataValue:(0,S.Wg)(a.rasterInfo.noDataValue)});if(null==v)return null;const R=f.blockBoundary[s];if("jpg"!==f.compression||c>R.minCol&&c<R.maxCol&&t>R.minRow&&t<R.maxRow)return v;const{origin:b,blockWidth:I,blockHeight:C}=f,{x:F,y:Z}=a.getPyramidPixelSize(s),B=Math.round((u.xmin-b.x)/F)%I,E=Math.round((u.xmax-b.x)/F)%I||I,O=Math.round((b.y-u.ymax)/Z)%C,k=Math.round((b.y-u.ymin)/Z)%C||C,H=c===R.minCol?B:0,P=t===R.minRow?O:0;return(0,fe.pW)(v,{x:H,y:P},{width:(c===R.maxCol?E:I)-H,height:(t===R.maxRow?k:C)-P}),v})()}getSliceIndex(s){if(!this._slices||(0,S.Wi)(s)||0===s.length)return null;const t=s;for(let c=0;c<this._slices.length;c++){const i=this._slices[c].multidimensionalDefinition;if(i.length===t.length&&!i.some(a=>{const f=t.find(u=>a.variableName===u.variableName&&u.dimensionName===a.dimensionName);return!f||(Array.isArray(a.values[0])?`${a.values[0][0]}-${a.values[0][1]}`:a.values[0])!==(Array.isArray(f.values[0])?`${f.values[0][0]}-${f.values[0][1]}`:f.values[0])}))return c}return null}fetchVariableStatisticsHistograms(s,t){var c=this;return(0,D.Z)(function*(){const i=c.request(c.url+"/statistics",{query:{variable:s,f:"json"},signal:t}).then(u=>u.data?.statistics),a=c.request(c.url+"/histograms",{query:{variable:s,f:"json"},signal:t}).then(u=>u.data?.histograms),f=yield Promise.all([i,a]);return f[0]&&f[0].forEach(u=>{u.avg=u.mean,u.stddev=u.standardDeviation}),{statistics:f[0]||null,histograms:f[1]||null}})()}computeBestPyramidLevelForLocation(s,t={}){var c=this;return(0,D.Z)(function*(){if(!c._tilemapCache)return 0;let i=c.identifyPixelLocation(s,0,(0,S.Wg)(t.datumTransformation));if(null===i)return null;let a=0;const{maximumPyramidLevel:f}=c.rasterInfo.storageInfo;let u=f-a+c._levelOffset;const m=i.srcLocation;for(;u>=0;){try{if("available"===(yield c._tilemapCache.fetchAvailability(u,i.row,i.col,t)))break}catch{}if(u--,a++,i=c.identifyPixelLocation(m,a,(0,S.Wg)(t.datumTransformation)),null===i)return null}return-1===u||null==i?null:a})()}_fetchRasterInfo(s){var t=this;return(0,D.Z)(function*(){const c=t.sourceJSON;if("Map"===t.tileType){const m=c.fullExtent||c.extent,d=Math.ceil((m.xmax-m.xmin)/c.pixelSizeX-.1),p=Math.ceil((m.ymax-m.ymin)/c.pixelSizeY-.1),h=X.Z.fromJSON(c.spatialReference||m.spatialReference),g=new Y.Z({x:c.pixelSizeX,y:c.pixelSizeY,spatialReference:h});return new we.Z({width:d,height:p,bandCount:3,extent:q.Z.fromJSON(m),spatialReference:h,pixelSize:g,pixelType:"u8",statistics:null,keyProperties:{DataType:"processed"}})}const{signal:i}=s,a=(0,er.g)(t.url,t.sourceJSON,{signal:i,query:t.ioConfig.customFetchParameters}),f=c.hasMultidimensions?t.request(`${t.url}/slices`,{query:{f:"json"},signal:i}).then(m=>m.data&&m.data.slices).catch(()=>null):null,u=yield Promise.all([a,f]);return t._slices=u[1],u[0]})()}_fixScaleInServiceInfo(){const{sourceJSON:s}=this;s.minScale&&s.minScale<0&&(s.minScale=0),s.maxScale&&s.maxScale<0&&(s.maxScale=0)}_fixGCSShift(s){const{extent:t,spatialReference:c}=s;t.xmin>-1&&t.xmax>181&&c?.wkid&&c.isGeographic&&(s.nativeExtent=s.extent,s.transform=new qt.Z,s.extent=s.transform.forwardTransform(t))}_computeMinMaxLOD(s,t){const{pixelSize:c}=s,i=.5/s.width*c.x,{lods:a}=t,f=t.lodAt(Math.max.apply(null,a.map(y=>y.level))),u=t.lodAt(Math.min.apply(null,a.map(y=>y.level))),{tileType:m}=this;if("Map"===m)return this._levelOffset=a[0].level,[f,u];if("Raster"===m)return[a.find(y=>y.resolution===c.x)??f,u];const{minScale:d,maxScale:p}=this.sourceJSON;let h=f;p>0&&(h=a.find(y=>Math.abs(y.scale-p)<i),h||(h=a.filter(y=>y.scale>p).sort((y,x)=>y.scale>x.scale?1:-1)[0]??f));let g=u;return d>0&&(g=a.find(y=>Math.abs(y.scale-d)<i)??u,this._levelOffset=g.level-u.level),[h,g]}};(0,T._)([(0,M.Cb)({type:String,json:{write:!0}})],Me.prototype,"datasetFormat",void 0),(0,T._)([(0,M.Cb)()],Me.prototype,"tileType",void 0),Me=(0,T._)([(0,ie.j)("esri.layers.support.rasterDatasets.ImageServerRaster")],Me);const tr=Me;var rr=w(25688),nr=w(44853);const ae=new Map;ae.set("Int8","s8"),ae.set("UInt8","u8"),ae.set("Int16","s16"),ae.set("UInt16","u16"),ae.set("Int32","s32"),ae.set("UInt32","u32"),ae.set("Float32","f32"),ae.set("Float64","f32"),ae.set("Double64","f32");const ue=new Map;ue.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),ue.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),ue.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),ue.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let Ie=class extends de{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}open(s){var t=this;return(0,D.Z)(function*(){yield t.init(),t.datasetName=t.url.slice(t.url.lastIndexOf("/")+1);const c=s?(0,S.Wg)(s.signal):null,i=yield t.request(t.url,{responseType:"xml",signal:c}),{rasterInfo:a,files:f}=t._parseHeader(i.data);if(-1===t.ioConfig.skipExtensions?.indexOf("aux.xml")){const b=yield t._fetchAuxiliaryData(s);null!=b&&(a.statistics=b.statistics??a.statistics,a.histograms=b.histograms,b.histograms&&(0,S.Wi)(a.statistics)&&(a.statistics=(0,Ze.Oh)(b.histograms)))}t._set("rasterInfo",a),t._files=f;const u=yield t.request(f.index,{responseType:"array-buffer",signal:c});t._storageIndex=t._parseIndex(u.data);const{blockWidth:m,blockHeight:d}=t.rasterInfo.storageInfo,p=t.rasterInfo.storageInfo.pyramidScalingFactor,{width:h,height:g}=t.rasterInfo,y=[],x=t._getBandSegmentCount();let v=0,R=-1;for(;v<t._storageIndex.length;){R++;const b=Math.ceil(h/m/p**R)-1,I=Math.ceil(g/d/p**R)-1;v+=(b+1)*(I+1)*x*4,y.push({maxRow:I,maxCol:b,minCol:0,minRow:0})}t.rasterInfo.storageInfo.blockBoundary=y,R>0&&(t.rasterInfo.storageInfo.firstPyramidLevel=1,t.rasterInfo.storageInfo.maximumPyramidLevel=R),t.updateTileInfo()})()}fetchRawTile(s,t,c,i={}){var a=this;return(0,D.Z)(function*(){const{blockWidth:f,blockHeight:u,blockBoundary:m}=a.rasterInfo.storageInfo,d=m[s];if(!d||d.maxRow<t||d.maxCol<c||d.minRow>t||d.minCol>c)return null;const{bandCount:p,pixelType:h}=a.rasterInfo,{ranges:g,actualTileWidth:y,actualTileHeight:x}=a._getTileLocation(s,t,c);if(!g||0===g.length)return null;if(0===g[0].from&&0===g[0].to){const P=new Uint8Array(f*u);return new rr.Z({width:f,height:u,pixels:null,mask:P,validPixelCount:0})}const{bandIds:v}=a.ioConfig,R=a._getBandSegmentCount(),b=[];let I=0;for(I=0;I<R;I++)(!v||v.indexOf[I]>-1)&&b.push(a.request(a._files.data,{range:{from:g[I].from,to:g[I].to},responseType:"array-buffer",signal:i.signal}));const C=yield Promise.all(b),F=C.map(P=>P.data.byteLength).reduce((P,z)=>P+z),Z=new Uint8Array(F);let B=0;for(I=0;I<R;I++)Z.set(new Uint8Array(C[I].data),B),B+=C[I].data.byteLength;const E=ue.get(a.rasterInfo.storageInfo.compression).decoderFormat,O=yield a.decodePixelBlock(Z.buffer,{width:f,height:u,format:E,planes:v?.length||p,pixelType:h});if(null==O)return null;if((0,S.pC)(a.rasterInfo.noDataValue)&&"lerc"!==E&&!O.mask){const P=a.rasterInfo.noDataValue[0];if(null!=P){const z=O.width*O.height,N=new Uint8Array(z);if(Math.abs(P)>1e24)for(I=0;I<z;I++)Math.abs((O.pixels[0][I]-P)/P)>1e-6&&(N[I]=1);else for(I=0;I<z;I++)O.pixels[0][I]!==P&&(N[I]=1);O.mask=N}}let k=0,H=0;if(y!==f||x!==u){let P=O.mask;if(P)for(I=0;I<u;I++)if(H=I*f,I<x)for(k=y;k<f;k++)P[H+k]=0;else for(k=0;k<f;k++)P[H+k]=0;else for(P=new Uint8Array(f*u),O.mask=P,I=0;I<x;I++)for(H=I*f,k=0;k<y;k++)P[H+k]=1}return O})()}_parseIndex(s){if(s.byteLength%16>0)throw new Error("invalid array buffer must be multiples of 16");let t,c,i,a,f,u;if(nr.f){for(c=new Uint8Array(s),a=new ArrayBuffer(s.byteLength),i=new Uint8Array(a),f=0;f<s.byteLength/4;f++)for(u=0;u<4;u++)i[4*f+u]=c[4*f+3-u];t=new Uint32Array(a)}else t=new Uint32Array(s);return t}_getBandSegmentCount(){return ue.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(s,t,c){const{blockWidth:i,blockHeight:a,pyramidScalingFactor:f}=this.rasterInfo.storageInfo,{width:u,height:m}=this.rasterInfo,d=this._getBandSegmentCount();let p,h,g,y=0,x=0;for(g=0;g<s;g++)x=f**g,p=Math.ceil(u/i/x),h=Math.ceil(m/a/x),y+=p*h;x=f**s,p=Math.ceil(u/i/x),h=Math.ceil(m/a/x),y+=t*p+c,y*=4*d;const v=this._storageIndex.subarray(y,y+4*d);let R=0,b=0;const I=[];for(let C=0;C<d;C++)R=v[4*C+0]*2**32+v[4*C+1],b=R+v[4*C+2]*2**32+v[4*C+3],I.push({from:R,to:b});return{ranges:I,actualTileWidth:c<p-1?i:Math.ceil(u/x)-i*(p-1),actualTileHeight:t<h-1?a:Math.ceil(m/x)-a*(h-1)}}_parseHeader(s){const t=te(s,"MRF_META/Raster");if(!t)throw new J.Z("mrf:open","not a valid MRF format");const c=te(t,"Size"),i=parseInt(c.getAttribute("x"),10),a=parseInt(c.getAttribute("y"),10),f=parseInt(c.getAttribute("c"),10),u=(ne(t,"Compression")||"none").toLowerCase();if(!ue.has(u))throw new J.Z("mrf:open","currently does not support compression "+u);const m=ne(t,"DataType")||"UInt8",d=ae.get(m);if(null==d)throw new J.Z("mrf:open","currently does not support pixel type "+m);const p=te(t,"PageSize"),h=parseInt(p.getAttribute("x"),10),g=parseInt(p.getAttribute("y"),10),y=te(t,"DataValues");let x,v;if(y&&(v=y.getAttribute("NoData"),null!=v&&(x=v.trim().split(" ").map(z=>parseFloat(z)))),te(s,"MRF_META/CachedSource"))throw new J.Z("mrf:open","currently does not support MRF referencing other data files");const R=te(s,"MRF_META/GeoTags"),b=te(R,"BoundingBox");let I,C=!1;if(null!=b){const z=parseFloat(b.getAttribute("minx")),N=parseFloat(b.getAttribute("miny")),W=parseFloat(b.getAttribute("maxx")),U=parseFloat(b.getAttribute("maxy")),j=ne(R,"Projection")||"";let G=X.Z.WGS84;if("LOCAL_CS[]"!==j)if(j.toLowerCase().startsWith("epsg:")){const $=Number(j.slice(5));isNaN($)||0===$||(G=new X.Z({wkid:$}))}else G=Ee(j)??X.Z.WGS84;else C=!0,G=new X.Z({wkid:3857});I=new q.Z(z,N,W,U),I.spatialReference=G}else C=!0,I=new q.Z({xmin:-.5,ymin:.5-a,xmax:i-.5,ymax:.5,spatialReference:new X.Z({wkid:3857})});const F=te(s,"MRF_META/Rsets"),Z=parseInt(F&&F.getAttribute("scale")||"2",10),B=I.spatialReference,E=new Ce.Z({origin:new Y.Z({x:I.xmin,y:I.ymax,spatialReference:B}),blockWidth:h,blockHeight:g,pyramidBlockWidth:h,pyramidBlockHeight:g,compression:u,pyramidScalingFactor:Z}),O=new Y.Z({x:I.width/i,y:I.height/a,spatialReference:B}),k=new we.Z({width:i,height:a,extent:I,isPseudoSpatialReference:C,spatialReference:B,bandCount:f,pixelType:d,pixelSize:O,noDataValue:x,storageInfo:E}),H=ne(s,"datafile"),P=ne(s,"IndexFile");return{rasterInfo:k,files:{mrf:this.url,index:P||this.url.replace(".mrf",".idx"),data:H||this.url.replace(".mrf",ue.get(u).blobExtension)}}}_fetchAuxiliaryData(s){var t=this;return(0,D.Z)(function*(){try{const{data:c}=yield t.request(t.url+".aux.xml",{responseType:"xml",signal:s?.signal});return Ye(c)}catch{return null}})()}};(0,T._)([(0,M.Cb)()],Ie.prototype,"_files",void 0),(0,T._)([(0,M.Cb)()],Ie.prototype,"_storageIndex",void 0),(0,T._)([(0,M.Cb)({type:String,json:{write:!0}})],Ie.prototype,"datasetFormat",void 0),Ie=(0,T._)([(0,ie.j)("esri.layers.support.rasterIO.MRFRaster")],Ie);const ir=Ie;var ye=w(93122),Je=w(635);const Xe=(s,t)=>s.get(t)?.values,ke=(s,t)=>s.get(t)?.values?.[0];let ge=class extends de{constructor(){super(...arguments),this._files=null,this._headerInfo=null,this._bufferSize=1048576,this.datasetFormat="TIFF"}open(s){var t=this;return(0,D.Z)(function*(){yield t.init();const c=s?(0,S.Wg)(s.signal):null,{data:i}=yield t.request(t.url,{range:{from:0,to:t._bufferSize},responseType:"array-buffer",signal:c});if(!i)throw new J.Z("tiffraster:open","failed to open url "+t.url);t.datasetName=t.url.slice(t.url.lastIndexOf("/")+1,t.url.lastIndexOf("."));const{littleEndian:a,firstIFDPos:f,isBigTiff:u}=(0,ye.cK)(i),m=[];yield t._readIFDs(m,i,a,f,0,u?8:4,c);const{imageInfo:d,rasterInfo:p}=t._parseIFDs(m),h=(0,ye.ee)(m),g=(0,ye.I7)(m);if(t._headerInfo={littleEndian:a,isBigTiff:u,ifds:m,pyramidIFDs:h,maskIFDs:g,...d},t._set("rasterInfo",p),!d.isSupported)throw new J.Z("tiffraster:open","this tiff is not supported: "+d.message);if(!d.tileWidth)throw new J.Z("tiffraster:open","none-tiled tiff is not optimized for access, convert to COG and retry.");const{skipExtensions:y=[]}=t.ioConfig;if(!y.includes("aux.xml")){const x=yield t._fetchAuxiliaryMetaData(s);null!=x&&t._processPAMInfo(x,p)}y.includes("vat.dbf")||1!==p.bandCount||"u8"!==p.pixelType||(p.attributeTable=yield t._fetchAuxiliaryTable(s),(0,S.pC)(p.attributeTable)&&(p.keyProperties.DataType="thematic")),t.updateTileInfo()})()}fetchRawTile(s,t,c,i={}){var a=this;return(0,D.Z)(function*(){if(!a._headerInfo?.isSupported||a.isBlockOutside(s,t,c))return null;const f=yield a._fetchRawTiffTile(s,t,c,!1,i);if((0,S.pC)(f)&&a._headerInfo.hasMaskBand){const u=yield a._fetchRawTiffTile(s,t,c,!0,i);(0,S.pC)(u)&&u.pixels[0]instanceof Uint8Array&&(f.mask=u.pixels[0])}return f})()}_parseIFDs(s){const t=(0,ye.FI)(s),{width:c,height:i,tileWidth:a,tileHeight:f,planes:u,pixelType:m,compression:d,firstPyramidLevel:p,maximumPyramidLevel:h,pyramidBlockWidth:g,pyramidBlockHeight:y,tileBoundary:x,affine:v,metadata:R}=t;let I=Ee(t.extent.spatialReference?.wkt||t.extent.spatialReference?.wkid),C=!!t.isPseudoGeographic;null==I&&(C=!0,I=new X.Z({wkid:3857}));const F=new q.Z({...t.extent,spatialReference:I}),Z=new Y.Z(F?{x:F.xmin,y:F.ymax,spatialReference:I}:{x:0,y:0}),B=new Ce.Z({blockWidth:a,blockHeight:f,pyramidBlockWidth:g,pyramidBlockHeight:y,compression:d,origin:Z,firstPyramidLevel:p,maximumPyramidLevel:h,blockBoundary:x}),E=new Y.Z({x:(F.xmax-F.xmin)/c,y:(F.ymax-F.ymin)/i,spatialReference:I}),O=R?{BandProperties:R.bandProperties,DataType:R.dataType}:{};let k=null;const H=ke(s[0],"PHOTOMETRICINTERPRETATION"),P=Xe(s[0],"COLORMAP");if(H<=3&&P?.length>3&&P.length%3==0){k=[];const N=P.length/3;for(let W=0;W<N;W++)k.push([W,P[W]>>>8,P[W+N]>>>8,P[W+2*N]>>>8])}const z=new we.Z({width:c,height:i,bandCount:u,pixelType:m,pixelSize:E,storageInfo:B,spatialReference:I,isPseudoSpatialReference:C,keyProperties:O,extent:F,colormap:k,statistics:R?R.statistics:null});return v?.length&&(z.nativeExtent=new q.Z({xmin:-.5,ymin:.5-i,xmax:c-.5,ymax:.5,spatialReference:I}),z.transform=new $e.Z({polynomialOrder:1,forwardCoefficients:[v[2]+v[0]/2,v[5]-v[3]/2,v[0],v[3],-v[1],-v[4]]}),z.extent=z.transform.forwardTransform(z.nativeExtent),z.pixelSize=new Y.Z({x:(F.xmax-F.xmin)/c,y:(F.ymax-F.ymin)/i,spatialReference:I}),B.origin.x=-.5,B.origin.y=.5),{imageInfo:t,rasterInfo:z}}_processPAMInfo(s,t){if(t.statistics=s.statistics??t.statistics,t.histograms=s.histograms,s.histograms&&(0,S.Wi)(t.statistics)&&(t.statistics=(0,Ze.Oh)(s.histograms)),s.transform&&(0,S.Wi)(t.transform)){t.transform=s.transform,t.nativeExtent=t.extent;const c=t.transform.forwardTransform(t.nativeExtent);t.pixelSize=new Y.Z({x:(c.xmax-c.xmin)/t.width,y:(c.ymax-c.ymin)/t.height,spatialReference:t.spatialReference}),t.extent=c}t.isPseudoSpatialReference&&s.spatialReference&&(t.spatialReference=s.spatialReference)}_readIFDs(s,t,c,i,a,f=4,u){var m=this;return(0,D.Z)(function*(){if(!i)return null;(i>=t.byteLength||i<0)&&(t=(yield m.request(m.url,{range:{from:i+a,to:i+a+m._bufferSize},responseType:"array-buffer",signal:u})).data,a=i+a,i=0);const d=yield m._readIFD(t,c,i,a,Je.Z.TIFF_TAGS,f,u);if(s.push(d.ifd),!d.nextIFD)return null;yield m._readIFDs(s,t,c,d.nextIFD-a,a,f,u)})()}_readIFD(s,t,c,i,a=Je.Z.TIFF_TAGS,f=4,u){var m=this;return(0,D.Z)(function*(){if(!s)return null;const d=(0,ye.vr)(s,t,c,i,a,f);if(d.success){const p=[];if(d.ifd?.forEach(h=>{h.values||p.push(h)}),p.length>0){const h=p.map(y=>y.offlineOffsetSize).filter(S.pC),g=Math.min.apply(null,h.map(y=>y[0]));if(Math.min.apply(null,h.map(y=>y[0]+y[1]))-g<=m._bufferSize){const{data:y}=yield m.request(m.url,{range:{from:g,to:g+m._bufferSize},responseType:"array-buffer",signal:u});s=y,i=g,p.forEach(x=>(0,ye.Dq)(s,t,x,i))}}if(d.ifd?.has("GEOKEYDIRECTORY")){const h=d.ifd.get("GEOKEYDIRECTORY"),g=h?.values;if(g&&g.length>4){const y=g[0]+"."+g[1]+"."+g[2],x=yield m._readIFD(s,t,h.valueOffset+6-i,i,Je.Z.GEO_KEYS,2,u);h.data=x.ifd,h.data&&h.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[y]})}}return d}return d.requiredBufferSize&&d.requiredBufferSize!==s.byteLength?(s=(yield m.request(m.url,{range:{from:i,to:i+d.requiredBufferSize+4},responseType:"array-buffer",signal:u})).data).byteLength<d.requiredBufferSize?null:m._readIFD(s,t,0,i,Je.Z.TIFF_TAGS,4,u):void 0})()}_fetchRawTiffTile(s,t,c,i,a={}){var f=this;return(0,D.Z)(function*(){const u=f._getTileLocation(s,t,c,i);if(!u)return null;const{ranges:m,actualTileWidth:d,actualTileHeight:p,ifd:h}=u,g=m.map(O=>f.request(f.url,{range:O,responseType:"array-buffer",signal:a.signal})),y=yield Promise.all(g),x=y.map(O=>O.data.byteLength).reduce((O,k)=>O+k),v=1===y.length?y[0].data:new ArrayBuffer(x),R=[0],b=[0];if(y.length>1){const O=new Uint8Array(v);for(let k=0,H=0;k<y.length;k++){const P=y[k].data;O.set(new Uint8Array(P),H),R[k]=H,H+=P.byteLength,b[k]=P.byteLength}}const{blockWidth:I,blockHeight:C}=f.getBlockWidthHeight(s),F=yield f.decodePixelBlock(v,{format:"tiff",customOptions:{headerInfo:f._headerInfo,ifd:h,offsets:R,sizes:b},width:I,height:C,planes:null,pixelType:null});if(null==F)return null;let Z,B,E;if(d!==I||p!==C){let O=F.mask;if(O)for(Z=0;Z<C;Z++)if(E=Z*I,Z<p)for(B=d;B<I;B++)O[E+B]=0;else for(B=0;B<I;B++)O[E+B]=0;else for(O=new Uint8Array(I*C),F.mask=O,Z=0;Z<p;Z++)for(E=Z*I,B=0;B<d;B++)O[E+B]=1}return F})()}_getTileLocation(s,t,c,i=!1){const{firstPyramidLevel:a,blockBoundary:f}=this.rasterInfo.storageInfo,u=0===s?0:s-(a-1),{_headerInfo:m}=this;if(!m)return null;const d=i?m.maskIFDs[u]:0===u?m?.ifds[0]:m?.pyramidIFDs[u-1];if(!d)return null;const p=(0,ye.If)(d,m),h=Xe(d,"TILEOFFSETS");if(void 0===h)return null;const g=Xe(d,"TILEBYTECOUNTS"),{minRow:y,minCol:x,maxRow:v,maxCol:R}=f[u];if(t>v||c>R||t<y||c<x)return null;const b=ke(d,"IMAGEWIDTH"),I=ke(d,"IMAGELENGTH"),C=ke(d,"TILEWIDTH"),F=ke(d,"TILELENGTH"),Z=p?this.rasterInfo.bandCount:1,B=Z*t*(R+1)+c,E=[{from:h[B],to:h[B+Z-1]+g[B+Z-1]-1}];if(p){let H=!0;for(let P=0;P<Z;P++)if(h[B+P]+g[B+P]!==h[B+P+1]){H=!1;break}if(!H)for(let P=0;P<Z;P++)E[P]={from:h[B+P],to:h[B+P]+g[B+P]-1}}return null==h[B]||null==g[B]?null:{ranges:E,ifd:d,actualTileWidth:c===R&&b%C||C,actualTileHeight:t===v&&I%F||F}}_fetchAuxiliaryMetaData(s){var t=this;return(0,D.Z)(function*(){try{const{data:c}=yield t.request(t.url+".aux.xml",{responseType:"xml",signal:s?.signal});return Ye(c)}catch{return null}})()}_fetchAuxiliaryTable(s){var t=this;return(0,D.Z)(function*(){try{const{data:c}=yield t.request(t.url+".vat.dbf",{responseType:"array-buffer",signal:s?.signal}),i=ct.parse(c);return i?.recordSet?ft.Z.fromJSON(i.recordSet):null}catch{return null}})()}};(0,T._)([(0,M.Cb)()],ge.prototype,"_files",void 0),(0,T._)([(0,M.Cb)()],ge.prototype,"_headerInfo",void 0),(0,T._)([(0,M.Cb)()],ge.prototype,"_bufferSize",void 0),(0,T._)([(0,M.Cb)({type:String,json:{write:!0}})],ge.prototype,"datasetFormat",void 0),ge=(0,T._)([(0,ie.j)("esri.layers.support.rasterDatasets.TIFFRaster")],ge);const sr=ge,K=new Map;K.set("CRF",{desc:"Cloud Raster Format",constructor:Ut}),K.set("MRF",{desc:"Meta Raster Format",constructor:ir}),K.set("TIFF",{desc:"GeoTIFF",constructor:sr}),K.set("RasterTileServer",{desc:"Raster Tile Server",constructor:tr}),K.set("JPG",{desc:"JPG Raster Format",constructor:Ne}),K.set("PNG",{desc:"PNG Raster Format",constructor:Ne}),K.set("GIF",{desc:"GIF Raster Format",constructor:Ne}),K.set("BMP",{desc:"BMP Raster Format",constructor:Ne});class ar{static get supportedFormats(){const t=new Set;return K.forEach((c,i)=>t.add(i)),t}static open(t){var c=this;return(0,D.Z)(function*(){const{url:i,ioConfig:a,sourceJSON:f}=t;let u=t.datasetFormat;null==u&&i.lastIndexOf(".")&&(u=i.slice(i.lastIndexOf(".")+1).toUpperCase()),"OVR"===u||"TIF"===u?u="TIFF":"JPG"!==u&&"JPEG"!==u&&"JFIF"!==u||(u="JPG"),i.toLowerCase().includes("/imageserver")&&!i.toLowerCase().includes("/wcsserver")&&(u="RasterTileServer");const m={url:i,sourceJSON:f,datasetFormat:u,ioConfig:a??{bandIds:null,sampling:null}};let d,p;if(u&&c.supportedFormats.has(u)){if("CRF"===u&&!a?.enableCRF)throw new J.Z("rasterfactory:open",`cannot open raster: ${i}`);return d=K.get(u).constructor,p=new d(m),yield p.open({signal:t.signal}),p}if(u)throw new J.Z("rasterfactory:open","not a supported format "+u);const h=Array.from(K.keys());let g=0;const y=()=>(u=h[g++],u&&("CRF"!==u||a?.enableCRF)?(d=K.get(u).constructor,p=new d(m),p.open({signal:t.signal}).then(()=>p).catch(()=>y())):null);return y()})()}static register(t,c,i){K.has(t.toUpperCase())||K.set(t.toUpperCase(),{desc:c,constructor:i})}}var or=w(49430);let A=class extends((0,bt.h)((0,Wt.M)((0,Ht.q)((0,Nt.I)((0,Rt.N)(Et((0,Lt.n)((0,vt.Y)((0,Jt.Q)((0,ht.R)(It.Z))))))))))){constructor(...s){super(...s),this._primaryRasters=null,this.bandIds=null,this.interpolation=null,this.legendEnabled=!0,this.isReference=null,this.listMode="show",this.sourceJSON=null,this.version=null,this.type="imagery-tile",this.operationalLayerType="ArcGISTiledImageServiceLayer",this.popupEnabled=!0,this.popupTemplate=null,this.fields=null}normalizeCtorArgs(s,t){return"string"==typeof s?{url:s,...t}:s}load(s){const t=(0,S.pC)(s)?s.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Image Service"]},s).catch(Re.r9).then(()=>this._openRaster(t))),Promise.resolve(this)}get defaultPopupTemplate(){return this.createPopupTemplate()}get rasterFields(){let s=[new Te.Z({name:"Raster.ServicePixelValue",alias:"Pixel Value",domain:null,editable:!1,length:50,type:"string"})];const{rasterInfo:t}=this,c=t?.attributeTable,i=(0,S.pC)(c)?c.fields:null;if(i){const m=i.filter(d=>"oid"!==d.type&&"value"!==d.name.toLowerCase()).map(d=>{const p=d.clone();return p.name="Raster."+d.name,p});s=s.concat(m)}const f=t?.dataType,u=t?.multidimensionalInfo;if(("vector-magdir"===f||"vector-uv"===f)&&(0,S.pC)(u)){const m=u.variables[0].unit?.trim();s.push(new Te.Z({name:"Raster.Magnitude",alias:"Magnitude"+(m?` (${m})`:""),domain:null,editable:!1,type:"double"})),s.push(new Te.Z({name:"Raster.Direction",alias:"Direction (\xb0)",domain:null,editable:!1,type:"double"}))}return s}set renderer(s){this._set("renderer",s),this.updateRenderer()}readRenderer(s,t,c){const a=(0,Be.ij)(t&&t.layerDefinition&&t.layerDefinition.drawingInfo&&t.layerDefinition.drawingInfo.renderer,c)||void 0;if(null!=a)return a}createPopupTemplate(s){return(0,or.eZ)({fields:this.rasterFields,title:this.title},s)}generateRasterInfo(s,t){var c=this;return(0,D.Z)(function*(){if(!(s=(0,Le.TJ)(_e.Z,s)))return c._primaryRasters[0].rasterInfo;try{const i={raster:c._primaryRasters[0]};c._primaryRasters.length>1&&c._primaryRasters.forEach(u=>i[u.url]=u);const a=(0,De.Ue)(s.toJSON(),i),f=new je({rasterFunction:a});return yield f.open(t),f.rasterInfo}catch{return null}})()}write(s,t){const{raster:c}=this;return(this.loaded?"RasterTileServer"===c.datasetFormat&&("Raster"===c.tileType||"Map"===c.tileType):this.url&&/\/ImageServer(\/|\/?$)/i.test(this.url))?super.write(s,t):(t&&t.messages&&t.messages.push(new J.Z("layer:unsupported",`Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${t.origin}/${t.layerContainerType||"operational-layers"}'`,{layer:this})),null)}_openRaster(s){var t=this;return(0,D.Z)(function*(){let c=!1;if(t.raster)t.raster.rasterInfo||(yield t.raster.open()),"Function"===t.raster.datasetFormat?(c=!0,t._primaryRasters=t.raster.primaryRasters.rasters):t._primaryRasters=[t.raster],t.url=t.raster.url;else{const{rasterFunction:a}=t,f=[t.url];a&&(0,De.G8)(a.toJSON(),f);const u=yield Promise.all(f.map(d=>ar.open({url:d,sourceJSON:t.sourceJSON,ioConfig:{sampling:"closest",...t.ioConfig,customFetchParameters:t.customParameters},signal:s}))),m=u.findIndex(d=>null==d);if(m>-1)throw new J.Z("imagery-tile-layer:open",`cannot open raster: ${f[m]}`);if(t._primaryRasters=u,a){const d={raster:t._primaryRasters[0]};t._primaryRasters.length>1&&t._primaryRasters.forEach(g=>d[g.url]=g);const p=(0,De.Ue)(a.rasterFunctionDefinition??a.toJSON(),d),h=new je({rasterFunction:p});try{yield h.open(),t.raster=h}catch(g){const y=We.Z.getLogger(t.declaredClass);g instanceof J.Z&&y.error("imagery-tile-layer:open",g.message),y.warn("imagery-tile-layer:open","the raster function cannot be applied and is removed"),t._set("rasterFunction",null),t.raster=u[0]}}else t.raster=u[0]}const i=t.raster.rasterInfo;if(!i)throw new J.Z("imagery-tile-layer:load","cannot load resources on "+t.url);if(t._set("rasterInfo",c?i:t._primaryRasters[0].rasterInfo),t._set("spatialReference",i.spatialReference),t.sourceJSON=t.sourceJSON||t.raster.sourceJSON,null!=t.sourceJSON){const a="Map"===t.raster.tileType&&null!=t.sourceJSON.minLOD&&null!=t.sourceJSON.maxLOD?t.sourceJSON:{...t.sourceJSON,minScale:0,maxScale:0};t.read(a,{origin:"service"})}t.title||(t.title=t.raster.datasetName),"Map"===t.raster.tileType&&(t.popupEnabled=!1),t._configDefaultSettings(),t.addHandles((0,yt.YP)(()=>t.customParameters,a=>{t.raster&&(t.raster.ioConfig.customFetchParameters=a)}))})()}};(0,T._)([(0,M.Cb)()],A.prototype,"_primaryRasters",void 0),(0,T._)([(0,M.Cb)({type:[Le.z8],json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"0,1,2"!==this.bandIds?.join(",")}}}}})],A.prototype,"bandIds",void 0),(0,T._)([(0,M.Cb)({json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"bilinear"!==this.interpolation}}}}}),(0,gt.J)(At.c)],A.prototype,"interpolation",void 0),(0,T._)([(0,M.Cb)(Ae.rn)],A.prototype,"legendEnabled",void 0),(0,T._)([(0,M.Cb)({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],A.prototype,"isReference",void 0),(0,T._)([(0,M.Cb)({type:["show","hide"]})],A.prototype,"listMode",void 0),(0,T._)([(0,M.Cb)({json:{read:!0,write:!0}})],A.prototype,"blendMode",void 0),(0,T._)([(0,M.Cb)()],A.prototype,"sourceJSON",void 0),(0,T._)([(0,M.Cb)({readOnly:!0,json:{origins:{service:{read:{source:"currentVersion"}}}}})],A.prototype,"version",void 0),(0,T._)([(0,M.Cb)({readOnly:!0,json:{read:!1}})],A.prototype,"type",void 0),(0,T._)([(0,M.Cb)({type:["ArcGISTiledImageServiceLayer"]})],A.prototype,"operationalLayerType",void 0),(0,T._)([(0,M.Cb)({type:Boolean,value:!0,json:{read:{source:"disablePopup",reader:(s,t)=>!t.disablePopup},write:{target:"disablePopup",overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType}},writer(s,t,c){t[c]=!s}}}})],A.prototype,"popupEnabled",void 0),(0,T._)([(0,M.Cb)({type:pt.Z,json:{read:{source:"popupInfo"},write:{target:"popupInfo",overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType}}}}})],A.prototype,"popupTemplate",void 0),(0,T._)([(0,M.Cb)({readOnly:!0})],A.prototype,"defaultPopupTemplate",null),(0,T._)([(0,M.Cb)({readOnly:!0,type:[Te.Z]})],A.prototype,"fields",void 0),(0,T._)([(0,M.Cb)({readOnly:!0,type:[Te.Z]})],A.prototype,"rasterFields",null),(0,T._)([(0,M.Cb)({types:Be.dr,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||!("raster-stretch"===this.renderer?.type&&"none"===this.renderer.stretchType&&!this.renderer.useGamma)}}},origins:{"web-scene":{types:Be.FK,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:s=>({enabled:s&&"vector-field"!==s.type&&"flow"!==s.type})}}}}})],A.prototype,"renderer",null),(0,T._)([(0,xt.r)("renderer")],A.prototype,"readRenderer",null),A=(0,T._)([(0,ie.j)("esri.layers.ImageryTileLayer")],A);const lr=A}}]);