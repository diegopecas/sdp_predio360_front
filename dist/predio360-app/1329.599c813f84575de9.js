"use strict";(self.webpackChunkpredio360_app=self.webpackChunkpredio360_app||[]).push([[1329],{50017:(K,j,V)=>{V.d(j,{Y6:()=>I});var R,g,X=V(95470),T=V(15331),U=V(79800),P=V(29302),B=V(63657),O=V(1503),Z=V(72642);(g=R||(R={}))[g.Z=0]="Z",g[g.M=1]="M";class k{constructor(h){this.spatialReference=h}createVector(){return this._tag((0,T.Ue)())}pointToVector(h){return this._tag((0,T.al)(h.x,h.y))}arrayToVector(h){return this._tag((0,T.al)(h[0],h[1]))}vectorToArray(h){return[h[0],h[1]]}pointToArray(h){return[h.x,h.y]}vectorToPoint(h,c=new Z.Z){return c.x=h[0],c.y=h[1],c.z=void 0,c.m=void 0,c.spatialReference=this.spatialReference,c}arrayToPoint(h,c=new Z.Z){return c.x=h[0],c.y=h[1],c.z=void 0,c.m=void 0,c.spatialReference=this.spatialReference,c}vectorToDehydratedPoint(h,c){if(h)return c??={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"},c.x=h[0],c.y=h[1],c.z=void 0,c.m=void 0,c.hasZ=!1,c.hasM=!1,c.spatialReference=this.spatialReference,c}lerp(h,c,_,f){return(0,X.t7)(f,h,c,_)}addDelta(h,c,_){h[0]+=c,h[1]+=_}distance(h,c){return(0,X.TE)(h,c)}getZ(h,c){return c}hasZ(){return!1}getM(h,c){return c}hasM(){return!1}clone(h){return this._tag((0,T.nI)(h))}copy(h,c){return(0,X.JG)(c,h)}fromXYZ(h){return this._tag((0,T.al)(h[0],h[1]))}toXYZ(h,c=(0,P.Ue)()){return(0,U.s)(c,h[0],h[1],0)}pointToXYZ(h,c=(0,P.Ue)()){return(0,U.s)(c,h.x,h.y,0)}equals(h,c){return(0,X.fS)(h,c)}_tag(h){return h}}class G{constructor(h,c){this._valueType=h,this.spatialReference=c}createVector(){return this._tag((0,P.Ue)())}pointToVector(h){return this._tag((0,P.al)(h.x,h.y,this._valueType===R.Z?h.z:h.m))}arrayToVector(h){return this._tag((0,P.al)(h[0],h[1],h[2]||0))}vectorToArray(h){return[h[0],h[1],h[2]]}pointToArray(h){return this._valueType===R.Z?[h.x,h.y,h.z]:[h.x,h.y,h.m]}vectorToPoint(h,c=new Z.Z){return c.x=h[0],c.y=h[1],c.z=this._valueType===R.Z?h[2]:void 0,c.m=this._valueType===R.M?h[2]:void 0,c.spatialReference=this.spatialReference,c}arrayToPoint(h,c=new Z.Z){return c.x=h[0],c.y=h[1],c.z=this._valueType===R.Z?h[2]:void 0,c.m=this._valueType===R.M?h[2]:void 0,c.spatialReference=this.spatialReference,c}vectorToDehydratedPoint(h,c){if(!h)return;c??={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"};const _=this._valueType===R.Z,f=this._valueType===R.M;return c.x=h[0],c.y=h[1],c.z=_?h[2]:void 0,c.m=f?h[2]:void 0,c.hasZ=_,c.hasM=f,c.spatialReference=this.spatialReference,c}lerp(h,c,_,f){return(0,U.m)(f,h,c,_)}addDelta(h,c,_,f){h[0]+=c,h[1]+=_,this._valueType===R.Z&&(h[2]+=f)}distance(h,c){return this._valueType===R.Z?(0,U.q)(h,c):(0,X.TE)(h,c)}getZ(h,c){return this._valueType===R.Z?h[2]:c}hasZ(){return this._valueType===R.Z}getM(h,c){return this._valueType===R.M?h[2]:c}hasM(){return this._valueType===R.M}clone(h){return this._tag((0,P.nI)(h))}copy(h,c){return(0,U.c)(c,h)}fromXYZ(h,c=0,_=0){return this._tag((0,P.al)(h[0],h[1],this._valueType===R.Z?h.length>2?h[2]:c:_))}toXYZ(h,c=(0,P.Ue)()){return(0,U.s)(c,h[0],h[1],this._valueType===R.Z?h[2]:0)}pointToXYZ(h,c=(0,P.Ue)()){return(0,U.s)(c,h.x,h.y,this._valueType===R.Z?h.z??0:0)}equals(h,c){return(0,U.G)(h,c)}_tag(h){return h}}class z{constructor(h){this.spatialReference=h}createVector(){return this._tag((0,O.Ue)())}pointToVector(h){return this._tag((0,O.al)(h.x,h.y,h.z,h.m))}arrayToVector(h){return this._tag((0,O.al)(h[0],h[1],h[2]||0,h[3]||0))}vectorToArray(h){return[h[0],h[1],h[2],h[3]]}pointToArray(h){return[h.x,h.y,h.z,h.m]}vectorToPoint(h,c=new Z.Z){return c.x=h[0],c.y=h[1],c.z=h[2],c.m=h[3],c.spatialReference=this.spatialReference,c}arrayToPoint(h,c=new Z.Z){return c.x=h[0],c.y=h[1],c.z=h[2],c.m=h[3],c.spatialReference=this.spatialReference,c}vectorToDehydratedPoint(h,c){if(h)return c??={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"},c.x=h[0],c.y=h[1],c.z=h[2],c.m=h[3],c.hasZ=!0,c.hasM=!0,c.spatialReference=this.spatialReference,c}lerp(h,c,_,f){return(0,B.l)(f,h,c,_)}addDelta(h,c,_,f){h[0]+=c,h[1]+=_,h[2]+=f}distance(h,c){return(0,U.q)(h,c)}getZ(h){return h[2]}hasZ(){return!0}getM(h){return h[3]}hasM(){return!0}clone(h){return this._tag((0,O.nI)(h))}copy(h,c){return(0,B.c)(c,h)}fromXYZ(h,c=0,_=0){return this._tag((0,O.al)(h[0],h[1],h.length>2?h[2]:c,_))}toXYZ(h,c=(0,P.Ue)()){return(0,U.s)(c,h[0],h[1],h[2])}pointToXYZ(h,c=(0,P.Ue)()){return(0,U.s)(c,h.x,h.y,h.z??0)}equals(h,c){return(0,B.e)(h,c)}_tag(h){return h}}function I(g,h,c){return g&&h?new z(c):h?new G(R.M,c):g?new G(R.Z,c):new k(c)}},466:(K,j,V)=>{V.d(j,{wA:()=>H,kS:()=>z,XE:()=>b,Xz:()=>G});var X=V(85931),T=V(61885),U=V(37118),P=V(55214),B=V(50017),O=V(37053),Z=V(59617);class G{constructor(g){this.component=g,this.leftEdge=null,this.rightEdge=null,this.type="vertex",this.index=null}get pos(){return this._pos}set pos(g){this._pos=g,this.component.unnormalizeVertexPositions()}}class z{constructor(g,h,c){this.component=g,this.leftVertex=h,this.rightVertex=c,this.type="edge",h.rightEdge=this,c.leftEdge=this}}class H{constructor(g,h){this._spatialReference=g,this._viewingMode=h,this.vertices=[],this.edges=[],this.index=null}unnormalizeVertexPositions(){this.vertices.length<=1||function R(I,g){if(!g.supported)return;let h=1/0,c=-1/0;const _=g.upperBoundX-g.lowerBoundX;I.forEach(p=>{let m=p.pos[0];for(;m<g.lowerBoundX;)m+=_;for(;m>g.upperBoundX;)m-=_;h=Math.min(h,m),c=Math.max(c,m),p.pos[0]=m});const f=c-h;_-f<f&&I.forEach(p=>{p.pos[0]<0&&(p.pos[0]+=_)})}(this.vertices,function k(I,g){const h=(0,O.C5)(I);return g===Z.JY.Global&&h?{supported:!0,lowerBoundX:h.valid[0],upperBoundX:h.valid[1]}:{supported:!1,lowerBoundX:null,upperBoundX:null}}(this._spatialReference,this._viewingMode))}updateVertexIndex(g,h){if(0===this.vertices.length)return;const c=this.vertices[0];let _=null,f=g,p=h;do{_=f,_.index=p++,f=_.rightEdge?_.rightEdge.rightVertex:null}while(null!=f&&f!==c);_.leftEdge&&_!==this.vertices[this.vertices.length-1]&&this.swapVertices(this.vertices.indexOf(_),this.vertices.length-1)}getFirstVertex(){return this.vertices.at(0)}getLastVertex(){return this.vertices.at(-1)}isClosed(){return this.vertices.length>2&&null!==this.vertices[0].leftEdge}swapVertices(g,h){const c=this.vertices[g];this.vertices[g]=this.vertices[h],this.vertices[h]=c}iterateVertices(g){if(0===this.vertices.length)return;const h=this.vertices[0];let c=h;do{g(c,c.index),c=null!=c.rightEdge?c.rightEdge.rightVertex:null}while(c!==h&&null!=c)}}class b extends T.Z{constructor(g,h){super(),this.type=g,this.coordinateHelper=h,this._geometry=null,this._dirty=!0,this.components=[]}get geometry(){if(this._dirty){switch(this.type){case"point":this._geometry=this._toPoint();break;case"polyline":this._geometry=this._toPolyline();break;case"polygon":this._geometry=this._toPolygon()}this._dirty=!1}return this._geometry}get spatialReference(){return this.coordinateHelper.spatialReference}notifyChanges(g){this._dirty=!0,this.emit("change",g)}_toPoint(){return 0===this.components.length||0===this.components[0].vertices.length?null:this.coordinateHelper.vectorToPoint(this.components[0].vertices[0].pos)}_toPolyline(){const g=[],h=this.coordinateHelper.vectorToArray;for(const c of this.components){if(c.vertices.length<1)continue;const _=[];let f=c.vertices.find(m=>null==m.leftEdge);const p=f;do{_.push(h(f.pos)),f=f.rightEdge?f.rightEdge.rightVertex:null}while(f&&f!==p);g.push(_)}return new P.Z({paths:g,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}_toPolygon(){const g=[],h=this.coordinateHelper.vectorToArray;for(const c of this.components){if(c.vertices.length<1)continue;const _=[],f=c.vertices[0];let p=f;const m=p;do{_.push(h(p.pos)),p=null!=p.rightEdge?p.rightEdge.rightVertex:null}while(p&&p!==m);c.isClosed()&&_.push(h(f.pos)),g.push(_)}return new U.Z({rings:g,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}static fromGeometry(g,h){const c=g.spatialReference,_=(0,B.Y6)(g.hasZ,g.hasM,c),f=new b(g.type,_);switch(g.type){case"polygon":{const p=g.rings;for(let m=0;m<p.length;++m){const y=p[m],E=new H(c,h);E.index=m;const C=y.length>2&&(0,X.fS)(y[0],y[y.length-1]),N=C?y.length-1:y.length;for(let M=0;M<N;++M){const S=_.arrayToVector(y[M]),w=new G(E);E.vertices.push(w),w.pos=S,w.index=M}const A=E.vertices.length-1;for(let M=0;M<A;++M){const Y=new z(E,E.vertices[M],E.vertices[M+1]);E.edges.push(Y)}if(C){const M=new z(E,E.vertices[E.vertices.length-1],E.vertices[0]);E.edges.push(M)}f.components.push(E)}break}case"polyline":{const p=g.paths;for(let m=0;m<p.length;++m){const y=p[m],E=new H(c,h);E.index=m;const C=y.length;for(let A=0;A<C;++A){const M=_.arrayToVector(y[A]),S=new G(E);E.vertices.push(S),S.pos=M,S.index=A}const N=E.vertices.length-1;for(let A=0;A<N;++A){const w=new z(E,E.vertices[A],E.vertices[A+1]);E.edges.push(w)}f.components.push(E)}break}case"point":{const p=new H(c,h);p.index=0;const m=new G(p);m.index=0,m.pos=_.pointToVector(g),p.vertices.push(m),f.components.push(p);break}}return f}}},97737:(K,j,V)=>{V.d(j,{c:()=>Y});var P,D,Z,X=V(61885),T=V(54024),U=V(466);(D=P||(P={}))[D.NEW_STEP=0]="NEW_STEP",D[D.ACCUMULATE_STEPS=1]="ACCUMULATE_STEPS";class B{constructor(s,l,d){this._editGeometry=s,this._component=l,this._pos=d,this._addedVertex=null,this._originalEdge=null,this._left=null,this._right=null}apply(){let s="redo";null==this._addedVertex&&(s="apply",this._addedVertex=new U.Xz(this._component));const l=this._component.getLastVertex();if(null==l)this._component.vertices.push(this._addedVertex),this._addedVertex.pos=this._pos,this._addedVertex.index=0;else{let d=null;l.rightEdge&&(this._originalEdge=l.rightEdge,d=this._originalEdge.rightVertex,this._component.edges.splice(this._component.edges.indexOf(this._originalEdge),1)),this._component.vertices.push(this._addedVertex),this._addedVertex.pos=this._pos,null==this._left&&(this._left=new U.kS(this._component,l,this._addedVertex)),this._component.edges.push(this._left),l.rightEdge=this._left,null!=this._originalEdge&&null!=d&&(null==this._right&&(this._right=new U.kS(this._component,this._addedVertex,d)),this._component.edges.push(this._right),d.leftEdge=this._right),this._component.updateVertexIndex(this._addedVertex,l.index+1)}this._editGeometry.notifyChanges({operation:s,addedVertices:[this._addedVertex]})}undo(){null!=this._addedVertex&&(this._component.vertices.splice(this._component.vertices.indexOf(this._addedVertex),1),null!=this._left&&(this._component.edges.splice(this._component.edges.indexOf(this._left),1),this._left.leftVertex.rightEdge=null),null!=this._right&&(this._component.edges.splice(this._component.edges.indexOf(this._right),1),this._right.rightVertex.leftEdge=null),null!=this._originalEdge&&(this._component.edges.push(this._originalEdge),this._originalEdge.leftVertex.rightEdge=this._originalEdge,this._originalEdge.rightVertex.leftEdge=this._originalEdge),null!=this._left?this._component.updateVertexIndex(this._left.leftVertex,this._left.leftVertex.index):this._component.updateVertexIndex(this._addedVertex,0),this._editGeometry.notifyChanges({operation:"undo",removedVertices:[this._addedVertex]}))}accumulate(){return!1}}class O{constructor(s,l,d){this._editGeometry=s,this._vertices=l,this.operation=d,this._undone=!1}apply(){this._vertices.forEach(s=>this.operation.apply(s)),this._editGeometry.components.forEach(s=>s.unnormalizeVertexPositions()),this._editGeometry.notifyChanges({operation:this._undone?"redo":"apply",updatedVertices:this._vertices})}undo(){this._vertices.forEach(s=>this.operation.undo(s)),this._editGeometry.notifyChanges({operation:"undo",updatedVertices:this._vertices}),this._undone=!0}canAccumulate(s){if(this._undone||s._vertices.length!==this._vertices.length)return!1;for(let l=0;l<s._vertices.length;++l)if(s._vertices[l]!==this._vertices[l])return!1;return this.operation.canAccumulate(s.operation)}accumulate(s){return!!(s instanceof O&&this.canAccumulate(s))&&(this._vertices.forEach(l=>this.operation.accumulate(l,s.operation)),this.operation.accumulateParams(s.operation),this._editGeometry.components.forEach(l=>l.unnormalizeVertexPositions()),this._editGeometry.notifyChanges({operation:"apply",updatedVertices:this._vertices}),!0)}}!function(D){D[D.CUMULATIVE=0]="CUMULATIVE",D[D.REPLACE=1]="REPLACE"}(Z||(Z={}));class R{constructor(s,l,d=0){this._editGeometry=s,this._vertices=l,this._minNumberOfVertices=d,this.removedVertices=null}apply(){let s="redo";if(null==this.removedVertices){const l=this.removedVertices=[];this._vertices.forEach(d=>{const x=this._removeVertex(d);null!=x&&l.push(x)}),s="apply"}else this.removedVertices.forEach(l=>{this._removeVertex(l.removedVertex)});this._editGeometry.notifyChanges({operation:s,removedVertices:this._vertices})}undo(){this.removedVertices?.forEach(s=>{this._undoRemoveVertex(s)}),this._editGeometry.notifyChanges({operation:"undo",addedVertices:this._vertices})}accumulate(){return!1}_removeVertex(s){const l=s.component;if(l.vertices.length<=this._minNumberOfVertices)return null;const d={removedVertex:s,createdEdge:null},x=s.leftEdge,v=s.rightEdge;return l.vertices.splice(l.vertices.indexOf(s),1),x&&(l.edges.splice(l.edges.indexOf(x),1),x.leftVertex.rightEdge=null),v&&(l.edges.splice(l.edges.indexOf(v),1),v.rightVertex.leftEdge=null),0===s.index&&v&&this._vertices.length>0&&l.swapVertices(l.vertices.indexOf(v.rightVertex),0),x&&v&&(d.createdEdge=new U.kS(l,x.leftVertex,v.rightVertex),l.edges.push(d.createdEdge)),v&&l.updateVertexIndex(v.rightVertex,v.rightVertex.index-1),d}_undoRemoveVertex(s){const l=s.removedVertex,d=s.removedVertex.component,x=l.leftEdge,v=l.rightEdge;s.createdEdge&&d.edges.splice(d.edges.indexOf(s.createdEdge),1),d.vertices.push(l),x&&(d.edges.push(x),x.leftVertex.rightEdge=x),v&&(d.edges.push(v),v.rightVertex.leftEdge=v),d.updateVertexIndex(l,l.index)}}class k{constructor(s,l,d){this._editGeometry=s,this._edge=l,this._t=d,this.createdVertex=null,this._left=null,this._right=null}apply(){let s="redo";const l=this._edge,d=l.component,x=l.leftVertex,v=l.rightVertex;d.edges.splice(d.edges.indexOf(l),1),null==this.createdVertex&&(s="apply",this.createdVertex=new U.Xz(l.component)),d.vertices.push(this.createdVertex),this.createdVertex.pos=this._editGeometry.coordinateHelper.lerp(l.leftVertex.pos,l.rightVertex.pos,this._t,this._editGeometry.coordinateHelper.createVector()),null==this._left&&(this._left=new U.kS(d,x,this.createdVertex)),this._left.leftVertex.leftEdge?d.edges.push(this._left):d.edges.unshift(this._left),x.rightEdge=this._left,null==this._right&&(this._right=new U.kS(d,this.createdVertex,v)),d.edges.push(this._right),v.leftEdge=this._right,d.updateVertexIndex(this.createdVertex,x.index+1),this._editGeometry.notifyChanges({operation:s,addedVertices:[this.createdVertex]})}undo(){if(null==this.createdVertex||null==this._left||null==this._right)return null;const s=this._edge,l=s.component,v=this.createdVertex.leftEdge?.leftVertex,L=this.createdVertex.rightEdge?.rightVertex;l.vertices.splice(l.vertices.indexOf(this.createdVertex),1),l.edges.splice(l.edges.indexOf(this._left),1),l.edges.splice(l.edges.indexOf(this._right),1),this._edge.leftVertex.leftEdge?l.edges.push(this._edge):l.edges.unshift(this._edge),v&&(v.rightEdge=s),L&&(L.leftEdge=s),v&&l.updateVertexIndex(v,v.index),this._editGeometry.notifyChanges({operation:"undo",removedVertices:[this.createdVertex]})}accumulate(){return!1}}class G{constructor(s,l,d){this._editGeometry=s,this._vertex=l,this._pos=d}apply(){const s=null==this._originalPosition;s&&(this._originalPosition=this._vertex.pos),this._apply(s?"apply":"redo")}undo(){this._vertex.pos=this._originalPosition,this._editGeometry.notifyChanges({operation:"undo",updatedVertices:[this._vertex]})}accumulate(s){return s instanceof G&&s._vertex===this._vertex&&(this._pos=s._pos,this._apply("apply"),!0)}_apply(s){this._vertex.pos=this._pos,this._editGeometry.components.forEach(l=>l.unnormalizeVertexPositions()),this._editGeometry.notifyChanges({operation:s,updatedVertices:[this._vertex]})}}var z=V(85931);class H{constructor(s,l){this._editGeometry=s,this._component=l,this._createdEdge=null}apply(){let s="redo";if(null==this._createdEdge){s="apply";const l=this._component.getFirstVertex(),d=this._component.getLastVertex();if(this._component.isClosed()||this._component.vertices.length<3||null==l||null==d)return;this._createdEdge=new U.kS(this._component,d,l)}this._createdEdge.leftVertex.rightEdge=this._createdEdge,this._createdEdge.rightVertex.leftEdge=this._createdEdge,this._component.edges.push(this._createdEdge),this._editGeometry.notifyChanges({operation:s})}undo(){null!=this._createdEdge&&((0,z.Od)(this._component.edges,this._createdEdge),this._createdEdge.leftVertex.rightEdge=null,this._createdEdge.rightVertex.leftEdge=null,this._editGeometry.notifyChanges({operation:"undo"}))}accumulate(){return!1}}class b{constructor(s,l,d,x){this._helper=s,this.dx=l,this.dy=d,this.dz=x}_move(s,l,d,x){this._helper.addDelta(s.pos,l,d,x)}apply(s){this._move(s,this.dx,this.dy,this.dz)}undo(s){this._move(s,-this.dx,-this.dy,-this.dz)}canAccumulate(s){return s instanceof b}accumulate(s,l){this._move(s,l.dx,l.dy,l.dz)}accumulateParams(s){this.dx+=s.dx,this.dy+=s.dy,this.dz+=s.dz}}var I=V(21286),g=V(95470),h=V(15331),c=V(79800),_=V(29302),f=V(90014),p=V(34054),m=V(396);class y{get plane(){return this._plane}get requiresSplitEdgeLeft(){return!this._left.isOriginalDirection}get requiresSplitEdgeRight(){return!this._right.isOriginalDirection}get edgeDirection(){return this._edgeDirection}constructor(s,l,d,x=0,v=A.IMMEDIATE){this._helper=s,this._planeType=l,this._edge=d,this.distance=x,this._plane=(0,f.Ue)(),this._offsetPlane=(0,f.Ue)(),this._minDistance=-1/0,this._maxDistance=1/0,this._selectedArrow=1,v===A.IMMEDIATE&&this._initialize()}_initialize(){this._initializeNeighbors(),this._initializePlane(),this._initializeDistanceConstraints()}_initializeNeighbors(){const s=this._toXYZ(this._edge.leftVertex.pos),l=this._toXYZ(this._edge.leftVertex.leftEdge?.leftVertex?.pos),d=this._toXYZ(this._edge.rightVertex.pos),x=this._toXYZ(this._edge.rightVertex.rightEdge?.rightVertex?.pos);this._edgeDirection=(0,c.E)((0,_.Ue)(),s,d),l?(this._left=this._computeNeighbor(s,l,this._edgeDirection),this._right=this._computeNeighbor(d,x,this._edgeDirection,this._left)):(this._right=this._computeNeighbor(d,x,this._edgeDirection),this._left=this._computeNeighbor(s,l,this._edgeDirection,this._right))}_toXYZ(s){return null!=s?this._helper.toXYZ(s):null}_pointToXYZ(s){return this._toXYZ(this._helper.pointToVector(s))}_computeNeighbor(s,l,d,x){const v=(0,_.Ue)();if(l){(0,c.E)(v,s,l);const L=!this._passesBisectingAngleThreshold(v,d);return{start:s,end:l,direction:L?this._bisectVectorsPerpendicular(d,v):v,isOriginalDirection:!L}}return this._helper.hasZ()?x&&((0,c.b)(v,d,x.direction),(0,c.b)(v,v,d),(0,c.n)(v,v),Math.sign(v[1])!==Math.sign(d[0])&&(0,c.h)(v,v,-1)):(0,c.s)(v,-d[1],d[0],0),{start:s,end:l,direction:v,isOriginalDirection:!0}}_passesBisectingAngleThreshold(s,l){const d=Math.abs((0,p.EU)(l,s));return d>=E&&d<=Math.PI-E}_bisectVectorsPerpendicular(s,l){const d=(0,c.k)(s,l)<0?s:(0,c.F)((0,_.Ue)(),s),x=Math.abs((0,c.k)(d,l));if(!(x<C||x>1-C))return this._bisectDirection(d,l);const v=(0,c.b)((0,_.Ue)(),d,[0,0,1]);return(0,c.n)(v,v)}_bisectDirection(s,l){const d=(0,c.g)((0,_.Ue)(),s,l);return(0,c.n)(d,d)}_initializePlane(){const s=this._computeNormalDirection(this._left),l=this._computeNormalDirection(this._right);(0,c.k)(s,l)<0&&(0,c.F)(l,l),(0,f.Yq)(this._left.start,this._bisectDirection(s,l),this._plane)}_computeNormalDirection(s){const l=(0,c.b)((0,_.Ue)(),s.direction,this._edgeDirection);(0,c.n)(l,l);const d=(0,c.b)((0,_.Ue)(),this._edgeDirection,l);return this._planeType===N.XY&&(d[2]=0),(0,c.n)(d,d)}_initializeDistanceConstraints(){null==this._left.end||this.requiresSplitEdgeLeft||this._updateDistanceConstraint((0,f.jH)(this._plane,this._left.end)),null==this._right.end||this.requiresSplitEdgeRight||this._updateDistanceConstraint((0,f.jH)(this._plane,this._right.end)),this._updateIntersectDistanceConstraint(this._plane)}_updateDistanceConstraint(s){s<=0&&(this._minDistance=Math.max(this._minDistance,s)),s>=0&&(this._maxDistance=Math.min(this._maxDistance,s))}_updateIntersectDistanceConstraint(s){const l=(0,f.st)(s),d=this._edgeDirection,x=(0,c.g)((0,_.Ue)(),this._left.start,this._left.direction),v=(0,c.g)((0,_.Ue)(),this._right.start,this._right.direction),L=this._pointInBasis2D((0,h.Ue)(),l,d,this._left.start),W=this._pointInBasis2D((0,h.Ue)(),l,d,x),J=this._pointInBasis2D((0,h.Ue)(),l,d,this._right.start),Q=this._pointInBasis2D((0,h.Ue)(),l,d,v),[$]=(0,m.dU)({start:W,end:L,type:m.SP.LINE},{start:Q,end:J,type:m.SP.LINE});if(!$)return;const F=(0,g.$X)((0,h.Ue)(),L,W);(0,g.Fv)(F,F);const q=(0,g.$X)((0,h.Ue)(),$,W),ee=(0,g.AK)(F,q),te=(0,c.g)((0,_.Ue)(),x,(0,c.h)((0,_.Ue)(),this._left.direction,-ee)),ie=(0,f.jH)(s,te);this._updateDistanceConstraint(ie)}_pointInBasis2D(s,l,d,x){return s[0]=(0,p.SR)(l,x),s[1]=(0,p.SR)(d,x),s}_offset(s,l){Number.isFinite(this._minDistance)&&(l=Math.max(this._minDistance,l)),Number.isFinite(this._maxDistance)&&(l=Math.min(this._maxDistance,l)),(0,f.JG)(this._offsetPlane,this._plane),this._offsetPlane[3]-=l;const d=(v,L,W)=>null!=L&&(0,f.fn)(this._offsetPlane,v,(0,c.g)((0,_.Ue)(),v,L),W),x=(0,_.Ue)();(s===this._edge.leftVertex?d(this._left.start,this._left.direction,x):d(this._right.start,this._right.direction,x))&&this._helper.copy(this._helper.fromXYZ(x,void 0,this._helper.getM(s.pos)),s.pos)}selectArrowFromStartPoint(s){this._selectedArrow=(0,f.Ac)(this.plane,this._pointToXYZ(s))?1:-1}get selectedArrow(){return this._selectedArrow}signedDistanceToPoint(s){return(0,f.jH)(this.plane,this._pointToXYZ(s))}apply(s){this._offset(s,this.distance)}undo(s){this._offset(s,0)}canAccumulate(s){return s instanceof y&&this._edge.leftVertex.index===s._edge.leftVertex.index&&this._edge.rightVertex.index===s._edge.rightVertex.index&&this._edge.component===s._edge.component&&this._maybeEqualsVec3(this._left.direction,s._left.direction)&&this._maybeEqualsVec3(this._right.direction,s._right.direction)&&(0,c.G)((0,f.st)(this._plane),(0,f.st)(s._plane))}accumulate(s,l){this._offset(s,this._plane[3]-l._plane[3]+l.distance)}accumulateParams(s){this.distance=s.distance-s._plane[3]+this._plane[3]}clone(){const s=new y(this._helper,this._planeType,this._edge,this.distance,A.DEFERRED);return(0,f.JG)(s._plane,this._plane),(0,f.JG)(s._offsetPlane,this._offsetPlane),s._maxDistance=this._maxDistance,s._minDistance=this._minDistance,s._left=this._cloneNeighbor(this._left),s._right=this._cloneNeighbor(this._right),s._edgeDirection=(0,c.c)((0,_.Ue)(),this._edgeDirection),s}_maybeEqualsVec3(s,l){return null==s&&null==l||null!=s&&null!=l&&(0,c.G)(s,l)}_cloneNeighbor({start:s,end:l,direction:d,isOriginalDirection:x}){return{start:(0,c.c)((0,_.Ue)(),s),end:null!=l?(0,c.c)((0,_.Ue)(),l):null,direction:(0,c.c)((0,_.Ue)(),d),isOriginalDirection:x}}}const E=(0,I.Vl)(15),C=.001;var N,A;(function(D){D[D.XYZ=0]="XYZ",D[D.XY=1]="XY"})(N||(N={})),function(D){D[D.IMMEDIATE=0]="IMMEDIATE",D[D.DEFERRED=1]="DEFERRED"}(A||(A={}));class M{constructor(s,l,d=Z.CUMULATIVE){this.origin=s,this.angle=l,this._accumulationType=d}_rotate(s,l){(0,g.U1)(s.pos,s.pos,this.origin,l)}apply(s){this._rotate(s,this.angle)}undo(s){this._rotate(s,-this.angle)}canAccumulate(s){return s instanceof M&&(0,z.fS)(this.origin,s.origin)}accumulate(s,l){this._rotate(s,l._accumulationType===Z.REPLACE?l.angle-this.angle:l.angle)}accumulateParams(s){this.angle=s._accumulationType===Z.REPLACE?s.angle:this.angle+s.angle}}class S{constructor(s,l,d,x,v=Z.CUMULATIVE){this.origin=s,this.axis1=l,this.factor1=d,this.factor2=x,this._accumulationType=v,this.axis2=(0,h.al)(l[1],-l[0])}_scale(s,l,d){(0,g.LG)(s.pos,s.pos,this.origin,this.axis1,l),(0,g.LG)(s.pos,s.pos,this.origin,this.axis2,d)}apply(s){this._scale(s,this.factor1,this.factor2)}undo(s){this._scale(s,1/this.factor1,1/this.factor2)}canAccumulate(s){return s instanceof S&&(0,z.fS)(this.origin,s.origin)&&(0,z.fS)(this.axis1,s.axis1)}accumulate(s,l){l._accumulationType===Z.REPLACE?this._scale(s,l.factor1/this.factor1,l.factor2/this.factor2):this._scale(s,l.factor1,l.factor2)}accumulateParams(s){const l=s._accumulationType===Z.REPLACE;this.factor1=l?s.factor1:this.factor1*s.factor1,this.factor2=l?s.factor2:this.factor2*s.factor2}}class w{constructor(){this._operations=[],this._closed=!1}close(){this._closed=!0}apply(){for(const s of this._operations)s.apply()}undo(){for(let s=this._operations.length-1;s>=0;s--)this._operations[s].undo()}accumulate(s){if(this._closed)return!1;const l=this._operations.length?this._operations[this._operations.length-1]:null;return l&&l.accumulate(s)||(this._operations.push(s),s.apply()),!0}}class Y extends X.Z{constructor(s){super(),this.data=s,this._undoStack=[],this._redoStack=[],this._listener=this.data.on("change",l=>{l.addedVertices&&this.emit("vertex-add",{type:"vertex-add",vertices:l.addedVertices,operation:l.operation}),l.removedVertices&&this.emit("vertex-remove",{type:"vertex-remove",vertices:l.removedVertices,operation:l.operation}),l.updatedVertices&&this.emit("vertex-update",{type:"vertex-update",vertices:l.updatedVertices,operation:l.operation})})}destroy(){this._listener.remove()}splitEdge(s,l){return this._apply(new k(this.data,s,l))}updateVertices(s,l,d=P.ACCUMULATE_STEPS){return this._apply(new O(this.data,s,l),d)}moveVertices(s,l,d,x,v=P.ACCUMULATE_STEPS){return this.updateVertices(s,new b(this.data.coordinateHelper,l,d,x),v)}scaleVertices(s,l,d,x,v,L=P.ACCUMULATE_STEPS,W=Z.CUMULATIVE){return this.updateVertices(s,new S(l,d,x,v,W),L)}rotateVertices(s,l,d,x=P.ACCUMULATE_STEPS,v=Z.CUMULATIVE){return this.updateVertices(s,new M(l,d,v),x)}removeVertices(s){return this._apply(new R(this.data,s,this._minNumVerticesPerType))}appendVertex(s){return 0===this.data.components.length?null:this._apply(new B(this.data,this.data.components[0],s))}setVertexPosition(s,l){return this._apply(new G(this.data,s,l))}offsetEdge(s,l,d,x=P.ACCUMULATE_STEPS){return this.updateVertices([l.leftVertex,l.rightVertex],new y(this.data.coordinateHelper,s,l,d),x)}closeComponent(s){return this.data.components.includes(s)?this._apply(new H(this.data,s)):null}canRemoveVertex(s){return s.vertices.length>this._minNumVerticesPerType}createUndoGroup(){const s=new w;return this._apply(s),(0,T.kB)(()=>s.close())}undo(){if(this._undoStack.length>0){const s=this._undoStack.pop();return s.undo(),this._redoStack.push(s),s}return null}redo(){if(this._redoStack.length>0){const s=this._redoStack.pop();return s.apply(),this._undoStack.push(s),s}return null}get canUndo(){return this._undoStack.length>0}get canRedo(){return this._redoStack.length>0}get lastOperation(){return this._undoStack.length>0?this._undoStack[this._undoStack.length-1]:null}get _minNumVerticesPerType(){switch(this.data.type){case"point":return 1;case"polyline":return 2;case"polygon":return 3;default:return 0}}_apply(s,l=P.ACCUMULATE_STEPS){return l!==P.NEW_STEP&&null!=this.lastOperation&&this.lastOperation.accumulate(s)||(s.apply(),this._undoStack.push(s),this._redoStack=[]),s}static fromGeometry(s,l){return new Y(U.XE.fromGeometry(s,l))}}},396:(K,j,V)=>{V.d(j,{SP:()=>I,UG:()=>b,dU:()=>H,k0:()=>Z,xO:()=>k}),V(21286);var I,p,T=V(95470),U=V(15331);function P(p,m){return p[0]*m[1]-p[1]*m[0]}function Z(p,m,y,E,C=y){return(0,T.$X)(h,E,y),(0,T.$X)(_,m,C),function O(p,m,y){const E=(0,T.AK)(y,m)/(0,T.we)(y);(0,T.bA)(p,y,E)}(f,_,h),(0,T.IH)(p,C,f)}function k(p,m,y,E){(0,T.$X)(h,m,y);const C=E/(0,T.kE)(h);return(0,T.od)(p,y,h,C)}function H(p,m){const y=p.start,C=m.start,N=m.end,A=(0,T.$X)(h,p.end,y),M=(0,T.$X)(c,N,C),S=P(A,M);if(Math.abs(S)<=g)return[];const w=(0,T.$X)(_,y,C),Y=P(M,w)/S,D=P(A,w)/S;if(Y>=0){if(D>=0||m.type===I.LINE)return[(0,T.od)(f,y,A,Y)]}else if(p.type===I.LINE&&(D>=0||m.type===I.LINE))return[(0,T.od)(f,y,A,Y)];return[]}function b(p,m,y){const E=[],C=(0,T.$X)(h,p.end,p.start),N=(0,T.$X)(c,p.start,m),A=(0,T.we)(C),M=2*(0,T.AK)(C,N),S=M*M-4*A*((0,T.we)(N)-y*y);if(0===S){const w=-M/(2*A);(p.type===I.LINE||w>=0)&&E.push((0,T.od)(f,p.start,C,w))}else if(S>0){const w=Math.sqrt(S),Y=(-M+w)/(2*A);(p.type===I.LINE||Y>=0)&&E.push((0,T.od)(f,p.start,C,Y));const D=(-M-w)/(2*A);(p.type===I.LINE||D>=0)&&E.push((0,T.od)(_,p.start,C,D))}return E}(p=I||(I={}))[p.RAY=0]="RAY",p[p.LINE=1]="LINE";const g=1e-6,h=(0,U.Ue)(),c=(0,U.Ue)(),_=(0,U.Ue)(),f=(0,U.Ue)()},66601:(K,j,V)=>{V.d(j,{m:()=>U});var X=V(55915),T=V(81863);function U(P){const B=(0,T.rS)(P),O=B===T.GG?T.wY:B;return(0,X.canProjectWithoutEngine)(P,O)?O:P}}}]);