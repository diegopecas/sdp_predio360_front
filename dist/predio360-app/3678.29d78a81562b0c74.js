"use strict";(self.webpackChunkpredio360_app=self.webpackChunkpredio360_app||[]).push([[3678],{986:(Te,pe,ut)=>{ut.d(pe,{E:()=>Ut});const gt=new(ut(6879).Z);function Ut(zt){if(null==zt)return["",!1];if(!gt.hasBidiChar(zt))return[zt,!1];let oe;return oe="rtl"===gt.checkContextual(zt)?"IDNNN":"ICNNN",[gt.bidiTransform(zt,oe,"VLYSN"),!0]}},17002:(Te,pe,ut)=>{ut.d(pe,{BN:()=>At,mx:()=>oe});var Wt=ut(15861),gt=ut(59318);const Ut="woff2",zt=new Map;function oe(St){return q.apply(this,arguments)}function q(){return(q=(0,Wt.Z)(function*(St){const Xt=function Mt(St){const Xt=function Lt(St){if(!St.weight)return"";switch(St.weight.toLowerCase()){case"bold":case"bolder":return"-bold"}return""}(St)+function _t(St){if(!St.style)return"";switch(St.style.toLowerCase()){case"italic":case"oblique":return"-italic"}return""}(St);return At(St.family)+(Xt.length>0?Xt:"-regular")}(St);let Kt=zt.get(Xt);if(Kt)return Kt;const et=new FontFace(St.family,`url('${gt.Z.fontsUrl}/woff2/${Xt}.${Ut}') format('${Ut}')`),at=document.fonts;return at.has(et)&&"loading"===et.status?et.loaded:(Kt=et.load(),zt.set(Xt,Kt),at.add(et),Kt)})).apply(this,arguments)}function At(St){if(!St)return"arial-unicode-ms";const Xt=St.toLowerCase().split(" ").join("-");switch(Xt){case"serif":return"noto-serif";case"sans-serif":return"arial-unicode-ms";case"monospace":return"ubuntu-mono";case"fantasy":return"cabin-sketch";case"cursive":return"redressed";default:return Xt}}},72283:(Te,pe,ut)=>{ut.d(pe,{GP:()=>zt,QK:()=>Q,XV:()=>Et,hh:()=>at,ov:()=>et,qh:()=>jt,v1:()=>Yt,wp:()=>Kt,zY:()=>se,zv:()=>$t});var Wt=ut(58817),gt=ut(91179),Ut=ut(97373);function zt(it){const Ct=(0,Wt.d9)(it);return function Xt(it){it&&((0,gt.oU)(it)?St(it.rings):(0,gt.l9)(it)?St(it.paths):(0,gt.aW)(it)&&_t(it.points),oe(it))}(Ct),Ct}function oe(it){it&&((0,gt.wp)(it)?it.y=-it.y:(0,gt.oU)(it)?At(it.rings):(0,gt.l9)(it)?At(it.paths):(0,gt.aW)(it)&&q(it.points))}function q(it){if(it){const Ct=it.length;for(let Gt=0;Gt<Ct;Gt++)it[Gt][1]=-it[Gt][1]}}function At(it){if(it)for(const Ct of it)q(Ct)}function Mt(it){if(it)for(let Ct=it.length-1;Ct>0;--Ct)it[Ct][0]-=it[Ct-1][0],it[Ct][1]-=it[Ct-1][1]}function Lt(it){if(it)for(const Ct of it)Mt(Ct)}function _t(it){if(it){const Ct=it.length;for(let Gt=1;Gt<Ct;++Gt)it[Gt][0]+=it[Gt-1][0],it[Gt][1]+=it[Gt-1][1]}}function St(it){if(it)for(const Ct of it)_t(Ct)}function Kt(it){it&&(oe(it),(0,gt.oU)(it)?Lt(it.rings):(0,gt.l9)(it)?Lt(it.paths):(0,gt.aW)(it)&&Mt(it.points))}function et(it){if(it)for(const Ct of it)at(Ct)}function at(it){it&&it.reverse()}function Et(it,Ct,Gt){return[it[0]+(Ct[0]-it[0])*Gt,it[1]+(Ct[1]-it[1])*Gt]}function Q(it){return!(!it||0===it.length)&&it[0][0]===it[it.length-1][0]&&it[0][1]===it[it.length-1][1]}function $t(it){return it[4]}function jt(it,Ct){it[4]=Ct}class Yt{constructor(Ct,Gt,qt,Dt=0){this.isClosed=!1,this.multiPath=null,this.acceptPolygon=Gt,this.acceptPolyline=qt,this.geomUnitsPerPoint=Dt,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1,Ct&&((0,gt.oU)(Ct)?Gt&&(this.multiPath=Ct.rings,this.isClosed=!0):(0,gt.l9)(Ct)?qt&&(this.multiPath=Ct.paths,this.isClosed=!1):(0,gt.YX)(Ct)&&Gt&&(this.multiPath=he(Ct).rings,this.isClosed=!0),this.multiPath&&(this.pathCount=this.multiPath.length)),this.internalPlacement=new Ut.u}next(){if(!this.multiPath)return null;for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const Ct=this.processPath(this.multiPath[this.pathIndex]);if(Ct)return Ct}return this.pathCount=-1,this.pathIndex=-1,this.multiPath=null,null}}class se{constructor(Ct,Gt,qt,Dt=0){this.isClosed=!1,this.multiPath=null,this.inputGeometries=Ct,this.acceptPolygon=Gt,this.acceptPolyline=qt,this.geomUnitsPerPoint=Dt,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1}next(){for(;;){if(!this.multiPath){let Ct=this.inputGeometries.next();for(;Ct;){if((0,gt.oU)(Ct)?this.acceptPolygon&&(this.multiPath=Ct.rings,this.isClosed=!0):(0,gt.l9)(Ct)?this.acceptPolyline&&(this.multiPath=Ct.paths,this.isClosed=!1):(0,gt.YX)(Ct)&&this.acceptPolygon&&(this.multiPath=he(Ct).rings,this.isClosed=!0),this.multiPath){this.pathCount=this.multiPath.length,this.pathIndex=-1;break}Ct=this.inputGeometries.next()}if(!this.multiPath)return null}for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const Ct=this.processPath(this.multiPath[this.pathIndex]);if(Ct)return Ct}this.pathCount=-1,this.pathIndex=-1,this.multiPath=null}}}function he(it){return{rings:[[[it.xmin,it.ymin],[it.xmin,it.ymax],[it.xmax,it.ymax],[it.xmax,it.ymin],[it.xmin,it.ymin]]]}}},29214:(Te,pe,ut)=>{ut.d(pe,{MU:()=>oe,ib:()=>At,yn:()=>Mt}),ut(58817);var gt=ut(13160);const Ut=512;let zt;class oe{constructor(_t){this._geometry=_t}next(){const _t=this._geometry;return this._geometry=null,_t}}function At(Lt,_t){let St,Xt;zt||(zt=new gt.bN(0,0,0,1)),zt.reset(gt.Vl.Polygon),zt.setPixelMargin(_t+1),zt.setExtent(Ut);for(const et of Lt.rings)if(et&&!(et.length<3)){St=et[0][0],Xt=-et[0][1],zt.moveTo(St,Xt);for(let at=1;at<et.length;at++)St=et[at][0],Xt=-et[at][1],zt.lineTo(St,Xt);zt.close()}const Kt=zt.result(!1);if(Kt){const et=[];for(const at of Kt){const Et=[];et.push(Et);for(const Q of at)Et.push([Q.x,-Q.y])}return{rings:et}}return{rings:[]}}function Mt(Lt,_t){let St,Xt;zt||(zt=new gt.bN(0,0,0,1)),zt.reset(gt.Vl.LineString),zt.setPixelMargin(_t+1),zt.setExtent(Ut);for(const et of Lt.paths)if(et&&!(et.length<2)){St=et[0][0],Xt=-et[0][1],zt.moveTo(St,Xt);for(let at=1;at<et.length;at++)St=et[at][0],Xt=-et[at][1],zt.lineTo(St,Xt)}const Kt=zt.result(!1);if(Kt){const et=[];for(const at of Kt){const Et=[];et.push(Et);for(const Q of at)Et.push([Q.x,-Q.y])}return{paths:et}}return{paths:[]}}},95727:(Te,pe,ut)=>{ut.d(pe,{h:()=>$e,W:()=>Ke});var Wt=ut(58817),gt=ut(91179),Ut=ut(72283);let zt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new oe(i,n,M)}}return v.instance=null,v})();class oe{constructor(e,i,n){this._inputGeometries=e,this._angleTolerance=void 0!==i.angleTolerance?i.angleTolerance:120,this._maxCosAngle=Math.cos((1-Math.abs(this._angleTolerance)/180)*Math.PI)}next(){let e=this._inputGeometries.next();for(;e;){if((0,gt.oU)(e)){this._isClosed=!0;const i=(0,Wt.d9)(e);return this._processMultipath(i.rings),i}if((0,gt.l9)(e)){this._isClosed=!1;const i=(0,Wt.d9)(e);return this._processMultipath(i.paths),i}if((0,gt.YX)(e)){if(this._maxCosAngle)return e;this._isClosed=!0;const i=[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]];return this._processPath(i),{rings:[i]}}e=this._inputGeometries.next()}return null}_processMultipath(e){if(e)for(const i of e)this._processPath(i)}_processPath(e){if(e){let i,n,M,a,r,P,x=e.length,w=e[0];this._isClosed&&++x;for(let I=1;I<x;++I){let E;E=this._isClosed&&I===x-1?e[0]:e[I];const tt=E[0]-w[0],Z=E[1]-w[1],ot=Math.sqrt(tt*tt+Z*Z);I>1&&ot>0&&M>0&&(i*tt+n*Z)/ot/M<=this._maxCosAngle&&(0,Ut.qh)(w,1),1===I&&(a=tt,r=Z,P=ot),ot>0&&(w=E,i=tt,n=Z,M=ot)}this._isClosed&&M>0&&P>0&&(i*a+n*r)/P/M<=this._maxCosAngle&&(0,Ut.qh)(e[0],1)}}}var q=ut(7547);const At=.03;class Mt{constructor(){this._path=[]}path(){return this._path}addPath(e,i){i||e.reverse(),Array.prototype.push.apply(this._path,e),i||e.reverse()}static mergePath(e,i){i&&Array.prototype.push.apply(e,i)}startPath(e){this._path.push(e)}lineTo(e){this._path.push(e)}close(){const e=this._path;e.length>1&&(e[0][0]===e[e.length-1][0]&&e[0][1]===e[e.length-1][1]||e.push([e[0][0],e[0][1]]))}}class Lt{constructor(e=0,i=!1){}normalize(e){const i=Math.sqrt(e[0]*e[0]+e[1]*e[1]);0!==i&&(e[0]/=i,e[1]/=i)}calculateLength(e,i){const n=i[0]-e[0],M=i[1]-e[1];return Math.sqrt(n*n+M*M)}calculateSegLength(e,i){return this.calculateLength(e[i],e[i+1])}calculatePathLength(e){let i=0;const n=e?e.length:0;for(let M=0;M<n-1;++M)i+=this.calculateSegLength(e,M);return i}calculatePathArea(e){let i=0;const n=e?e.length:0;for(let M=0;M<n-1;++M)i+=(e[M+1][0]-e[M][0])*(e[M+1][1]+e[M][1]);return i/2}getCoord2D(e,i,n){return[e[0]+(i[0]-e[0])*n,e[1]+(i[1]-e[1])*n]}getSegCoord2D(e,i,n){return this.getCoord2D(e[i],e[i+1],n)}getAngle(e,i,n){return Math.atan2(i[1]-e[1],i[0]-e[0])}getSegAngle(e,i,n){return this.getAngle(e[i],e[i+1],n)}getAngleCS(e,i,n){const M=i[0]-e[0],a=i[1]-e[1],r=Math.sqrt(M*M+a*a);return r>0?[M/r,a/r]:[1,0]}getSegAngleCS(e,i,n){return this.getAngleCS(e[i],e[i+1],n)}cut(e,i,n,M){return[n<=0?e[i]:this.getSegCoord2D(e,i,n),M>=1?e[i+1]:this.getSegCoord2D(e,i,M)]}addSegment(e,i,n){n&&e.push(i[0]),e.push(i[1])}getSubCurve(e,i,n){const M=[];return this.appendSubCurve(M,e,i,n)?M:null}appendSubCurve(e,i,n,M){const a=i?i.length-1:0;let r=0,P=!0,x=0;for(;x<a;){const w=this.calculateSegLength(i,x);if(0!==w){if(P){if(r+w>n){let E=1,tt=!1;r+w>=M&&(E=(M-r)/w,tt=!0);const Z=this.cut(i,x,(n-r)/w,E);if(Z&&this.addSegment(e,Z,P),tt)break;P=!1}}else{if(r+w>M){const I=this.cut(i,x,0,(M-r)/w);I&&this.addSegment(e,I,P);break}this.addSegment(e,[i[x],i[x+1]],P)}r+=w,++x}else++x}return!0}getCIMPointAlong(e,i){const n=e?e.length-1:0;let M=0,a=-1;for(;a<n;){++a;const r=this.calculateSegLength(e,a);if(0!==r){if(M+r>i)return this.getCoord2D(e[a],e[a+1],(i-M)/r);M+=r}}return null}isEmpty(e,i){if(!e||e.length<=1)return!0;const n=e?e.length-1:0;let M=-1;for(;M<n;)if(++M,e[M+1][0]!==e[M][0]||e[M+1][1]!==e[M][1]||i&&e[M+1][2]!==e[M][2])return!1;return!0}offset(e,i,n,M,a){if(!e||e.length<2)return null;let r=0,P=e[r++],x=r;for(;r<e.length;){const tt=e[r];tt[0]===P[0]&&tt[1]===P[1]||(r!==x&&(e[x]=e[r]),P=e[x++]),r++}const w=e[0][0]===e[x-1][0]&&e[0][1]===e[x-1][1];if(w&&--x,x<(w?3:2))return null;const I=[];P=w?e[x-1]:null;let E=e[0];for(let tt=0;tt<x;tt++){const Z=tt===x-1?w?e[0]:null:e[tt+1];if(P)if(Z){const ot=[Z[0]-E[0],Z[1]-E[1]];this.normalize(ot);const dt=[E[0]-P[0],E[1]-P[1]];this.normalize(dt);const It=dt[0]*ot[1]-dt[1]*ot[0],Vt=dt[0]*ot[0]+dt[1]*ot[1];if(0===It&&1===Vt){E=Z;continue}if(It>=0==i<=0){if(Vt<1){const re=[ot[0]-dt[0],ot[1]-dt[1]];this.normalize(re);const ne=Math.sqrt((1+Vt)/2);if(ne>1/M){const Bt=-Math.abs(i)/ne;I.push([E[0]-re[0]*Bt,E[1]-re[1]*Bt])}}}else switch(n){case q.id.Mitered:{const re=Math.sqrt((1+Vt)/2);if(re>0&&1/re<M){const ne=[ot[0]-dt[0],ot[1]-dt[1]];this.normalize(ne);const Bt=Math.abs(i)/re;I.push([E[0]-ne[0]*Bt,E[1]-ne[1]*Bt]);break}}case q.id.Bevelled:I.push([E[0]+dt[1]*i,E[1]-dt[0]*i]),I.push([E[0]+ot[1]*i,E[1]-ot[0]*i]);break;case q.id.Rounded:if(Vt<1){I.push([E[0]+dt[1]*i,E[1]-dt[0]*i]);const re=Math.floor(2.5*(1-Vt));if(re>0){const ne=1/re;let Bt=ne;for(let xe=1;xe<re;xe++,Bt+=ne){const de=[dt[1]*(1-Bt)+ot[1]*Bt,-dt[0]*(1-Bt)-ot[0]*Bt];this.normalize(de),I.push([E[0]+de[0]*i,E[1]+de[1]*i])}}I.push([E[0]+ot[1]*i,E[1]-ot[0]*i])}break;default:if(It<0)I.push([E[0]+(dt[1]+dt[0])*i,E[1]+(dt[1]-dt[0])*i]),I.push([E[0]+(ot[1]-ot[0])*i,E[1]-(ot[0]+ot[1])*i]);else{const re=Math.sqrt((1+Math.abs(Vt))/2),ne=[ot[0]-dt[0],ot[1]-dt[1]];this.normalize(ne);const Bt=i/re;I.push([E[0]-ne[0]*Bt,E[1]-ne[1]*Bt])}}}else{const ot=[E[0]-P[0],E[1]-P[1]];this.normalize(ot),I.push([E[0]+ot[1]*i,E[1]-ot[0]*i])}else{const ot=[Z[0]-E[0],Z[1]-E[1]];this.normalize(ot),I.push([E[0]+ot[1]*i,E[1]-ot[0]*i])}P=E,E=Z}return I.length<(w?3:2)?null:(w&&I.push([I[0][0],I[0][1]]),I)}}const _t=1.7320508075688772,Xt=q.TF.OpenEnded;let Kt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new et(i,n,M)}}return v.instance=null,v})();class et extends Ut.zY{constructor(e,i,n){super(e,!1,!0),this._curveHelper=new Lt,this._width=(void 0!==i.width?i.width:5)*n,this._arrowType=void 0!==i.geometricEffectArrowType?i.geometricEffectArrowType:void 0!==i.arrowType?i.arrowType:Xt,this._offsetFlattenError=At*n}processPath(e){switch(this._arrowType){case q.TF.OpenEnded:default:return this._constructSimpleArrow(e,!0);case q.TF.Block:return this._constructSimpleArrow(e,!1);case q.TF.Crossed:return this._constructCrossedArrow(e)}}_constructSimpleArrow(e,i){const n=this._curveHelper.calculatePathLength(e);let M=this._width;n<2*M&&(M=n/2);const a=this._curveHelper.getSubCurve(e,0,n-M);if(!a)return null;const r=M/2;if(this._curveHelper.isEmpty(a,!1))return null;const P=this._constructOffset(a,-r);if(!P)return null;const x=this._constructOffset(a,r);if(!x)return null;const w=this._constructArrowBasePoint(P,-r/2);if(!w)return null;const I=this._constructArrowBasePoint(x,r/2);if(!I)return null;const E=e[e.length-1];i||(this._makeControlPoint(x,!0),this._makeControlPoint(P,!0));const tt=new Mt;return tt.addPath(x,!0),tt.lineTo(I),this._makeControlPoint(tt.path()),tt.lineTo(E),this._makeControlPoint(tt.path()),tt.lineTo(w),this._makeControlPoint(tt.path()),tt.addPath(P,!1),i?{paths:[tt.path()]}:(tt.close(),{rings:[tt.path()]})}_constructCrossedArrow(e){const i=this._curveHelper.calculatePathLength(e);let n=this._width;i<n*(1+_t+1)&&(n=i/(1+_t+1));const M=this._curveHelper.getSubCurve(e,0,i-n*(1+_t));if(!M)return null;const a=n/2;if(this._curveHelper.isEmpty(M,!1))return null;const r=this._constructOffset(M,a);if(!r)return null;const P=this._constructOffset(M,-a);if(!P)return null;const x=this._curveHelper.getSubCurve(e,0,i-n);if(!x||this._curveHelper.isEmpty(x,!1))return null;const w=this._constructOffset(x,a);if(!w)return null;const I=this._constructOffset(x,-a);if(!I)return null;const E=w[w.length-1],tt=this._constructArrowBasePoint(w,a/2);if(!tt)return null;const Z=I[I.length-1],ot=this._constructArrowBasePoint(I,-a/2);if(!ot)return null;const dt=e[e.length-1];this._makeControlPoint(r,!1),this._makeControlPoint(P,!1);const It=new Mt;return It.addPath(r,!0),this._makeControlPoint(It.path()),It.lineTo(Z),It.lineTo(ot),this._makeControlPoint(It.path()),It.lineTo(dt),this._makeControlPoint(It.path()),It.lineTo(tt),this._makeControlPoint(It.path()),It.lineTo(E),this._makeControlPoint(It.path()),It.addPath(P,!1),{paths:[It.path()]}}_constructOffset(e,i){return this._curveHelper.offset(e,i,q.id.Rounded,4,this._offsetFlattenError)}_constructArrowBasePoint(e,i){if(!e||e.length<2)return null;const n=e[e.length-2],M=e[e.length-1],a=[M[0]-n[0],M[1]-n[1]];return this._curveHelper.normalize(a),[M[0]+a[1]*i,M[1]-a[0]*i]}_makeControlPoint(e,i=!1){(0,Ut.qh)(i?e[0]:e[e.length-1],1)}}ut(29132);var Et=ut(62208),Q=ut(29214),$t=ut(65234);let jt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new Yt(i,n,M,a,r)}}return v.instance=null,v})();class Yt{constructor(e,i,n,M,a){this._inputGeometries=e,this._tileKey=M,this._geometryEngine=a,this._curveHelper=new Lt,this._size=(void 0!==i.size?i.size:1)*n,this._offsetFlattenError=At*n}next(){let e;for(;e=this._inputGeometries.next();){if(0===this._size)return e;if((0,gt.YX)(e))if(this._size>0){const a=this._curveHelper.offset([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]],this._size,q.id.Rounded,4,this._offsetFlattenError);if(a)return{rings:[a]}}else if(this._size<0&&Math.min(e.xmax-e.xmin,e.ymax-e.ymin)+2*this._size>0)return{xmin:e.xmin-this._size,xmax:e.xmax+this._size,ymin:e.ymin-this._size,ymax:e.ymax+this._size};const i=this._geometryEngine;if((0,Et.Wi)(i))return null;let n=e;if((!(0,gt.oU)(e)||!this._tileKey||(n=(0,Q.ib)(e,Math.abs(this._size)+1),n&&n.rings&&0!==n.rings.length))&&(!(0,gt.l9)(e)||!this._tileKey||(n=(0,Q.yn)(e,Math.abs(this._size)+1),n&&n.paths&&0!==n.paths.length)))return i.buffer($t.Z.WebMercator,n,this._size,1)}return null}}let se=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new he(i,n,M)}}return v.instance=null,v})();class he{constructor(e,i,n){this._defaultPointSize=20,this._inputGeometries=e,this._geomUnitsPerPoint=n,this._rule=i.rule??q.Em.FullGeometry,this._defaultSize=this._defaultPointSize*n}next(){let e;for(;e=this._inputGeometries.next();){let i;if((0,gt.wp)(e)?i=this._processGeom([[[e.x,e.y]]]):(0,gt.aW)(e)?i=this._processGeom([e.points]):(0,gt.l9)(e)?i=this._processGeom(e.paths):(0,gt.oU)(e)&&(i=this._processGeom(e.rings)),i&&i.length)return{paths:i}}return null}_clone(e){return[e[0],e[1]]}_mid(e,i){return[(e[0]+i[0])/2,(e[1]+i[1])/2]}_mix(e,i,n,M){return[e[0]*i+n[0]*M,e[1]*i+n[1]*M]}_add(e,i){return[e[0]+i[0],e[1]+i[1]]}_add2(e,i,n){return[e[0]+i,e[1]+n]}_sub(e,i){return[e[0]-i[0],e[1]-i[1]]}_dist(e,i){return Math.sqrt((e[0]-i[0])*(e[0]-i[0])+(e[1]-i[1])*(e[1]-i[1]))}_norm(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}_normalize(e,i=1){const n=i/this._norm(e);e[0]*=n,e[1]*=n}_leftPerpendicular(e){const n=e[0];e[0]=-e[1],e[1]=n}_leftPerp(e){return[-e[1],e[0]]}_rightPerpendicular(e){const n=-e[0];e[0]=e[1],e[1]=n}_rightPerp(e){return[e[1],-e[0]]}_dotProduct(e,i){return e[0]*i[0]+e[1]*i[1]}_crossProduct(e,i){return e[0]*i[1]-e[1]*i[0]}_rotateDirect(e,i,n){const a=e[0]*n+e[1]*i;e[0]=e[0]*i-e[1]*n,e[1]=a}_makeCtrlPt(e){const i=[e[0],e[1]];return(0,Ut.qh)(i,1),i}_addAngledTicks(e,i,n,M){const a=this._sub(n,i);this._normalize(a);const r=this._crossProduct(a,this._sub(M,i));let P;P=r>0?this._rightPerp(a):this._leftPerp(a);const x=Math.abs(r)/2,w=[];w.push([i[0]+(P[0]-a[0])*x,i[1]+(P[1]-a[1])*x]),w.push(i),w.push(n),w.push([n[0]+(P[0]+a[0])*x,n[1]+(P[1]+a[1])*x]),e.push(w)}_addBezier2(e,i,n,M,a){if(0==a--)return void e.push(M);const r=this._mid(i,n),P=this._mid(n,M),x=this._mid(r,P);this._addBezier2(e,i,r,x,a),this._addBezier2(e,x,P,M,a)}_addBezier3(e,i,n,M,a,r){if(0==r--)return void e.push(a);const P=this._mid(i,n),x=this._mid(n,M),w=this._mid(M,a),I=this._mid(P,x),E=this._mid(x,w),tt=this._mid(I,E);this._addBezier3(e,i,P,I,tt,r),this._addBezier3(e,tt,E,w,a,r)}_add90DegArc(e,i,n,M,a){const r=a??this._crossProduct(this._sub(n,i),this._sub(M,i))>0,P=this._mid(i,n),x=this._sub(P,i);r?this._leftPerpendicular(x):this._rightPerpendicular(x),P[0]+=x[0],P[1]+=x[1],this._addBezier3(e,i,this._mix(i,.33333,P,.66667),this._mix(n,.33333,P,.66667),n,4)}_addArrow(e,i,n){const M=i[0],a=i[1],r=i[i.length-1],P=this._sub(M,a);this._normalize(P);const x=this._crossProduct(P,this._sub(r,a)),w=.5*x,I=this._leftPerp(P),E=[r[0]-I[0]*x,r[1]-I[1]*x],tt=i.length-1,Z=[];Z.push(n?[-I[0],-I[1]]:I);let ot=[-P[0],-P[1]];for(let dt=1;dt<tt-1;dt++){const It=this._sub(i[dt+1],i[dt]);this._normalize(It);const Vt=this._dotProduct(It,ot),re=this._crossProduct(It,ot),ne=Math.sqrt((1+Vt)/2),Bt=this._sub(It,ot);this._normalize(Bt),Bt[0]/=ne,Bt[1]/=ne,Z.push(re<0?[-Bt[0],-Bt[1]]:Bt),ot=It}Z.push(this._rightPerp(ot));for(let dt=Z.length-1;dt>0;dt--)e.push([i[dt][0]+Z[dt][0]*w,i[dt][1]+Z[dt][1]*w]);e.push([E[0]+Z[0][0]*w,E[1]+Z[0][1]*w]),e.push([E[0]+Z[0][0]*x,E[1]+Z[0][1]*x]),e.push(M),e.push([E[0]-Z[0][0]*x,E[1]-Z[0][1]*x]),e.push([E[0]-Z[0][0]*w,E[1]-Z[0][1]*w]);for(let dt=1;dt<Z.length;dt++)e.push([i[dt][0]-Z[dt][0]*w,i[dt][1]-Z[dt][1]*w])}_cp2(e,i,n){return e.length>=2?e[1]:this._add2(e[0],i*this._defaultSize,n*this._defaultSize)}_cp3(e,i,n,M){if(e.length>=3)return e[2];const a=this._mix(e[0],1-n,i,n),r=this._sub(i,e[0]);return this._normalize(r),this._rightPerpendicular(r),[a[0]+r[0]*M*this._defaultSize,a[1]+r[1]*M*this._defaultSize]}_arrowPath(e){if(e.length>2)return e;const i=e[0],n=this._cp2(e,-4,0),M=this._sub(i,n);this._normalize(M);const a=this._rightPerp(M);return[i,n,[i[0]+(a[0]-M[0])*this._defaultSize,i[1]+(a[1]-M[1])*this._defaultSize]]}_arrowLastSeg(e){const i=e[0],n=this._cp2(e,-4,0);let M;if(e.length>=3)M=e[e.length-1];else{const a=this._sub(i,n);this._normalize(a);const r=this._rightPerp(a);M=[i[0]+(r[0]-a[0])*this._defaultSize,i[1]+(r[1]-a[1])*this._defaultSize]}return[n,M]}_processGeom(e){if(!e)return null;const i=[];for(const n of e){if(!n||0===n.length)continue;const M=n.length;let a=n[0];switch(this._rule){case q.Em.PerpendicularFromFirstSegment:{const r=this._cp2(n,0,-1),P=this._cp3(n,r,.5,4),x=[];x.push(P),x.push(this._mid(a,r)),i.push(x);break}case q.Em.ReversedFirstSegment:{const r=this._cp2(n,0,-1);i.push([r,a]);break}case q.Em.PerpendicularToSecondSegment:{const r=this._cp2(n,-4,1),P=this._cp3(n,r,.882353,-1.94),x=[];x.push(this._mid(r,P)),x.push(a),i.push(x);break}case q.Em.SecondSegmentWithTicks:{const r=this._cp2(n,-4,1),P=this._cp3(n,r,.882353,-1.94),x=this._sub(P,r);let w;w=this._crossProduct(x,this._sub(a,r))>0?this._rightPerp(w):this._leftPerp(x);const I=[];I.push([r[0]+(w[0]-x[0])/3,r[1]+(w[1]-x[1])/3]),I.push(r),I.push(P),I.push([P[0]+(w[0]+x[0])/3,P[1]+(w[1]+x[1])/3]),i.push(I);break}case q.Em.DoublePerpendicular:{const r=this._cp2(n,0,-1),P=this._cp3(n,r,.5,3),x=this._mid(a,r),w=this._sub(x,P);this._normalize(w);const I=this._crossProduct(w,this._sub(a,P));this._leftPerpendicular(w);const E=[];E.push(a),E.push([P[0]+w[0]*I,P[1]+w[1]*I]),i.push(E);const tt=[];tt.push([P[0]-w[0]*I,P[1]-w[1]*I]),tt.push(r),i.push(tt);break}case q.Em.OppositeToFirstSegment:{const r=this._cp2(n,0,-1),P=this._cp3(n,r,.5,3),x=this._mid(a,r),w=this._sub(x,P);this._normalize(w);const I=this._crossProduct(w,this._sub(a,P));this._leftPerpendicular(w);const E=[];E.push([P[0]+w[0]*I,P[1]+w[1]*I]),E.push([P[0]-w[0]*I,P[1]-w[1]*I]),i.push(E);break}case q.Em.TriplePerpendicular:{const r=this._cp2(n,0,-1),P=this._cp3(n,r,.5,4),x=this._mid(a,r),w=this._sub(x,P);this._normalize(w);const I=this._crossProduct(w,this._sub(a,P));this._leftPerpendicular(w);const E=[];E.push([P[0]+w[0]*I*.8,P[1]+w[1]*I*.8]),E.push([x[0]+.8*(a[0]-x[0]),x[1]+.8*(a[1]-x[1])]),i.push(E),i.push([P,x]);const tt=[];tt.push([P[0]-w[0]*I*.8,P[1]-w[1]*I*.8]),tt.push([x[0]+.8*(r[0]-x[0]),x[1]+.8*(r[1]-x[1])]),i.push(tt);break}case q.Em.HalfCircleFirstSegment:{const r=this._cp2(n,0,-1),P=this._cp3(n,r,.5,4),x=this._mid(a,r);let w=this._sub(r,a);const I=Math.cos(Math.PI/18),E=Math.sin(Math.PI/18),tt=Math.sqrt((1+I)/2),Z=Math.sqrt((1-I)/2),ot=[];let dt;this._crossProduct(w,this._sub(P,a))>0?(ot.push(a),w=this._sub(a,x),dt=r):(ot.push(r),w=this._sub(r,x),dt=a),this._rotateDirect(w,tt,Z),w[0]/=tt,w[1]/=tt;for(let It=1;It<=18;It++)ot.push(this._add(x,w)),this._rotateDirect(w,I,E);ot.push(dt),i.push(ot);break}case q.Em.HalfCircleSecondSegment:{const r=this._cp2(n,0,-1),P=this._cp3(n,r,1,-1);let x=this._sub(a,r);this._normalize(x);const w=this._crossProduct(x,this._sub(P,r))/2;this._leftPerpendicular(x);const I=[r[0]+x[0]*w,r[1]+x[1]*w];x=this._sub(r,I);const E=Math.cos(Math.PI/18);let tt=Math.sin(Math.PI/18);w>0&&(tt=-tt);const Z=[r];for(let ot=1;ot<=18;ot++)this._rotateDirect(x,E,tt),Z.push(this._add(I,x));i.push(Z);break}case q.Em.HalfCircleExtended:{const r=this._cp2(n,0,-2),P=this._cp3(n,r,1,-1);let x;if(M>=4)x=n[3];else{const ot=this._sub(a,r);x=this._add(P,ot)}const w=this._dist(r,P)/2/.75,I=this._sub(r,a);this._normalize(I,w);const E=this._sub(P,x);this._normalize(E,w),i.push([x,P]);const Z=[this._clone(P)];this._addBezier3(Z,P,this._add(P,E),this._add(r,I),r,4),Z.push(a),i.push(Z);break}case q.Em.OpenCircle:{const r=this._cp2(n,-2,0),P=this._sub(r,a),x=Math.cos(Math.PI/18),w=-Math.sin(Math.PI/18),I=[r];for(let E=1;E<=33;E++)this._rotateDirect(P,x,w),I.push(this._add(a,P));i.push(I);break}case q.Em.CoverageEdgesWithTicks:{const r=this._cp2(n,0,-1);let P,x;if(M>=3)P=n[2];else{const tt=this._sub(r,a),Z=this._leftPerp(tt);P=[a[0]+Z[0]-.25*tt[0],a[1]+Z[1]-.25*tt[1]]}if(M>=4)x=n[3];else{const tt=this._mid(a,r),Z=this._sub(a,r);this._normalize(Z),this._leftPerpendicular(Z);const ot=this._crossProduct(Z,this._sub(P,tt));this._rightPerpendicular(Z),x=[P[0]+Z[0]*ot*2,P[1]+Z[1]*ot*2]}const w=this._sub(r,a);let I,E;I=this._crossProduct(w,this._sub(P,a))>0?this._rightPerp(w):this._leftPerp(w),E=[],E.push(P),E.push(a),E.push([a[0]+(I[0]-w[0])/3,a[1]+(I[1]-w[1])/3]),i.push(E),I=this._crossProduct(w,this._sub(x,r))>0?this._rightPerp(I):this._leftPerp(w),E=[],E.push([r[0]+(I[0]+w[0])/3,r[1]+(I[1]+w[1])/3]),E.push(r),E.push(x),i.push(E);break}case q.Em.GapExtentWithDoubleTicks:{const r=this._cp2(n,0,2),P=this._cp3(n,r,0,1);let x;if(M>=4)x=n[3];else{const w=this._sub(r,a);x=this._add(P,w)}this._addAngledTicks(i,a,r,this._mid(P,x)),this._addAngledTicks(i,P,x,this._mid(a,r));break}case q.Em.GapExtentMidline:{const r=this._cp2(n,2,0),P=this._cp3(n,r,0,1);let x;if(M>=4)x=n[3];else{const I=this._sub(r,a);x=this._add(P,I)}const w=[];w.push(this._mid(a,P)),w.push(this._mid(r,x)),i.push(w);break}case q.Em.Chevron:{const r=this._cp2(n,-1,-1);let P;if(M>=3)P=n[2];else{const x=this._sub(r,a);this._leftPerpendicular(x),P=this._add(a,x)}i.push([r,this._makeCtrlPt(a),P]);break}case q.Em.PerpendicularWithArc:{const r=this._cp2(n,0,-2),P=this._cp3(n,r,.5,-1);let x=this._sub(r,a);const w=this._norm(x);x[0]/=w,x[1]/=w;const I=this._crossProduct(x,this._sub(P,a));let E=this._dotProduct(x,this._sub(P,a));E<.05*w?E=.05*w:E>.95*w&&(E=.95*w);const tt=[a[0]+x[0]*E,a[1]+x[1]*E];this._leftPerpendicular(x);let Z=[];Z.push([tt[0]-x[0]*I,tt[1]-x[1]*I]),Z.push([tt[0]+x[0]*I,tt[1]+x[1]*I]),i.push(Z);const ot=[r[0]+x[0]*I,r[1]+x[1]*I];x=this._sub(r,ot);const dt=Math.cos(Math.PI/18);let It=Math.sin(Math.PI/18);I<0&&(It=-It),Z=[a,r];for(let Vt=1;Vt<=9;Vt++)this._rotateDirect(x,dt,It),Z.push(this._add(ot,x));i.push(Z);break}case q.Em.ClosedHalfCircle:{const r=this._cp2(n,2,0),P=this._mid(a,r),x=this._sub(r,P),w=Math.cos(Math.PI/18),I=Math.sin(Math.PI/18),E=[a,r];for(let tt=1;tt<=18;tt++)this._rotateDirect(x,w,I),E.push(this._add(P,x));i.push(E);break}case q.Em.TripleParallelExtended:{const r=this._cp2(n,0,-2),P=this._cp3(n,r,1,-2),x=this._mid(a,r),w=this._sub(P,r);this._normalize(w);const I=Math.abs(this._crossProduct(w,this._sub(x,r)))/2,E=this._dist(r,P),tt=[r,a];tt.push([a[0]+w[0]*E*.5,a[1]+w[1]*E*.5]),i.push(tt);const Z=[];Z.push([x[0]-w[0]*I,x[1]-w[1]*I]),Z.push([x[0]+w[0]*E*.375,x[1]+w[1]*E*.375]),(0,Ut.qh)(Z[Z.length-1],1),Z.push([x[0]+w[0]*E*.75,x[1]+w[1]*E*.75]),i.push(Z),i.push([r,P]);break}case q.Em.ParallelWithTicks:{const r=this._cp2(n,3,0),P=this._cp3(n,r,.5,-1),x=this._sub(P,r);this._normalize(x);const w=this._crossProduct(x,this._sub(P,a));this._leftPerpendicular(x),this._addAngledTicks(i,a,r,P),this._addAngledTicks(i,this._mix(a,1,x,w),this._mix(r,1,x,w),this._mid(a,r));break}case q.Em.Parallel:{const r=this._cp2(n,3,0),P=this._cp3(n,r,.5,-1),x=this._sub(r,a);this._normalize(x);const w=this._leftPerp(x),I=this._crossProduct(x,this._sub(P,a));let E=[a,r];i.push(E),E=[],E.push([a[0]+w[0]*I,a[1]+w[1]*I]),E.push([r[0]+w[0]*I,r[1]+w[1]*I]),i.push(E);break}case q.Em.PerpendicularToFirstSegment:{const r=this._cp2(n,3,0),P=this._cp3(n,r,.5,-1),x=this._mid(a,r),w=this._sub(r,a);this._normalize(w);const I=this._crossProduct(w,this._sub(P,a));this._leftPerpendicular(w);const E=[];E.push([x[0]-w[0]*I*.25,x[1]-w[1]*I*.25]),E.push([x[0]+w[0]*I*1.25,x[1]+w[1]*I*1.25]),i.push(E);break}case q.Em.ParallelOffset:{const r=this._cp2(n,3,0),P=this._cp3(n,r,.5,-1),x=this._sub(r,a);this._normalize(x);const w=this._crossProduct(x,this._sub(P,a));this._leftPerpendicular(x);const I=[];I.push([a[0]-x[0]*w,a[1]-x[1]*w]),I.push([r[0]-x[0]*w,r[1]-x[1]*w]),i.push(I);const E=[];E.push([a[0]+x[0]*w,a[1]+x[1]*w]),E.push([r[0]+x[0]*w,r[1]+x[1]*w]),i.push(E);break}case q.Em.OffsetOpposite:{const r=this._cp2(n,3,0),P=this._cp3(n,r,.5,-1),x=this._sub(r,a);this._normalize(x);const w=this._crossProduct(x,this._sub(P,a));this._leftPerpendicular(x);const I=[];I.push([a[0]-x[0]*w,a[1]-x[1]*w]),I.push([r[0]-x[0]*w,r[1]-x[1]*w]),i.push(I);break}case q.Em.OffsetSame:{const r=this._cp2(n,3,0),P=this._cp3(n,r,.5,-1),x=this._sub(r,a);this._normalize(x);const w=this._crossProduct(x,this._sub(P,a));this._leftPerpendicular(x);const I=[];I.push([a[0]+x[0]*w,a[1]+x[1]*w]),I.push([r[0]+x[0]*w,r[1]+x[1]*w]),i.push(I);break}case q.Em.CircleWithArc:{let r=this._cp2(n,3,0);const P=this._cp3(n,r,.5,-1);let x,w;if(M>=4)x=n[3],w=this._crossProduct(this._sub(x,r),this._sub(P,r))>0;else{x=r,w=this._crossProduct(this._sub(x,a),this._sub(P,a))>0;const ot=24*this._geomUnitsPerPoint,dt=this._sub(x,a);this._normalize(dt,ot);const It=Math.sqrt(2)/2;this._rotateDirect(dt,It,w?It:-It),r=this._add(a,dt)}const I=this._sub(r,a),E=Math.cos(Math.PI/18),tt=Math.sin(Math.PI/18),Z=[r];for(let ot=1;ot<=36;ot++)this._rotateDirect(I,E,tt),Z.push(this._add(a,I));this._add90DegArc(Z,r,x,P,w),(0,Ut.qh)(Z[Z.length-8],1),i.push(Z);break}case q.Em.DoubleJog:{let r,P,x=this._cp2(n,-3,1);if(r=M>=3?n[2]:this._add(a,this._sub(a,x)),M>=4)P=n[3];else{const Vt=a;a=x,P=r;const re=this._dist(a,Vt),ne=this._dist(P,Vt);let Bt=30*this._geomUnitsPerPoint;.5*re<Bt&&(Bt=.5*re),.5*ne<Bt&&(Bt=.5*ne),x=this._mix(a,Bt/re,Vt,(re-Bt)/re),r=this._mix(P,Bt/ne,Vt,(ne-Bt)/ne)}const w=this._mid(a,x),I=this._mid(P,r),E=this._dist(a,x),tt=this._dist(r,P);let Z=Math.min(E,tt)/8;Z=Math.min(Z,24*this._geomUnitsPerPoint);const ot=Math.cos(Math.PI/4);let dt=this._sub(a,x);this._normalize(dt,Z),this._crossProduct(dt,this._sub(P,x))>0?this._rotateDirect(dt,ot,-ot):this._rotateDirect(dt,ot,ot);let It=[];It.push(x),It.push(this._add(w,dt)),It.push(this._sub(w,dt)),It.push(a),i.push(It),dt=this._sub(P,r),this._normalize(dt,Z),this._crossProduct(dt,this._sub(a,r))<0?this._rotateDirect(dt,ot,ot):this._rotateDirect(dt,ot,-ot),It=[],It.push(r),It.push(this._add(I,dt)),It.push(this._sub(I,dt)),It.push(P),i.push(It);break}case q.Em.PerpendicularOffset:{const r=this._cp2(n,-4,1),P=this._cp3(n,r,.882353,-1.94),x=this._sub(P,r);this._crossProduct(x,this._sub(a,r))>0?this._rightPerpendicular(x):this._leftPerpendicular(x);const w=[x[0]/8,x[1]/8],I=this._sub(this._mid(r,P),w);i.push([I,a]);break}case q.Em.LineExcludingLastSegment:{const r=this._arrowPath(n),P=[];let x=r.length-2;for(;x--;)P.push(r[x]);i.push(P);break}case q.Em.MultivertexArrow:{const r=this._arrowPath(n),P=[];this._addArrow(P,r,!1),i.push(P);break}case q.Em.CrossedArrow:{const r=this._arrowPath(n),P=[];this._addArrow(P,r,!0),i.push(P);break}case q.Em.ChevronArrow:{const[r,P]=this._arrowLastSeg(n),x=10*this._geomUnitsPerPoint,w=this._sub(a,r);this._normalize(w);const I=this._crossProduct(w,this._sub(P,r)),E=this._leftPerp(w),tt=[P[0]-E[0]*I*2,P[1]-E[1]*I*2],Z=[];Z.push([P[0]+w[0]*x,P[1]+w[1]*x]),Z.push(a),Z.push([tt[0]+w[0]*x,tt[1]+w[1]*x]),i.push(Z);break}case q.Em.ChevronArrowOffset:{const[r,P]=this._arrowLastSeg(n),x=this._sub(a,r);this._normalize(x);const w=this._crossProduct(x,this._sub(P,r));this._leftPerpendicular(x);const I=[P[0]-x[0]*w,P[1]-x[1]*w],E=[];E.push([I[0]+x[0]*w*.5,I[1]+x[1]*w*.5]),E.push(this._mid(I,a)),E.push([I[0]-x[0]*w*.5,I[1]-x[1]*w*.5]),i.push(E);break}case q.Em.PartialFirstSegment:{const[r,P]=this._arrowLastSeg(n),x=this._sub(a,r);this._normalize(x);const w=this._crossProduct(x,this._sub(P,r));this._leftPerpendicular(x),i.push([r,[P[0]-x[0]*w,P[1]-x[1]*w]]);break}case q.Em.Arch:{const r=this._cp2(n,0,-1),P=this._cp3(n,r,.5,1),x=this._sub(a,r),w=this._mix(P,1,x,.55),I=this._mix(P,1,x,-.55),E=[a];this._addBezier2(E,a,w,P,4),this._addBezier2(E,P,I,r,4),i.push(E);break}case q.Em.CurvedParallelTicks:{const r=this._cp2(n,-4,1),P=this._cp3(n,r,.882353,-1.94),x=this._sub(P,r);this._crossProduct(x,this._sub(a,r))>0?this._rightPerpendicular(x):this._leftPerpendicular(x);const w=[x[0]/8,x[1]/8],I=this._sub(this._mid(r,P),w),E=this._sub(this._mix(r,.75,P,.25),w),tt=this._sub(this._mix(r,.25,P,.75),w),Z=[r];this._addBezier2(Z,r,E,I,3),this._addBezier2(Z,I,tt,P,3),i.push(Z);for(let ot=0;ot<8;ot++){const dt=Z[2*ot+1],It=[this._clone(dt)];It.push(this._add(dt,[x[0]/4,x[1]/4])),i.push(It)}break}case q.Em.Arc90Degrees:{const r=this._cp2(n,0,-1),P=this._cp3(n,r,.5,1),x=[r];this._add90DegArc(x,r,a,P),i.push(x);break}default:i.push(n)}}return i}}let it=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new Ct(i,n,M)}}return v.instance=null,v})();class Ct extends Ut.zY{constructor(e,i,n){super(e,!0,!0),this._curveHelper=new Lt,this._beginCut=(void 0!==i.beginCut?i.beginCut:1)*n,this._endCut=(void 0!==i.endCut?i.endCut:1)*n,this._middleCut=(void 0!==i.middleCut?i.middleCut:0)*n,this._invert=void 0!==i.invert&&i.invert,this._beginCut<0&&(this._beginCut=0),this._endCut<0&&(this._endCut=0),this._middleCut<0&&(this._middleCut=0)}processPath(e){const i=this._beginCut,n=this._endCut,M=this._middleCut,a=this._curveHelper.calculatePathLength(e),r=[];if(this._invert){if(0!==i||0!==n||0!==M)if(i+n+M>=a)r.push(e);else{let P=this._curveHelper.getSubCurve(e,0,i);P&&r.push(P),P=this._curveHelper.getSubCurve(e,.5*(a-M),.5*(a+M)),P&&r.push(P),P=this._curveHelper.getSubCurve(e,a-n,n),P&&r.push(P)}}else if(0===i&&0===n&&0===M)r.push(e);else if(!(i+n+M>=a))if(0===M){const P=this._curveHelper.getSubCurve(e,i,a-n);P&&r.push(P)}else{let P=this._curveHelper.getSubCurve(e,i,.5*(a-M));P&&r.push(P),P=this._curveHelper.getSubCurve(e,.5*(a+M),a-n),P&&r.push(P)}return 0===r.length?null:{paths:r}}}class qt{constructor(){this._values=[],this.extPtGap=0,this.ctrlPtGap=0,this._length=0,this._currentValue=0}isEmpty(){return 0===this._values.length}size(){return this._values.length}init(e,i,n=!0){if(this._setEmpty(),!e||0===e.length)return!1;for(let M=0;M<e.length;M++){let a=Math.abs(e[M]);n&&a<1e-7&&(a=1e-7),this._values.push(a),this._length+=a}return i&&1&e.length&&(this._length*=2),0!==this._length&&(this.ctrlPtGap=this.extPtGap=0,this._currentValue=-1,!0)}scale(e){const i=this._values?this._values.length:0;for(let n=0;n<i;++n)this._values[n]*=e;this._length*=e,this.extPtGap*=e,this.ctrlPtGap*=e}addValue(e){this._length+=e,this._values.push(e)}firstValue(){return this._values[0]}lastValue(){return this._values[this._values.length-1]}nextValue(){return this._currentValue++,this._currentValue===this._values.length&&(this._currentValue=0),this._values[this._currentValue]}reset(){this._currentValue=-1}length(){return this._length}_setEmpty(){this.extPtGap=this.ctrlPtGap=this._length=0,this._currentValue=-1,this._values.length=0}}class Dt{constructor(){this.pt=null,this.ca=0,this.sa=0}}var ee,v;(v=ee||(ee={}))[v.FAIL=0]="FAIL",v[v.END=1]="END",v[v.CONTINUE=2]="CONTINUE";class Rt{constructor(){this.reset()}reset(){this.segment=-1,this.segmentLength=0,this.abscissa=0,this.isPathEnd=!1,this.isPartEnd=!1}isValid(){return-1!==this.segment}copyTo(e){e.segment=this.segment,e.segmentLength=this.segmentLength,e.abscissa=this.abscissa,e.isPathEnd=this.isPathEnd,e.isPartEnd=this.isPartEnd}}class ct extends Lt{constructor(e=0,i=!1){super(e,i),this._tolerance=At,this._currentPosition=new Rt}updateTolerance(e){this._tolerance=At*e}init(e,i,n=!0){return n?(this._patternLength=i.length(),this._partExtPtGap=i.extPtGap,this._partCtrlPtGap=i.ctrlPtGap):(this._patternLength=0,this._partExtPtGap=0,this._partCtrlPtGap=0),this._currentPosition.reset(),this._partSegCount=0,this._path=e,this._seg=-1,this._setPosAtNextPart()}curPositionIsValid(){return this._currentPosition.isValid()}nextPosition(e,i=ee.FAIL){const n=new Rt;return!!this._nextPosition(e,n,null,i)&&(n.copyTo(this._currentPosition),!0)}curPointAndAngle(e){e.pt=this._getPoint(this._currentPosition);const[i,n]=this._getAngle(this._currentPosition);e.ca=i,e.sa=n}nextPointAndAngle(e,i,n=ee.FAIL){const M=new Rt;if(!this._nextPosition(e,M,null,n))return!1;M.copyTo(this._currentPosition),i.pt=this._getPoint(M);const[a,r]=this._getAngle(M);return i.ca=a,i.sa=r,!0}nextCurve(e){if(0===e)return null;const i=[],n=new Rt;return this._nextPosition(e,n,i,ee.END)?(n.copyTo(this._currentPosition),i):null}isPathEnd(){return this._currentPosition.isPathEnd}getPathEnd(){if(-1===this._currentPosition.segment)throw new Error("missing segment");return this._path[this._currentPosition.segment+1]}_nextPosition(e,i,n,M){if(this._currentPosition.isPathEnd)return!1;let a=this._currentPosition.abscissa;for(this._currentPosition.segmentLength>0&&(a/=this._currentPosition.segmentLength),this._currentPosition.copyTo(i);i.abscissa+e*this._partLengthRatio>i.segmentLength+this._tolerance;){if(n){if(0===n.length)if(0===a){const P=this._path[i.segment];n.push([P[0],P[1]])}else n.push(this.getSegCoord2D(this._path,i.segment,a));const r=this._path[i.segment+1];n.push([r[0],r[1]])}if(a=0,e-=(i.segmentLength-i.abscissa)/this._partLengthRatio,this._partSegCount)i.segment=this._nextSegment(),i.segmentLength=this.calculateSegLength(this._path,i.segment),i.abscissa=0,this._partSegCount--;else{if(!this._setPosAtNextPart())return M!==ee.FAIL&&(i.segmentLength=this.calculateSegLength(this._path,i.segment),i.isPartEnd=!0,M===ee.END?(i.abscissa=i.segmentLength,i.isPathEnd=!0):i.abscissa=i.segmentLength+e,!0);this._currentPosition.copyTo(i)}}if(i.abscissa+=e*this._partLengthRatio,n){if(0===n.length)if(0===a){const P=this._path[i.segment];n.push([P[0],P[1]])}else n.push(this.getSegCoord2D(this._path,i.segment,a));const r=i.abscissa/i.segmentLength;if(1===r){const P=this._path[i.segment+1];n.push([P[0],P[1]])}else n.push(this.getSegCoord2D(this._path,i.segment,r))}return this._partSegCount||Math.abs(i.abscissa-i.segmentLength)<this._tolerance&&(i.isPathEnd=this._partIsLast,i.isPartEnd=!0),!0}_getPoint(e){if(-1===e.segment)throw new Error("missing segment");return this.getSegCoord2D(this._path,e.segment,e.segmentLength<=0?0:e.abscissa/e.segmentLength)}_getAngle(e){if(-1===e.segment)throw new Error("missing segment");return this.getSegAngleCS(this._path,e.segment,e.segmentLength<=0?0:e.abscissa/e.segmentLength)}_setPosAtNextPart(){for(;this._partSegCount;)this._hasNextSegment()&&this._nextSegment(),this._partSegCount--;if(!this._hasNextSegment())return!1;for(this._partLength=0,this._partIsLast=!0,this._partSegCount=0;this._hasNextSegment();)if(this._partLength+=this.calculateSegLength(this._path,this._nextSegment()),this._partSegCount++,1===(0,Ut.zv)(this._path[this._getEndPointIndex()])){this._partIsLast=!this._hasNextSegment();break}let e=this._partSegCount;for(;e;)this._previousSegment(),--e;this._currentPosition.segment=this._nextSegment(),this._currentPosition.segmentLength=this.calculateSegLength(this._path,this._currentPosition.segment),this._currentPosition.abscissa=0,this._currentPosition.isPathEnd=this._currentPosition.isPartEnd=!1,--this._partSegCount;const i=this._getStartPointIndex();this._ctrlPtBegin=1===(0,Ut.zv)(this._path[i]);let n=i+this._partSegCount+1;if(n>=this._path.length&&(n=0),this._ctrlPtEnd=1===(0,Ut.zv)(this._path[n]),this._patternLength>0){const M=this._ctrlPtBegin?this._partCtrlPtGap:this._partExtPtGap,a=this._ctrlPtEnd?this._partCtrlPtGap:this._partExtPtGap;let r=Math.round((this._partLength-(M+a))/this._patternLength);r<=0&&(r=M+a>0?0:1),this._partLengthRatio=this._partLength/(M+a+r*this._patternLength),this._partLengthRatio<.01&&(this._partLengthRatio=1)}else this._partLengthRatio=1;return!0}_hasNextSegment(){return this._seg<this._path.length-2}_previousSegment(){return--this._seg}_nextSegment(){return++this._seg}_getStartPointIndex(){return this._seg}_getEndPointIndex(){return this._seg+1}}let yt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new pt(i,n,M)}}return v.instance=null,v})();class pt extends Ut.zY{constructor(e,i,n){super(e,!0,!0),this._firstCurve=null,this._walker=new ct,this._walker.updateTolerance(n),this._endings=i.lineDashEnding,this._customDashPos=-(i.offsetAlongLine??0)*n,this._offsetAtEnd=(i.customEndingOffset??0)*n,this._pattern=new qt,this._pattern.init(i.dashTemplate,!0),this._pattern.scale(n)}processPath(e){if(0===this._pattern.length())return this.iteratePath=!1,{paths:[e]};if(!this.iteratePath){let M=!0;switch(this._endings){case q.sj.HalfPattern:case q.sj.HalfGap:default:this._pattern.extPtGap=0;break;case q.sj.FullPattern:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.firstValue());break;case q.sj.FullGap:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.lastValue());break;case q.sj.NoConstraint:this.isClosed||(M=!1);break;case q.sj.Custom:this.isClosed||(this._pattern.extPtGap=.5*this._offsetAtEnd)}const a=this._walker.calculatePathLength(e);if(this._pattern.isEmpty()||a<.1*this._pattern.length())return{paths:[e]};if(!this._walker.init(e,this._pattern,M))return{paths:[e]}}let i;if(this.iteratePath)i=this._pattern.nextValue();else{let M;switch(this._endings){case q.sj.HalfPattern:default:M=.5*this._pattern.firstValue();break;case q.sj.HalfGap:M=.5*-this._pattern.lastValue();break;case q.sj.FullGap:M=-this._pattern.lastValue();break;case q.sj.FullPattern:M=0;break;case q.sj.NoConstraint:case q.sj.Custom:M=-this._customDashPos}let a=M/this._pattern.length();a-=Math.floor(a),M=a*this._pattern.length(),this._pattern.reset(),i=this._pattern.nextValue();let r=!1;for(;M>=i;)M-=i,i=this._pattern.nextValue(),r=!r;i-=M,r?(this._walker.nextPosition(i),i=this._pattern.nextValue()):this.isClosed&&(this._firstCurve=this._walker.nextCurve(i),i=this._pattern.nextValue(),this._walker.nextPosition(i),i=this._pattern.nextValue())}let n=this._walker.nextCurve(i);return n?this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(this._firstCurve.splice(0,1),Mt.mergePath(n,this._firstCurve),this._firstCurve=null)):(i=this._pattern.nextValue(),!this._walker.nextPosition(i)||this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(n=this._firstCurve,this._firstCurve=null)):this.iteratePath=!0):(this.iteratePath=!1,n=this._firstCurve,this._firstCurve=null),{paths:[n]}}}let Pt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new vt(i,n,M,a,r)}}return v.instance=null,v})();class vt{constructor(e,i,n,M,a){this._inputGeometries=e,this._tileKey=M,this._geometryEngine=a,this._width=(void 0!==i.width?i.width:2)*n,this._option=i.option}next(){let e;for(;e=this._inputGeometries.next();){if((0,gt.YX)(e)&&this._width>0){if(Math.min(e.xmax-e.xmin,e.ymax-e.ymin)-2*this._width<0)return e;const i=[];return i.push([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]),i.push([[e.xmin+this._width,e.ymin+this._width],[e.xmax-this._width,e.ymin+this._width],[e.xmax-this._width,e.ymax-this._width],[e.xmin+this._width,e.ymax-this._width],[e.xmin+this._width,e.ymin+this._width]]),{rings:i}}if((0,gt.oU)(e)){let i=null;const n=this._geometryEngine;let M=e;if(this._tileKey&&(M=(0,Q.ib)(e,Math.abs(this._width)+1),!M||!M.rings||0===M.rings.length))continue;if((0,Et.pC)(n)&&(i=n.buffer($t.Z.WebMercator,M,-this._width,1)),this._width>0){const a=[];for(const r of e.rings)r&&a.push(r);if(i)for(const r of i.rings)r&&a.push(r.reverse());if(a.length)return{rings:a}}}}return null}}let Ft=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new te(i,n,M)}}return v.instance=null,v})();class te extends Ut.zY{constructor(e,i,n){super(e,!1,!0),this._curveHelper=new Lt,this._length=(void 0!==i.length?i.length:20)*n,this._angle=void 0!==i.angle?i.angle:225,this._position=void 0!==i.position?i.position:50,this._length<0&&(this._length=-this._length),this._position<20&&(this._position=20),this._position>80&&(this._position=80),this._mirror=!1}processPath(e){if(this._curveHelper.isEmpty(e,!1))return null;const i=e[0],n=e[e.length-1];this._curveHelper.normalize([n[0]-i[0],n[1]-i[1]]);const a=[i[0]+(n[0]-i[0])*this._position/100,i[1]+(n[1]-i[1])*this._position/100],r=Math.cos((90-this._angle)/180*Math.PI);let P=Math.sin((90-this._angle)/180*Math.PI);return this._mirror&&(P=-P),this._mirror=!this._mirror,{paths:[[i,[a[0]-this._length/2*r,a[1]-this._length/2*P],[a[0]+this._length/2*r,a[1]+this._length/2*P],n]]}}}let Zt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new ae(i,n,M)}}return v.instance=null,v})();class ae{constructor(e,i,n){this._inputGeometries=e,this._offsetX=void 0!==i.offsetX?i.offsetX*n:0,this._offsetY=void 0!==i.offsetY?-i.offsetY*n:0}next(){let e=this._inputGeometries.next();for(;e;){if((0,gt.YX)(e))return{xmin:e.xmin+this._offsetX,xmax:e.xmax+this._offsetX,ymin:e.ymin+this._offsetY,ymax:e.ymax+this._offsetY};if((0,gt.oU)(e)){const i=(0,Wt.d9)(e);return this._moveMultipath(i.rings,this._offsetX,this._offsetY),i}if((0,gt.l9)(e)){const i=(0,Wt.d9)(e);return this._moveMultipath(i.paths,this._offsetX,this._offsetY),i}if((0,gt.aW)(e)){const i=(0,Wt.d9)(e);return this._movePath(i.points,this._offsetX,this._offsetY),i}if((0,gt.wp)(e))return{x:e.x+this._offsetX,y:e.y+this._offsetY};e=this._inputGeometries.next()}return null}_moveMultipath(e,i,n){if(e)for(const M of e)this._movePath(M,i,n)}_movePath(e,i,n){if(e)for(const M of e)M[0]+=i,M[1]+=n}}let ce=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new wt(i,n,M,a,r)}}return v.instance=null,v})();class wt{constructor(e,i,n,M,a){this._inputGeometries=e,this._tileKey=M,this._geometryEngine=a,this._curveHelper=new Lt,this._offset=(i.offset??1)*n,this._method=i.method,this._option=i.option,this._offsetFlattenError=At*n}next(){let e;for(;e=this._inputGeometries.next();){if(0===this._offset)return e;if((0,gt.YX)(e)){if(this._method===q.id.Rounded&&this._offset>0){const a=this._curveHelper.offset([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]],-this._offset,this._method,4,this._offsetFlattenError);return a?{rings:[a]}:null}if(Math.min(e.xmax-e.xmin,e.ymax-e.ymin)+2*this._offset>0)return{xmin:e.xmin-this._offset,xmax:e.xmax+this._offset,ymin:e.ymin-this._offset,ymax:e.ymax+this._offset}}const i=this._geometryEngine;if((0,Et.Wi)(i))return null;let n=e;if((0,gt.oU)(e)){if(this._tileKey&&(n=(0,Q.ib)(e,Math.abs(this._offset)+1),!n||!n.rings||0===n.rings.length))continue}else if((0,gt.l9)(e)&&this._tileKey&&(n=(0,Q.yn)(e,Math.abs(this._offset)+1),!n||!n.paths||0===n.paths.length))continue;return i.offset($t.Z.WebMercator,n,-this._offset,1,this._method,4,this._offsetFlattenError)}return null}}let y=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new k(i,n,M)}}return v.instance=null,v})();class k{constructor(e,i,n){this._inputGeometries=e,this._reverse=void 0===i.reverse||i.reverse}next(){let e=this._inputGeometries.next();for(;e;){if(!this._reverse)return e;if((0,gt.l9)(e)){const i=(0,Wt.d9)(e);return(0,Ut.ov)(i.paths),i}e=this._inputGeometries.next()}return null}}var Y=ut(65401),A=ut(32442);let j=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new ht(i,n,M)}}return v.instance=null,v})();class ht{constructor(e,i,n){this._inputGeometries=e,this._rotateAngle=void 0!==i.angle?i.angle*Math.PI/180:0}next(){let e=this._inputGeometries.next();for(;e;){if(0===this._rotateAngle)return e;const i=(0,Y.Ue)();(0,A.$P)(i,e);const n=(i[2]+i[0])/2,M=(i[3]+i[1])/2;if((0,gt.YX)(e)){const a={rings:[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]]};return this._rotateMultipath(a.rings,n,M),a}if((0,gt.oU)(e)){const a=(0,Wt.d9)(e);return this._rotateMultipath(a.rings,n,M),a}if((0,gt.l9)(e)){const a=(0,Wt.d9)(e);return this._rotateMultipath(a.paths,n,M),a}if((0,gt.aW)(e)){const a=(0,Wt.d9)(e);return this._rotatePath(a.points,n,M),a}if((0,gt.wp)(e))return e;e=this._inputGeometries.next()}return null}_rotateMultipath(e,i,n){if(e)for(const M of e)this._rotatePath(M,i,n)}_rotatePath(e,i,n){if(e){const M=Math.cos(this._rotateAngle),a=Math.sin(this._rotateAngle);for(const r of e){const P=r[0]-i,x=r[1]-n;r[0]=i+P*M-x*a,r[1]=n+P*a+x*M}}}}let K=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new bt(i,n,M)}}return v.instance=null,v})();class bt{constructor(e,i,n){this._inputGeometries=e,this._xFactor=void 0!==i.xScaleFactor?i.xScaleFactor:1.15,this._yFactor=void 0!==i.yScaleFactor?i.yScaleFactor:1.15}next(){let e=this._inputGeometries.next();for(;e;){if(1===this._xFactor&&1===this._yFactor)return e;const i=(0,Y.Ue)();(0,A.$P)(i,e);const n=(i[2]+i[0])/2,M=(i[3]+i[1])/2;if((0,gt.YX)(e)){const a={rings:[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]]};return this._scaleMultipath(a.rings,n,M),a}if((0,gt.oU)(e)){const a=(0,Wt.d9)(e);return this._scaleMultipath(a.rings,n,M),a}if((0,gt.l9)(e)){const a=(0,Wt.d9)(e);return this._scaleMultipath(a.paths,n,M),a}if((0,gt.aW)(e)){const a=(0,Wt.d9)(e);return this._scalePath(a.points,n,M),a}if((0,gt.wp)(e))return e;e=this._inputGeometries.next()}return null}_scaleMultipath(e,i,n){if(e)for(const M of e)this._scalePath(M,i,n)}_scalePath(e,i,n){if(e)for(const M of e){const r=(M[1]-n)*this._yFactor;M[0]=i+(M[0]-i)*this._xFactor,M[1]=n+r}}}let Tt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new T(i,n,M)}}return v.instance=null,v})();class T{constructor(e,i,n){this._inputGeometries=e,this._height=(void 0!==i.amplitude?i.amplitude:2)*n,this._period=(void 0!==i.period?i.period:3)*n,this._style=i.waveform,this._height<=0&&(this._height=Math.abs(this._height)),this._period<=0&&(this._period=Math.abs(this._period)),this._pattern=new qt,this._pattern.addValue(this._period),this._pattern.addValue(this._period),this._walker=new ct,this._walker.updateTolerance(n)}next(){let e=this._inputGeometries.next();for(;e;){if(0===this._height||0===this._period)return e;if((0,gt.l9)(e)){const i=this._processGeom(e.paths);if(i.length)return{paths:i}}if((0,gt.oU)(e)){const i=this._processGeom(e.rings);if(i.length)return{rings:i}}e=this._inputGeometries.next()}return null}_processGeom(e){const i=[];for(const n of e)if(this._walker.init(n,this._pattern))switch(this._style){case q.zQ.Sinus:default:i.push(this._constructCurve(n,!1));break;case q.zQ.Square:i.push(this._constructSquare(n));break;case q.zQ.Triangle:i.push(this._constructTriangle(n));break;case q.zQ.Random:i.push(this._constructCurve(n,!0))}else i.push(n);return i}_constructCurve(e,i){const n=new Mt,M=this._walker.calculatePathLength(e);let a=Math.round(M/this._period);0===a&&(a=1);const x=this._period/16,w=1/(16*a+1),I=2*Math.PI*M/(M/a),E=2*Math.PI*Math.random(),tt=2*Math.PI*Math.random(),Z=2*Math.PI*Math.random(),ot=.75-Math.random()/2,dt=.75-Math.random()/2,It=new Dt;this._walker.curPointAndAngle(It),n.startPath(It.pt);let Vt=0;for(;;){if(!this._walker.nextPointAndAngle(x,It)){n.lineTo(e[e.length-1]);break}{const re=Vt;let ne;if(Vt+=w,i){const Bt=this._height/2*(1+.3*Math.sin(ot*I*re+E));ne=Bt*Math.sin(I*re+tt),ne+=Bt*Math.sin(dt*I*re+Z),ne/=2}else ne=.5*this._height*Math.sin(.5*I*re);n.lineTo([It.pt[0]-ne*It.sa,It.pt[1]+ne*It.ca])}}return n.path()}_constructSquare(e){const i=new Mt,n=this._walker.calculatePathLength(e);Math.round(n/this._period);let M=!0;for(;;){let a=!1;if(this._walker.curPositionIsValid()){const r=new Dt;this._walker.curPointAndAngle(r);const P=new Dt;if(this._walker.nextPointAndAngle(this._period,P)){const x=new Dt;this._walker.nextPointAndAngle(this._period,x)&&(M?(i.startPath(r.pt),M=!1):i.lineTo(r.pt),i.lineTo([r.pt[0]-this._height/2*r.sa,r.pt[1]+this._height/2*r.ca]),i.lineTo([P.pt[0]-this._height/2*P.sa,P.pt[1]+this._height/2*P.ca]),i.lineTo([P.pt[0]+this._height/2*P.sa,P.pt[1]-this._height/2*P.ca]),i.lineTo([x.pt[0]+this._height/2*x.sa,x.pt[1]-this._height/2*x.ca]),a=!0)}}if(!a){i.lineTo(this._walker.getPathEnd());break}}return i.path()}_constructTriangle(e){const i=new Mt,n=this._walker.calculatePathLength(e);Math.round(n/this._period);let M=!0;for(;;){let a=!1;if(this._walker.curPositionIsValid()){const r=new Dt;this._walker.curPointAndAngle(r);const P=new Dt;if(this._walker.nextPointAndAngle(this._period/2,P)){const x=new Dt;this._walker.nextPointAndAngle(this._period,x)&&(this._walker.nextPosition(this._period/2)&&(M?(i.startPath(r.pt),M=!1):i.lineTo(r.pt),i.lineTo([P.pt[0]-this._height/2*P.sa,P.pt[1]+this._height/2*P.ca]),i.lineTo([x.pt[0]+this._height/2*x.sa,x.pt[1]-this._height/2*x.ca])),a=!0)}}if(!a){i.lineTo(this._walker.getPathEnd());break}}return i.path()}}let S=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new L(i,n,M)}}return v.instance=null,v})();class L extends Ut.v1{constructor(e,i,n){super(e,!0,!0),this._geometryWalker=new ct,this._geometryWalker.updateTolerance(n),this._angleToLine=i.angleToLine??!0,this._offset=(i.offset?i.offset:0)*n,this._originalEndings=i.endings,this._offsetAtEnd=(i.customEndingOffset?i.customEndingOffset:0)*n,this._position=-(i.offsetAlongLine?i.offsetAlongLine:0)*n,this._pattern=new qt,this._pattern.init(i.placementTemplate,!1),this._pattern.scale(n),this._endings=this._originalEndings}processPath(e){if(this._pattern.isEmpty())return null;let i;if(this.iteratePath)i=this._pattern.nextValue();else{this._endings=this._originalEndings===q.JS.WithFullGap&&this.isClosed?q.JS.WithMarkers:this._originalEndings,this._pattern.extPtGap=0;let M,a=!0;switch(this._endings){case q.JS.NoConstraint:M=-this._position,M=this._adjustPosition(M),a=!1;break;case q.JS.WithHalfGap:default:M=-this._pattern.lastValue()/2;break;case q.JS.WithFullGap:M=-this._pattern.lastValue(),this._pattern.extPtGap=this._pattern.lastValue();break;case q.JS.WithMarkers:M=0;break;case q.JS.Custom:M=-this._position,M=this._adjustPosition(M),this._pattern.extPtGap=.5*this._offsetAtEnd}if(!this._geometryWalker.init(e,this._pattern,a))return null;this._pattern.reset();let r=0;for(;M>r;)M-=r,r=this._pattern.nextValue();r-=M,i=r,this.iteratePath=!0}const n=new Dt;return this._geometryWalker.nextPointAndAngle(i,n)?this._endings===q.JS.WithFullGap&&this._geometryWalker.isPathEnd()?(this.iteratePath=!1,null):this._endings===q.JS.WithMarkers&&this._geometryWalker.isPathEnd()&&(this.iteratePath=!1,this.isClosed)?null:(this.internalPlacement.setTranslate(n.pt[0]-this._offset*n.sa,n.pt[1]+this._offset*n.ca),this._angleToLine&&this.internalPlacement.setRotateCS(n.ca,n.sa),this.internalPlacement):(this.iteratePath=!1,null)}_adjustPosition(e){let i=e/this._pattern.length();return i-=Math.floor(i),i*this._pattern.length()}}let N=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new J(i,n,M)}}return v.instance=null,v})();class J extends Ut.v1{constructor(e,i,n){super(e,!1,!0),this._curveHelper=new Lt,this._angleToLine=void 0===i.angleToLine||i.angleToLine,this._offset=void 0!==i.offset?i.offset*n:0,this._type=i.extremityPlacement,this._position=void 0!==i.offsetAlongLine?i.offsetAlongLine*n:0,this._beginProcessed=!1}processPath(e){let i;switch(this._type){case q.Tx.Both:default:this._beginProcessed?(i=this._atExtremities(e,this._position,!1),this._beginProcessed=!1,this.iteratePath=!1):(i=this._atExtremities(e,this._position,!0),this._beginProcessed=!0,this.iteratePath=!0);break;case q.Tx.JustBegin:i=this._atExtremities(e,this._position,!0);break;case q.Tx.JustEnd:i=this._atExtremities(e,this._position,!1);case q.Tx.None:}return i}_atExtremities(e,i,n){const M=e.length;if(M<2)return null;const r=n?M:-1,P=n?1:-1;let x,w=0,I=n?e[0]:e[M-1];for(let E=n?1:M-2;E!==r;E+=P){x=I,I=e[E];const tt=this._curveHelper.calculateLength(x,I);if(w+tt>i){const Z=(i-w)/tt,[ot,dt]=this._curveHelper.getAngleCS(x,I,Z),It=(0,Ut.XV)(x,I,Z);return this.internalPlacement.setTranslate(It[0]-this._offset*dt,It[1]+this._offset*ot),this._angleToLine&&this.internalPlacement.setRotateCS(-ot,-dt),this.internalPlacement}w+=tt}return null}}let O=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new $(i,n,M)}}return v.instance=null,v})();class $ extends Ut.v1{constructor(e,i,n){super(e,!0,!0),this._walker=new ct,this._walker.updateTolerance(n),this._angleToLine=void 0===i.angleToLine||i.angleToLine,this._offset=void 0!==i.offset?i.offset*n:0,this._beginGap=void 0!==i.beginPosition?i.beginPosition*n:0,this._endGap=void 0!==i.endPosition?i.endPosition*n:0,this._flipFirst=void 0===i.flipFirst||i.flipFirst,this._pattern=new qt,this._pattern.init(i.positionArray,!1,!1),this._subPathLen=0,this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0}processPath(e){if(this._pattern.isEmpty())return null;let i;if(this.iteratePath){const P=this._pattern.nextValue()*this._subPathLen,x=this._beginGap+P;i=x-this._prevPos,this._prevPos=x}else{if(this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0,this._subPathLen=this._walker.calculatePathLength(e)-this._beginGap-this._endGap,this._subPathLen<0)return this.iteratePath=!1,null;if(!this._walker.init(e,this._pattern,!1))return null;this._pattern.reset();const P=this._pattern.nextValue()*this._subPathLen,x=this._beginGap+P;i=x-this._prevPos,this._prevPos=x,this.iteratePath=!0}const n=new Dt;if(!this._walker.nextPointAndAngle(i,n,ee.END))return this.iteratePath=!1,null;let a,r;return this.internalPlacement.setTranslate(n.pt[0]-this._offset*n.sa,n.pt[1]+this._offset*n.ca),this._angleToLine?(a=n.ca,r=n.sa):(a=1,r=0),this._isFirst&&this._flipFirst&&(a=-a,r=-r),this.internalPlacement.setRotateCS(a,r),this._isFirst=!1,this._posCount--,0===this._posCount&&(this.iteratePath=!1),this.internalPlacement}}var lt=ut(4619),F=ut(97373);const u=512,W=24;let rt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new nt(i,n,M,a,r)}}return v.instance=null,v})();class nt{constructor(e,i,n,M,a){if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._accelerationMap=null,this._testInsidePolygon=!1,this._verticalSubdivision=!0,this._stepX=Math.abs(i.stepX??16)*n,this._stepY=Math.abs(i.stepY??16)*n,0!==this._stepX&&0!==this._stepY&&e&&function mt(v){return void 0!==v.rings}(e)&&e.rings){if(this._gridType=i.gridType??q.bj.Fixed,this._gridType===q.bj.Random)this._randomLCG=new lt.Z(1*(i.seed??13)),this._randomness=(i.randomness??100)/100,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0,this._buildRandomValues();else{if(this._randomness=0,this._gridAngle=i.gridAngle??0,this._shiftOddRows=i.shiftOddRows??!1,this._offsetX=(i.offsetX??0)*n,this._offsetY=(i.offsetY??0)*n,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}if(this._graphicOriginX=0,this._graphicOriginY=0,null!=M){const[r,P,x]=M.split("/"),w=parseFloat(P),I=parseFloat(x);this._graphicOriginX=-I*u,this._graphicOriginY=w*u,this._testInsidePolygon=!0}this._internalPlacement=new F.u,this._calculateMinMax(e),this._geometry=e}}next(){return this._geometry?this._nextInside():null}_buildRandomValues(){if(!nt._randValues){nt._randValues=[];for(let e=0;e<W;e++)for(let i=0;i<W;i++)nt._randValues.push(this._randomLCG.getFloat()),nt._randValues.push(this._randomLCG.getFloat())}}_calculateMinMax(e){let i,n,M,a,r,P,x,w,I,E,tt,Z,ot,dt;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,x=w=ot=tt=Number.MAX_VALUE,I=E=dt=Z=-Number.MAX_VALUE;const It=1!==this._cosAngle;let Vt=0;for(const Bt of e.rings){const xe=Bt?Bt.length:0;for(let de=0;de<xe;de++)P=Bt[de][0],r=Bt[de][1],i=P-this._graphicOriginX-this._offsetX,n=r-this._graphicOriginY-this._offsetY,It?(M=this._cosAngle*i-this._sinAngle*n,a=this._sinAngle*i+this._cosAngle*n):(M=i,a=n),x=Math.min(x,M),I=Math.max(I,M),w=Math.min(w,a),E=Math.max(E,a),tt=Math.min(tt,r),Z=Math.max(Z,r),ot=Math.min(ot,P),dt=Math.max(dt,P),Vt++}tt=tt!==Number.MAX_VALUE?tt:-u-this._stepY,Z=Z!==-Number.MAX_VALUE?Z:this._stepY,ot=ot!==Number.MAX_VALUE?ot:-this._stepX,dt=dt!==-Number.MAX_VALUE?dt:u+this._stepX;const re=Z-tt,ne=dt-ot;if(this._verticalSubdivision=re>=ne,this._polygonMin=this._verticalSubdivision?tt:ot,this._testInsidePolygon){let Bt=0-this._graphicOriginX-this._offsetX-this._stepX,xe=u-this._graphicOriginX-this._offsetX+this._stepX,de=-u-this._graphicOriginY-this._offsetY-this._stepY,Le=0-this._graphicOriginY-this._offsetY+this._stepY;if(It){const We=[[Bt,de],[Bt,Le],[xe,de],[xe,Le]];Bt=de=Number.MAX_VALUE,xe=Le=-Number.MAX_VALUE;for(const Re of We){const Pe=this._cosAngle*Re[0]-this._sinAngle*Re[1],Ee=this._sinAngle*Re[0]+this._cosAngle*Re[1];Bt=Math.min(Bt,Pe),xe=Math.max(xe,Pe),de=Math.min(de,Ee),Le=Math.max(Le,Ee)}}x=x!==Number.MAX_VALUE?Math.max(x,Bt):Bt,w=w!==Number.MAX_VALUE?Math.max(w,de):de,I=I!==-Number.MAX_VALUE?Math.min(I,xe):xe,E=E!==-Number.MAX_VALUE?Math.min(E,Le):Le}this._xMin=Math.round(x/this._stepX),this._xMax=Math.round(I/this._stepX),this._yMin=Math.round(w/this._stepY),this._yMax=Math.round(E/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1,this._testInsidePolygon&&Vt>12&&(re>25||ne>25)&&this._buildAccelerationMap(e,ot,dt,tt,Z)}_buildAccelerationMap(e,i,n,M,a){const{rings:r}=e,P=new Map,x=this._verticalSubdivision,w=x?a-M:n-i;let I=Math.ceil(w/10);if(I<=1)return;const E=Math.floor(w/I);let tt,Z,ot,dt,It,Vt,re,ne,Bt,xe;I++,this._delta=E,x?(ne=-u-this._stepY,Bt=this._stepY,xe=M):(ne=-this._stepX,Bt=u+this._stepX,xe=i);for(let de=0;de<r.length;de++)if(tt=r[de],!(tt.length<2))for(let Le=1;Le<tt.length;Le++){if(Z=tt[Le-1],ot=tt[Le],x){if(Z[1]===ot[1]||Z[1]<ne&&ot[1]<ne||Z[1]>Bt&&ot[1]>Bt)continue;dt=Math.min(Z[1],ot[1]),It=Math.max(Z[1],ot[1])}else{if(Z[0]===ot[0]||Z[0]<ne&&ot[0]<ne||Z[0]>Bt&&ot[0]>Bt)continue;dt=Math.min(Z[0],ot[0]),It=Math.max(Z[0],ot[0])}for(;dt<It;)Vt=Math.floor((dt-xe)/E),xt(Vt,de,Le,P),dt+=E;re=Math.floor((It-xe)/E),re>Vt&&xt(re,de,Le,P)}this._accelerationMap=P}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let e=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(e+=.5*this._stepX);const i=this._currentY*this._stepY+this._offsetY;let n,M;if(this._currentX++,this._gridType===q.bj.Random){const a=(this._currentX%W+W)%W,r=(this._currentY%W+W)%W;n=this._graphicOriginX+e+this._stepX*this._randomness*(.5-nt._randValues[r*W+a])*2/3,M=this._graphicOriginY+i+this._stepY*this._randomness*(.5-nt._randValues[r*W+a+1])*2/3}else n=this._graphicOriginX+this._cosAngle*e+this._sinAngle*i,M=this._graphicOriginY-this._sinAngle*e+this._cosAngle*i;if(!this._testInsidePolygon||this._isInsidePolygon(n,M,this._geometry))return this._internalPlacement.setTranslate(n,M),this._internalPlacement}}_isInsidePolygon(e,i,n){const{rings:M}=n;if((0,Et.Wi)(this._accelerationMap))return function st(v,e,i){const{rings:n}=i;let M,a,r,P=0;for(const x of n){M=x.length;for(let w=1;w<M;++w)a=x[w-1],r=x[w],a[1]>e!=r[1]>e&&((r[0]-a[0])*(e-a[1])-(r[1]-a[1])*(v-a[0])>0?P++:P--)}return 0!==P}(e,i,n);const a=this._verticalSubdivision,P=Math.floor(((a?i:e)-this._polygonMin)/this._delta),x=this._accelerationMap.get(P);if(!x)return!1;let w,I,E,tt,Z,ot=0;for(const dt of x){Z=dt[0];const It=M[Z];if(tt=dt[1],w=It[tt-1],I=It[tt],a){if(w[1]>i==I[1]>i)continue;E=(I[0]-w[0])*(i-w[1])-(I[1]-w[1])*(e-w[0])}else{if(w[0]>e==I[0]>e)continue;E=(I[1]-w[1])*(e-w[0])-(I[0]-w[0])*(i-w[1])}E>0?ot++:ot--}return 0!==ot}}function xt(v,e,i,n){let M=n.get(v);M||(M=[],n.set(v,M)),M.push([e,i])}let Ht=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new Ot(i,n,M)}}return v.instance=null,v})();class Ot extends Ut.v1{constructor(e,i,n){super(e,!0,!0),this._curveHelper=new Lt,this._angleToLine=void 0===i.angleToLine||i.angleToLine,this._offset=void 0!==i.offset?i.offset*n:0,this._relativeTo=i.relativeTo,this._position=void 0!==i.startPointOffset?i.startPointOffset*n:0,this._epsilon=.001*n}processPath(e){const i=this._position;if(this._relativeTo===q.CS.SegmentMidpoint){for(this.iteratePath||(this._segmentCount=e.length,this._curSegment=1,this.iteratePath=!0);this._curSegment<this._segmentCount;){const M=this._curSegment;this._curSegment++;const a=e[M-1],r=e[M],P=this._curveHelper.calculateLength(a,r);if(P<this._epsilon)continue;const x=.5+this._position/P,[w,I]=this._curveHelper.getAngleCS(a,r,x),E=(0,Ut.XV)(a,r,x);return this.internalPlacement.setTranslate(E[0]-this._offset*I,E[1]+this._offset*w),this._angleToLine&&this.internalPlacement.setRotateCS(w,I),this.internalPlacement}return this.iteratePath=!1,null}this._relativeTo===q.CS.LineEnd&&(0,Ut.hh)(e);const n=this.onLine(e,i);return this._relativeTo===q.CS.LineEnd&&(0,Ut.hh)(e),n}onLine(e,i){let n,M=!1;switch(this._relativeTo){case q.CS.LineMiddle:default:n=this._curveHelper.calculatePathLength(e)/2+i;break;case q.CS.LineBeginning:n=i;break;case q.CS.LineEnd:n=i,M=!0}const a=e.length;let r,P=0,x=e[0];for(let w=1;w<a;++w){r=x,x=e[w];const I=this._curveHelper.calculateLength(r,x);if(P+I>n){const E=(n-P)/I,[tt,Z]=this._curveHelper.getAngleCS(r,x,E),ot=(0,Ut.XV)(r,x,E),dt=M?-this._offset:this._offset;return this.internalPlacement.setTranslate(ot[0]-dt*Z,ot[1]+dt*tt),this._angleToLine&&(M?this.internalPlacement.setRotateCS(-tt,-Z):this.internalPlacement.setRotateCS(tt,Z)),this.internalPlacement}P+=I}return null}}let Nt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new Qt(i,n,M)}}return v.instance=null,v})();const le=1e-15;class Qt extends Ut.v1{constructor(e,i,n){super(e,!0,!0),this._curveHelper=new Lt,this._angleToLine=void 0===i.angleToLine||i.angleToLine,this._offset=void 0!==i.offset?i.offset*n:0,this._endPoints=void 0===i.placeOnEndPoints||i.placeOnEndPoints,this._controlPoints=void 0===i.placeOnControlPoints||i.placeOnControlPoints,this._regularVertices=void 0===i.placeOnRegularVertices||i.placeOnRegularVertices,this._tags=[],this._tagIterator=0}processPath(e){if(this.iteratePath||(this._preparePath(e),this.iteratePath=!0),this._tagIterator>=this._tags.length)return this._tags.length=0,this._tagIterator=0,this.iteratePath=!1,null;const i=this._tags[this._tagIterator];this._angleToLine&&this.internalPlacement.setRotate(i[2]);let n=i[0],M=i[1];if(0!==this._offset){const a=Math.cos(i[2]),r=Math.sin(i[2]);n-=this._offset*r,M+=this._offset*a}return this.internalPlacement.setTranslate(n,M),this._tagIterator++,this.internalPlacement}_preparePath(e){this._tags.length=0,this._tagIterator=0;const i=(0,Ut.QK)(e),n=e.length-1;let M,a,r=0,P=0,x=0,w=0,I=0;for(;r<n;){r++,M=e[r-1],a=e[r];const E=(0,Ut.zv)(M),tt=(0,Ut.zv)(a);(this._angleToLine||0!==this._offset)&&(w=this._curveHelper.getAngle(M,a,0)),1===r?i?(P=w,x=E):(this._endPoints||this._controlPoints&&1===E)&&this._tags.push([M[0],M[1],w]):1===E?this._controlPoints&&this._tags.push([M[0],M[1],Jt(I,w)]):this._regularVertices&&this._tags.push([M[0],M[1],Jt(I,w)]),(this._angleToLine||0!==this._offset)&&(I=this._curveHelper.getAngle(M,a,1)),r===n&&(i?1===tt||1===x?this._controlPoints&&this._tags.push([a[0],a[1],Jt(I,P)]):this._regularVertices&&this._tags.push([a[0],a[1],Jt(I,P)]):(this._endPoints||this._controlPoints&&1===tt)&&this._tags.push([a[0],a[1],I]))}this._tagIterator=0}}function Jt(v,e){const i=Math.PI;for(;Math.abs(e-v)>i+2*le;)e-v>i?e-=2*i:e+=2*i;return(v+e)/2}var ie=ut(8314),ue=ut(27105);class be{constructor(e=Me){this._data=[],this._compare=e}get size(){return this._data.length}enqueue(e){if(null==e)return;const{_data:i,_compare:n}=this;i.push(e);let M=i.length-1>>>0;const a=i[M];for(;M>0;){const r=M-1>>1,P=i[r];if(!(n(P,a)<=0))break;i[r]=a,i[M]=P,M=r}}dequeue(){const{_data:e,_compare:i}=this,n=e[0],M=e.pop();if(0===e.length)return n;e[0]=M;let a=0;const r=e.length,P=e[0];let x,w,I=null;for(;;){const E=2*a+1,tt=2*a+2;if(I=null,E<r&&(x=e[E],i(x,P)>0&&(I=E)),tt<r&&(w=e[tt],(null===I&&i(w,P)<=0||null!==I&&i(w,x)<=0)&&(I=tt)),null===I)break;e[a]=e[I],e[I]=P,a=I}return n}}const Me=(v,e)=>v<e?-1:v>e?1:0;var fe=ut(25748),we=ut(11519);function _e(v,e){const{rings:i}=e;let n=0;for(const M of i){const a=M.length;for(let r=1;r<a;++r){const P=M[r-1],x=M[r];P[1]>v[1]!=x[1]>v[1]&&((x[0]-P[0])*(v[1]-P[1])-(x[1]-P[1])*(v[0]-P[0])>0?n++:n--)}}return 0!==n}function me(v,e,i){if(i&&_e(v,e))return{coord:v,distance:0};let n=1/0,M=0,a=0;const r=[0,0],{rings:P}=e;for(const x of P)if(!(x.length<2))for(let w=0;w<x.length-1;w++){(0,fe.Tx)(r,v,x,w);const I=ye(v,r);I<n&&(n=I,M=r[0],a=r[1])}return{coord:[M,a],distance:Math.sqrt(n)}}function ve(v,e,i,n){const M=[e,0];let a=1/0,r=1/0,P=!1,x=!1;const w=[[e,n[1]-1],[e,n[3]+1]],I=[0,0],E=[0,0],tt=[0,0],Z=[[0,0],[0,0]],ot=(0,Y.Ue)(),{rings:dt}=v;for(const It of dt)if(!(It.length<2))for(let Vt=1;Vt<It.length;Vt++){if(Z[0][0]=It[Vt-1][0],Z[0][1]=It[Vt-1][1],Z[1][0]=It[Vt][0],Z[1][1]=It[Vt][1],null===ze(ot,Z)||(E[0]=w[0][0],E[1]=w[0][1],tt[0]=w[1][0],tt[1]=w[1][1],0===Oe(ot,E,tt))||!(0,we.UT)(w[0],w[1],Z[0],Z[1],I))continue;const re=I[1];a>r?re<a&&(a=re,P=!0):re<r&&(r=re,x=!0)}return P&&x?M[1]=(a+r)/2:M[0]=M[1]=NaN,M}function ze(v,e){if(e.length<2)return null;v||(v=(0,Y.Ue)());const[i,n]=e[0],[M,a]=e[1];return v[0]=Math.min(i,M),v[1]=Math.min(n,a),v[2]=Math.max(i,M),v[3]=Math.max(n,a),v}const Ae=1,Ne=4,Fe=3,Ue=12;function Oe(v,e,i){let n=ke(e,v),M=ke(i,v);const a=v[0],r=v[1],P=v[2],x=v[3];if(n&M)return 0;if(!(n|M))return 4;const w=(n?1:0)|(M?2:0);do{const I=i[0]-e[0],E=i[1]-e[1];if(I>E)n&Fe?(n&Ae?(e[1]+=E*(a-e[0])/I,e[0]=a):(e[1]+=E*(P-e[0])/I,e[0]=P),n=ke(e,v)):M&Fe?(M&Ae?(i[1]+=E*(a-i[0])/I,i[0]=a):(i[1]+=E*(P-i[0])/I,i[0]=P),M=ke(i,v)):n?(n&Ne?(e[0]+=I*(r-e[1])/E,e[1]=r):(e[0]+=I*(x-e[1])/E,e[1]=x),n=ke(e,v)):(M&Ne?(i[0]+=I*(r-i[1])/E,i[1]=r):(i[0]+=I*(x-i[1])/E,i[1]=x),M=ke(i,v));else if(n&Ue?(n&Ne?(e[0]+=I*(r-e[1])/E,e[1]=r):(e[0]+=I*(x-e[1])/E,e[1]=x),n=ke(e,v)):M&Ue?(M&Ne?(i[0]+=I*(r-i[1])/E,i[1]=r):(i[0]+=I*(x-i[1])/E,i[1]=x),M=ke(i,v)):n?(n&Ae?(e[1]+=E*(a-e[0])/I,e[0]=a):(e[1]+=E*(P-e[0])/I,e[0]=P),n=ke(e,v)):(M&Ae?(i[1]+=E*(a-i[0])/I,i[0]=a):(i[1]+=E*(P-i[0])/I,i[0]=P),M=ke(i,v)),n&M)return 0}while(n|M);return w}function ke(v,e){return(v[0]<e[0]?1:0)|(v[0]>e[2]?1:0)<<1|(v[1]<e[1]?1:0)<<2|(v[1]>e[3]?1:0)<<3}function Ge(v,e,i){return v+(e-v)*i}function ye(v,e){return(v[0]-e[0])*(v[0]-e[0])+(v[1]-e[1])*(v[1]-e[1])}function De(v,e){if(v<e)return-1;if(v>e)return 1;if(v===e)return 0;const i=isNaN(v),n=isNaN(e);return i<n?-1:i>n?1:0}class Se{constructor(e,i,n,M){this.x=e,this.y=i,this.cellSize=n,this.distancefromCellCenter=(0,fe.ko)(e,i,M),this.maxDistanceToPolygon=this.distancefromCellCenter+this.cellSize*Math.SQRT2}}let je=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,M,a,r){return new Je(i,n,M)}}return v.instance=null,v})();class Je{constructor(e,i,n){this._geometry=e,this._offsetX=void 0!==i.offsetX?i.offsetX*n:0,this._offsetY=void 0!==i.offsetY?i.offsetY*n:0,this._method=void 0!==i.method?i.method:q.Lh.OnPolygon,this._internalPlacement=new F.u}next(){const e=this._geometry;return this._geometry=null,e&&function Ie(v){return void 0!==v.rings}(e)?this._polygonCenter(e):null}_polygonCenter(e){let i=!1;switch(this._method){case q.Lh.CenterOfMass:{const n=(0,ue.NA)(e);n&&(this._internalPlacement.setTranslate(n[0]+this._offsetX,n[1]+this._offsetY),i=!0)}break;case q.Lh.BoundingBoxCenter:{const n=(0,Y.Ue)();(0,A.$P)(n,e),n&&(this._internalPlacement.setTranslate((n[2]+n[0])/2+this._offsetX,(n[3]+n[1])/2+this._offsetY),i=!0)}break;default:{let n;n=(0,ie.Z)("polylabel-placement-enabled")?function He(v){if(!v||!v.rings||0===v.rings.length)return null;const e=(0,A.lC)((0,Y.Ue)(),v.rings[0]);if(!e)return null;const i=e[2]-e[0],n=e[3]-e[1];if(0===i||0===n)return[e[0]+i/2,e[1]+n/2];const M=Math.max(Math.min(i,n)/100,1),a=new be((Z,ot)=>ot.maxDistanceToPolygon-Z.maxDistanceToPolygon),r=Math.min(i,n);let P=r/2,x=0,w=0;for(x=e[0];x<e[2];x+=r)for(w=e[1];w<e[3];w+=r)a.enqueue(new Se(x+P,w+P,P,v));const I=(0,ue.a)(v.rings,!1);if(null===I)return null;let E,tt=new Se(I[0],I[1],0,v);for(;a.size>0;)E=(0,Et.Wg)(a.dequeue()),E.distancefromCellCenter>tt.distancefromCellCenter&&(tt=E),E.maxDistanceToPolygon-tt.distancefromCellCenter<=M||(P=E.cellSize/2,a.enqueue(new Se(E.x-P,E.y-P,P,v)),a.enqueue(new Se(E.x+P,E.y-P,P,v)),a.enqueue(new Se(E.x-P,E.y+P,P,v)),a.enqueue(new Se(E.x+P,E.y+P,P,v)));return[tt.x,tt.y]}(e):function Ce(v){const{rings:e}=v;if(!e||0===e.length)return null;const i=(0,A.$P)((0,Y.Ue)(),v);if(!i)return null;const n=4*(Math.abs(i[0])+Math.abs(i[2])+Math.abs(i[1])+Math.abs(i[3])+1)*222045e-19;let M=0,a=0;for(let Pe=0;Pe<e.length;Pe++){const Ee=(0,fe.Sm)(e[Pe]);Ee>a&&(a=Ee,M=Pe)}if(Math.abs(a)<=2*n*n){const Pe=(0,A.lC)((0,Y.Ue)(),e[M]);return[(Pe[0]+Pe[2])/2,(Pe[1]+Pe[3])/2]}const r=(0,ue.DS)(e[M],!1,(0,Y.Ue)());if(null===r)return null;if(1===e.length&&e[0].length<4)return r;const P=[[NaN,NaN],[NaN,NaN],[NaN,NaN],[NaN,NaN]],x=[NaN,NaN,NaN,NaN],w=[NaN,NaN,NaN,NaN];let I=!1,E=me(r,v,!0);0===E.distance&&(I=!0,P[0][0]=r[0],P[0][1]=r[1],E=me(r,v,!1)),x[0]=E.distance,w[0]=0;const tt=[NaN,NaN];let Z=!1,ot=.25,dt=-1;const It=(0,A.lC)((0,Y.Ue)(),e[M]);let Vt=NaN;do{if(Vt=NaN,P[1]=ve(v,Ge(It[0],It[2],ot),0,i),isNaN(P[1][0])||isNaN(P[1][1])||(E=me(P[1],v,!1),Vt=E.distance),!isNaN(Vt)&&Vt>n&&_e(P[1],v))Z=!0,x[1]=Vt,w[1]=ye(P[1],r);else if(!isNaN(Vt)&&Vt>dt&&(dt=Vt,tt[0]=P[1][0],tt[1]=P[1][1]),ot-=.01,ot<.1){if(!(dt>=0))break;Z=!0,x[1]=dt,P[1][0]=tt[0],P[1][1]=tt[1],w[1]=ye(P[1],r)}}while(!Z);Z=!1,ot=.5,dt=-1;let re=.01,ne=1;do{if(Vt=NaN,P[2]=ve(v,Ge(It[0],It[2],ot),0,i),isNaN(P[2][0])||isNaN(P[2][1])||(E=me(P[2],v,!1),Vt=E.distance),!isNaN(Vt)&&Vt>n&&_e(P[2],v))Z=!0,x[2]=Vt,w[2]=ye(P[2],r);else if(!isNaN(Vt)&&Vt>dt)dt=Vt,tt[0]=P[2][0],tt[1]=P[2][1];else if(Vt>dt&&(dt=Vt,tt[0]=P[2][0],tt[1]=P[2][1]),ot=.5+re*ne,re+=.01,ne*=-1,ot<.3||ot>.7){if(!(dt>=0))break;Z=!0,x[2]=dt,P[2][0]=tt[0],P[2][1]=tt[1],w[2]=ye(P[2],r)}}while(!Z);Z=!1,ot=.75,dt=-1;do{if(Vt=NaN,P[3]=ve(v,Ge(It[0],It[2],ot),0,i),isNaN(P[3][0])||isNaN(P[3][1])||(E=me(P[3],v,!1),Vt=E.distance),!isNaN(Vt)&&Vt>n&&_e(P[3],v))Z=!0,x[3]=Vt,w[3]=ye(P[3],r);else if(Vt>dt&&(dt=Vt,tt[0]=P[3][0],tt[1]=P[3][1]),ot+=.01,ot>.9){if(!(dt>=0))break;Z=!0,x[3]=dt,P[3][0]=tt[0],P[3][1]=tt[1],w[3]=ye(P[3],r)}}while(!Z);const Bt=[0,1,2,3],xe=I?0:1;let de;for(let Pe=xe;Pe<4;Pe++)for(let Ee=xe;Ee<3;Ee++){const Ye=w[Ee],Ve=w[Ee+1];De(Ye,Ve)>0&&(de=Bt[Ee],Bt[Ee]=Bt[Ee+1],Bt[Ee+1]=de,w[Ee]=Ve,w[Ee+1]=Ye)}let Le=xe,We=0,Re=0;for(let Pe=xe;Pe<4;Pe++){switch(Pe){case 0:Re=2*x[Bt[Pe]];break;case 1:Re=1.66666666*x[Bt[Pe]];break;case 2:Re=1.33333333*x[Bt[Pe]];break;case 3:Re=x[Bt[Pe]]}Re>We&&(We=Re,Le=Bt[Pe])}return P[Le]}(e),null!==n&&(this._internalPlacement.setTranslate(n[0]+this._offsetX,n[1]+this._offsetY),i=!0)}}return i?this._internalPlacement:null}}function $e(v){if(!v)return null;switch(v.type){case"CIMGeometricEffectAddControlPoints":return zt.local();case"CIMGeometricEffectArrow":return Kt.local();case"CIMGeometricEffectBuffer":return jt.local();case"CIMGeometricEffectControlMeasureLine":return se.local();case"CIMGeometricEffectCut":return it.local();case"CIMGeometricEffectDashes":return yt.local();case"CIMGeometricEffectDonut":return Pt.local();case"CIMGeometricEffectJog":return Ft.local();case"CIMGeometricEffectMove":return Zt.local();case"CIMGeometricEffectOffset":return ce.local();case"CIMGeometricEffectReverse":return y.local();case"CIMGeometricEffectRotate":return j.local();case"CIMGeometricEffectScale":return K.local();case"CIMGeometricEffectWave":return Tt.local()}return null}function Ke(v){if(!v)return null;switch(v.type){case"CIMMarkerPlacementAlongLineSameSize":return S.local();case"CIMMarkerPlacementAtExtremities":return N.local();case"CIMMarkerPlacementAtRatioPositions":return O.local();case"CIMMarkerPlacementInsidePolygon":return rt.local();case"CIMMarkerPlacementOnLine":return Ht.local();case"CIMMarkerPlacementOnVertices":return Nt.local();case"CIMMarkerPlacementPolygonCenter":return je.local()}return null}},97373:(Te,pe,ut)=>{ut.d(pe,{u:()=>Wt});class Wt{constructor(){this.setIdentity()}getAngle(){return(null==this.rz||0===this.rz&&1!==this.rzCos&&0!==this.rzSin)&&(this.rz=Math.atan2(this.rzSin,this.rzCos)),this.rz}setIdentity(){this.tx=0,this.ty=0,this.tz=0,this.s=1,this.rx=0,this.ry=0,this.rz=0,this.rzCos=1,this.rzSin=0}setTranslate(zt,oe){this.tx=zt,this.ty=oe}setTranslateZ(zt){this.tz=zt}setRotateCS(zt,oe){this.rz=void 0,this.rzCos=zt,this.rzSin=oe}setRotate(zt){this.rz=zt,this.rzCos=void 0,this.rzSin=void 0}setRotateY(zt){this.ry=zt}setScale(zt){this.s=zt}setMeasure(zt){this.m=zt}}},26933:(Te,pe,ut)=>{ut.d(pe,{cD:()=>yt,uQ:()=>Rt,zA:()=>Dt}),ut(986);var gt=ut(17002),Ut=ut(58817),zt=ut(63290),oe=ut(62208),q=ut(27899),At=ut(23841),Mt=ut(65401),Lt=ut(32442),_t=ut(27105),St=ut(91179),Xt=ut(29214);class Kt{applyColorSubstituition(y,k){if(!k)return y;this._rasterizationCanvas||(this._rasterizationCanvas=document.createElement("canvas"));const{width:Y,height:A}=y,j=this._rasterizationCanvas,ht=j.getContext("2d");y!==j&&(j.width=Y,j.height=A,ht.drawImage(y,0,0,Y,A));const K=ht.getImageData(0,0,Y,A).data;if(k)for(const Tt of k)if(Tt&&Tt.oldColor&&4===Tt.oldColor.length&&Tt.newColor&&4===Tt.newColor.length){const[T,S,L,N]=Tt.oldColor,[J,O,$,lt]=Tt.newColor;if(T===J&&S===O&&L===$&&N===lt)continue;for(let F=0;F<K.length;F+=4)T===K[F]&&S===K[F+1]&&L===K[F+2]&&N===K[F+3]&&(K[F]=J,K[F+1]=O,K[F+2]=$,K[F+3]=lt)}const bt=new ImageData(K,Y,A);return ht.putImageData(bt,0,0),j}tintImageData(y,k){if(!k||k.length<4)return y;this._rasterizationCanvas||(this._rasterizationCanvas=document.createElement("canvas"));const{width:Y,height:A}=y,j=this._rasterizationCanvas,ht=j.getContext("2d");y!==j&&(j.width=Y,j.height=A,ht.drawImage(y,0,0,Y,A));const K=ht.getImageData(0,0,Y,A),bt=new Uint8Array(K.data),Tt=[k[0]/255,k[1]/255,k[2]/255,k[3]/255];for(let S=0;S<bt.length;S+=4)bt[S+0]*=Tt[0],bt[S+1]*=Tt[1],bt[S+2]*=Tt[2],bt[S+3]*=Tt[3];const T=new ImageData(new Uint8ClampedArray(bt.buffer),Y,A);return ht.putImageData(T,0,0),j}}var et=ut(95727),at=ut(97373),Et=ut(7547);function Q(wt){const y=wt.getFrame(0);if(y instanceof HTMLImageElement||y instanceof HTMLCanvasElement)return y;const k=document.createElement("canvas");k.width=wt.width,k.height=wt.height;const Y=k.getContext("2d");return y instanceof ImageData?Y.putImageData(y,0,0):Y.drawImage(y,0,0),k}var $t=ut(31375),jt=ut(68937),Yt=ut(80991);ut(40028),ut(39351),ut(25797);const Ct=Math.PI/180,qt=zt.Z.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");class Dt{constructor(y){this._t=y}static createIdentity(){return new Dt([1,0,0,0,1,0])}clone(){return new Dt(this._t.slice())}transform(y){const k=this._t;return[k[0]*y[0]+k[1]*y[1]+k[2],k[3]*y[0]+k[4]*y[1]+k[5]]}static createScale(y,k){return new Dt([y,0,0,0,k,0])}scale(y,k){const Y=this._t;return Y[0]*=y,Y[1]*=y,Y[2]*=y,Y[3]*=k,Y[4]*=k,Y[5]*=k,this}scaleRatio(){return Math.sqrt(this._t[0]*this._t[0]+this._t[1]*this._t[1])}static createTranslate(y,k){return new Dt([0,0,y,0,0,k])}translate(y,k){const Y=this._t;return Y[2]+=y,Y[5]+=k,this}static createRotate(y){const k=Math.cos(y),Y=Math.sin(y);return new Dt([k,-Y,0,Y,k,0])}rotate(y){return Dt.multiply(this,Dt.createRotate(y),this)}angle(){const y=this._t[0],k=this._t[3],Y=Math.sqrt(y*y+k*k);return[y/Y,k/Y]}static multiply(y,k,Y){const A=y._t,j=k._t,K=A[1]*j[0]+A[4]*j[1],bt=A[2]*j[0]+A[5]*j[1]+j[2],Tt=A[0]*j[3]+A[3]*j[4],T=A[1]*j[3]+A[4]*j[4],S=A[2]*j[3]+A[5]*j[4]+j[5],L=Y._t;return L[0]=A[0]*j[0]+A[3]*j[1],L[1]=K,L[2]=bt,L[3]=Tt,L[4]=T,L[5]=S,Y}invert(){const y=this._t;let k=y[0]*y[4]-y[1]*y[3];return 0===k?new Dt([0,0,0,0,0,0]):(k=1/k,new Dt([y[4]*k,-y[1]*k,(y[1]*y[5]-y[2]*y[4])*k,-y[3]*k,y[0]*k,(y[2]*y[3]-y[0]*y[5])*k]))}}class ee{constructor(y,k){this._resourceManager=y,this._transfos=[],this._sizeTransfos=[],this._geomUnitsPerPoint=1,this._placementPool=new q.Z(at.u,void 0,void 0,100),this._earlyReturn=!1,this._mapRotation=0,this._transfos.push(k||Dt.createIdentity()),this._sizeTransfos.push(k?k.scaleRatio():1)}setTransform(y,k){this._transfos=[y||Dt.createIdentity()],this._sizeTransfos=[k||(y?y.scaleRatio():1)]}setGeomUnitsPerPoint(y){this._geomUnitsPerPoint=y}transformPt(y){return this._transfos[this._transfos.length-1].transform(y)}transformSize(y){return y*this._sizeTransfos[this._sizeTransfos.length-1]}reverseTransformPt(y){return this._transfos[this._transfos.length-1].invert().transform(y)}reverseTransformSize(y){return y/this._sizeTransfos[this._sizeTransfos.length-1]}getTransformAngle(){return this._transfos[this._transfos.length-1].angle()}geomUnitsPerPoint(){return this.isEmbedded()?1:this._geomUnitsPerPoint}isEmbedded(){return this._transfos.length>1}back(){return this._transfos[this._transfos.length-1]}push(y,k){const Y=k?y.scaleRatio():1;Dt.multiply(y,this.back(),y),this._transfos.push(y),this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length-1]*Y)}pop(){this._transfos.splice(-1,1),this._sizeTransfos.splice(-1,1)}drawSymbol(y,k,Y){if(y)switch(y.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":this.drawMultiLayerSymbol(y,k);break;case"CIMTextSymbol":this.drawTextSymbol(y,k,Y)}}drawMultiLayerSymbol(y,k){if(!y||!k)return;const Y=y.symbolLayers;if(!Y)return;const A=y.effects;if(A&&A.length>0){const j=this.executeEffects(A,k);if(j){let ht=j.next();for(;ht;)this.drawSymbolLayers(Y,ht),ht=j.next()}}else this.drawSymbolLayers(Y,k)}executeEffects(y,k){const Y=this._resourceManager.geometryEngine;let A=new Xt.MU(k);for(const j of y){const ht=(0,et.h)(j);ht&&(A=ht.execute(A,j,this.geomUnitsPerPoint(),null,Y))}return A}drawSymbolLayers(y,k){let Y=y.length;for(;Y--;){const A=y[Y];if(!A||!1===A.enable)continue;const j=A.effects;if(j&&j.length>0){const ht=this.executeEffects(j,k);if(ht){let K=null;for(;(K=ht.next())&&(this.drawSymbolLayer(A,K),!this._earlyReturn););}}else this.drawSymbolLayer(A,k);if(this._earlyReturn)return}}drawSymbolLayer(y,k){switch(y.type){case"CIMSolidFill":this.drawSolidFill(k,y.color);break;case"CIMHatchFill":this.drawHatchFill(k,y);break;case"CIMPictureFill":this.drawPictureFill(k,y);break;case"CIMGradientFill":this.drawGradientFill(k,y);break;case"CIMSolidStroke":this.drawSolidStroke(k,y.color,y.width,y.capStyle,y.joinStyle,y.miterLimit);break;case"CIMPictureStroke":this.drawPictureStroke(k,y);break;case"CIMGradientStroke":this.drawGradientStroke(k,y);break;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":this.drawMarkerLayer(y,k)}}drawHatchFill(y,k){const Y=this._buildHatchPolyline(k,y,this.geomUnitsPerPoint());Y&&(this.pushClipPath(y),this.drawMultiLayerSymbol(k.lineSymbol,Y),this.popClipPath())}drawPictureFill(y,k){}drawGradientFill(y,k){}drawPictureStroke(y,k){}drawGradientStroke(y,k){}drawMarkerLayer(y,k){const Y=y.markerPlacement;if(Y){const A=(0,et.W)(Y);if(A){const j="CIMMarkerPlacementInsidePolygon"===Y.type||"CIMMarkerPlacementPolygonCenter"===Y.type&&Y.clipAtBoundary;j&&this.pushClipPath(k);const ht=A.execute(k,Y,this.geomUnitsPerPoint(),null,this._resourceManager.geometryEngine);if(ht){let K=null;for(;(K=ht.next())&&(this.drawMarker(y,K),!this._earlyReturn););}j&&this.popClipPath()}}else{const A=this._placementPool.acquire();if((0,St.wp)(k))A.tx=k.x,A.ty=k.y,this.drawMarker(y,A);else if((0,St.oU)(k)){const j=(0,_t.tO)(k);j&&([A.tx,A.ty]=j,this.drawMarker(y,A))}else for(const j of k.points)if(A.tx=j[0],A.ty=j[1],this.drawMarker(y,A),this._earlyReturn)break;this._placementPool.release(A)}}drawMarker(y,k){switch(y.type){case"CIMCharacterMarker":case"CIMPictureMarker":this.drawPictureMarker(y,k);break;case"CIMVectorMarker":this.drawVectorMarker(y,k)}}drawPictureMarker(y,k){if(!y)return;const Y=this._resourceManager.getResource(y.url),A=y.size??10;if((0,oe.Wi)(Y)||A<=0)return;const j=Y.width,ht=Y.height;if(!j||!ht)return;const K=j/ht,bt=y.scaleX??1,Tt=Dt.createIdentity(),T=y.anchorPoint;if(T){let $=T.x,lt=T.y;"Absolute"!==y.anchorPointUnits&&($*=A*K*bt,lt*=A),Tt.translate(-$,-lt)}let S=y.rotation??0;y.rotateClockwise&&(S=-S),this._mapRotation&&(S+=this._mapRotation),S&&Tt.rotate(S*Ct);let L=y.offsetX??0,N=y.offsetY??0;if(L||N){if(this._mapRotation){const $=Ct*this._mapRotation,lt=Math.cos($),F=Math.sin($),u=L*F+N*lt;L=L*lt-N*F,N=u}Tt.translate(L,N)}const J=this.geomUnitsPerPoint();1!==J&&Tt.scale(J,J);const O=k.getAngle();O&&Tt.rotate(O),Tt.translate(k.tx,k.ty),this.push(Tt,!1),this.drawImage(y,A),this.pop()}drawVectorMarker(y,k){if(!y)return;const Y=y.markerGraphics;if(!Y)return;const A=y.size??10,j=y.frame,ht=j?j.ymax-j.ymin:0,K=A&&ht?A/ht:1,bt=Dt.createIdentity();j&&bt.translate(.5*-(j.xmax+j.xmin),.5*-(j.ymax+j.ymin));const Tt=y.anchorPoint;if(Tt){let O=Tt.x,$=Tt.y;"Absolute"!==y.anchorPointUnits?j&&(O*=j.xmax-j.xmin,$*=j.ymax-j.ymin):(O/=K,$/=K),bt.translate(-O,-$)}1!==K&&bt.scale(K,K);let T=y.rotation??0;y.rotateClockwise&&(T=-T),this._mapRotation&&(T+=this._mapRotation),T&&bt.rotate(T*Ct);let S=y.offsetX??0,L=y.offsetY??0;if(S||L){if(this._mapRotation){const O=Ct*this._mapRotation,$=Math.cos(O),lt=Math.sin(O),F=S*lt+L*$;S=S*$-L*lt,L=F}bt.translate(S,L)}const N=this.geomUnitsPerPoint();1!==N&&bt.scale(N,N);const J=k.getAngle();J&&bt.rotate(J),bt.translate(k.tx,k.ty),this.push(bt,y.scaleSymbolsProportionally);for(const O of Y)if(O&&O.symbol&&O.geometry||qt.error("Invalid marker graphic",O),this.drawSymbol(O.symbol,O.geometry,O.textString),this._earlyReturn)break;this.pop()}drawTextSymbol(y,k,Y){if(!y||!(0,St.wp)(k)||(y.height??10)<=0)return;const A=Dt.createIdentity();let j=y.angle??0;j=-j,j&&A.rotate(j*Ct);const ht=y.offsetX??0,K=y.offsetY??0;(ht||K)&&A.translate(ht,K);const bt=this.geomUnitsPerPoint();1!==bt&&A.scale(bt,bt),A.translate(k.x,k.y),this.push(A,!1),this.drawText(y,Y),this.pop()}_buildHatchPolyline(y,k,Y){let A=(void 0!==y.separation?y.separation:4)*Y,j=void 0!==y.rotation?y.rotation:0;if(0===A)return null;A<0&&(A=-A);let ht=0;const K=.5*A;for(;ht>K;)ht-=A;for(;ht<-K;)ht+=A;const bt=(0,Mt.Ue)();(0,Lt.$P)(bt,k),bt[0]-=K,bt[1]-=K,bt[2]+=K,bt[3]+=K;const Tt=[[bt[0],bt[1]],[bt[0],bt[3]],[bt[2],bt[3]],[bt[2],bt[1]]];for(;j>180;)j-=180;for(;j<0;)j+=180;const T=Math.cos(j*Ct),S=Math.sin(j*Ct),L=-A*S,N=A*T;let J,O,$,lt;ht=(void 0!==y.offsetX?y.offsetX*Y:0)*S-(void 0!==y.offsetY?y.offsetY*Y:0)*T,J=$=Number.MAX_VALUE,O=lt=-Number.MAX_VALUE;for(const mt of Tt){const rt=mt[0],nt=mt[1],st=T*rt+S*nt,xt=-S*rt+T*nt;J=Math.min(J,st),$=Math.min($,xt),O=Math.max(O,st),lt=Math.max(lt,xt)}$=Math.floor($/A)*A;let F=T*J-S*$-L*ht/A,u=S*J+T*$-N*ht/A,R=T*O-S*$-L*ht/A,U=S*O+T*$-N*ht/A;const ft=1+Math.round((lt-$)/A),W=[];for(let mt=0;mt<ft;mt++)F+=L,u+=N,R+=L,U+=N,W.push([[F,u],[R,U]]);return{paths:W}}}class Rt extends ee{constructor(y,k){super(y,k),this.reset()}reset(){this._xmin=this._ymin=1/0,this._xmax=this._ymax=-1/0,this._clipCount=0}envelope(){return new $t.Z(this._xmin,this._ymin,this._xmax-this._xmin,this._ymax-this._ymin)}bounds(){return(0,Mt.al)(this._xmin,this._ymin,this._xmax,this._ymax)}drawSolidFill(y){if(y&&!(this._clipCount>0))if((0,St.oU)(y))this._processPath(y.rings,0);else if((0,St.l9)(y))this._processPath(y.paths,0);else if((0,St.YX)(y)){const k=Pt(y);k&&this._processPath(k.rings,0)}else console.error("drawSolidFill Unexpected geometry type!")}drawSolidStroke(y,k,Y){if(!y||this._clipCount>0)return;const A=.5*this.transformSize(Y??0);if((0,St.oU)(y))this._processPath(y.rings,A);else if((0,St.l9)(y))this._processPath(y.paths,A);else if((0,St.YX)(y)){const j=Pt(y);j&&this._processPath(j.rings,A)}else console.error("drawSolidStroke unexpected geometry type!")}drawMarkerLayer(y,k){(0,St.oU)(k)&&y.markerPlacement&&("CIMMarkerPlacementInsidePolygon"===y.markerPlacement.type||"CIMMarkerPlacementPolygonCenter"===y.markerPlacement.type&&y.markerPlacement.clipAtBoundary)?this._processPath(k.rings,0):super.drawMarkerLayer(y,k)}drawHatchFill(y,k){this.drawSolidFill(y)}drawPictureFill(y,k){this.drawSolidFill(y)}drawGradientFill(y,k){this.drawSolidFill(y)}drawPictureStroke(y,k){this.drawSolidStroke(y,null,k.width)}drawGradientStroke(y,k){this.drawSolidStroke(y,null,k.width)}pushClipPath(y){this.drawSolidFill(y),this._clipCount++}popClipPath(){this._clipCount--}drawImage(y,k){const{url:Y}=y,A=y.scaleX??1;let j=A*k,ht=k;const K=this._resourceManager.getResource(Y);!k&&(0,oe.pC)(K)&&(j=A*K.width,ht=K.height),this._merge(this.transformPt([-j/2,-ht/2]),0),this._merge(this.transformPt([-j/2,ht/2]),0),this._merge(this.transformPt([j/2,-ht/2]),0),this._merge(this.transformPt([j/2,ht/2]),0)}drawText(y,k){if(!k||0===k.length)return;this._textRasterizer||(this._textRasterizer=new jt.Z);const Y=Zt(y),[A,j]=this._textRasterizer.computeTextSize(k,Y);let ht=0;switch(y.horizontalAlignment){case"Left":ht=A/2;break;case"Right":ht=-A/2}let K=0;switch(y.verticalAlignment){case"Bottom":K=j/2;break;case"Top":K=-j/2;break;case"Baseline":K=j/6}this._merge(this.transformPt([-A/2+ht,-j/2+K]),0),this._merge(this.transformPt([-A/2+ht,j/2+K]),0),this._merge(this.transformPt([A/2+ht,-j/2+K]),0),this._merge(this.transformPt([A/2+ht,j/2+K]),0)}_processPath(y,k){if(y)for(const Y of y){const A=Y?Y.length:0;if(A>1){this._merge(this.transformPt(Y[0]),k);for(let j=1;j<A;j++)this._merge(this.transformPt(Y[j]),k)}}}_merge(y,k){y[0]-k<this._xmin&&(this._xmin=y[0]-k),y[0]+k>this._xmax&&(this._xmax=y[0]+k),y[1]-k<this._ymin&&(this._ymin=y[1]-k),y[1]+k>this._ymax&&(this._ymax=y[1]+k)}}class yt extends ee{constructor(y,k,Y,A){super(k,Y),this._applyAdditionalRenderProps=A,this._colorSubstitutionHelper=new Kt,this._ctx=y}drawSolidFill(y,k){if(!y)return;if((0,St.oU)(y))this._buildPath(y.rings,!0);else if((0,St.l9)(y))this._buildPath(y.paths,!0);else if((0,St.YX)(y))this._buildPath(Pt(y).rings,!0);else{if(!(0,St.aW)(y))return;console.log("CanvasDrawHelper.drawSolidFill - No implementation!")}const Y=this._ctx;Y.fillStyle="string"==typeof k?k:"rgba("+Math.round(k[0])+","+Math.round(k[1])+","+Math.round(k[2])+","+(k[3]??255)/255+")",Y.fill("evenodd")}drawSolidStroke(y,k,Y,A,j,ht){if(!y||!k||0===Y)return;if((0,St.oU)(y))this._buildPath(y.rings,!0);else if((0,St.l9)(y))this._buildPath(y.paths,!1);else{if(!(0,St.YX)(y))return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");this._buildPath(Pt(y).rings,!0)}const K=this._ctx;K.strokeStyle="string"==typeof k?k:"rgba("+Math.round(k[0])+","+Math.round(k[1])+","+Math.round(k[2])+","+(k[3]??255)/255+")",K.lineWidth=Math.max(this.transformSize(Y),.5),this._setCapStyle(A),this._setJoinStyle(j),K.miterLimit=ht,K.stroke()}pushClipPath(y){if(this._ctx.save(),(0,St.oU)(y))this._buildPath(y.rings,!0);else if((0,St.l9)(y))this._buildPath(y.paths,!0);else{if(!(0,St.YX)(y))return;this._buildPath(Pt(y).rings,!0)}this._ctx.clip("evenodd")}popClipPath(){this._ctx.restore()}drawImage(y,k){const{colorSubstitutions:Y,url:A,tintColor:j}=y,ht=y.scaleX??1,K=this._resourceManager.getResource(A);if((0,oe.Wi)(K))return;let bt=k*(K.width/K.height),Tt=k;k||(bt=K.width,Tt=K.height);const T=(0,Yt.TB)(A)||"src"in K&&(0,Yt.TB)(K.src);let S="getFrame"in K?Q(K):K;Y&&(S=this._colorSubstitutionHelper.applyColorSubstituition(S,Y)),this._applyAdditionalRenderProps&&!T&&j&&(S=this._colorSubstitutionHelper.tintImageData(S,j));const L=this.transformPt([0,0]),[N,J]=this.getTransformAngle(),O=this.transformSize(1),$=this._ctx;$.save(),$.setTransform({m11:ht*O*N,m12:ht*O*J,m21:-O*J,m22:O*N,m41:L[0],m42:L[1]}),$.drawImage(S,-bt/2,-Tt/2,bt,Tt),$.restore()}drawText(y,k){if(!k||0===k.length)return;this._textRasterizer||(this._textRasterizer=new jt.Z);const Y=Zt(y);Y.size*=this.transformSize((0,At.Wz)(1));const A=this._textRasterizer.rasterizeText(k,Y);if(!A)return;const{size:j,anchorX:ht,anchorY:K,canvas:bt}=A,Tt=j[0]*(ht+.5),T=j[1]*(K-.5),S=this._ctx,L=this.transformPt([0,0]),[N,J]=this.getTransformAngle();S.save(),S.setTransform({m11:1*N,m12:1*J,m21:-1*J,m22:1*N,m41:L[0]-1*Tt,m42:L[1]+1*T}),S.drawImage(bt,0,0),S.restore()}drawPictureFill(y,k){if(!y)return;let{colorSubstitutions:Y,height:A,offsetX:j,offsetY:ht,rotation:K,scaleX:bt,tintColor:Tt,url:T}=k;const S=this._resourceManager.getResource(T);if((0,oe.Wi)(S))return;if((0,St.oU)(y))this._buildPath(y.rings,!0);else if((0,St.l9)(y))this._buildPath(y.paths,!0);else if((0,St.YX)(y))this._buildPath(Pt(y).rings,!0);else{if(!(0,St.aW)(y))return;console.log("CanvasDrawHelper.drawPictureFill - No implementation!")}const L=this._ctx,N=(0,Yt.TB)(T)||"src"in S&&(0,Yt.TB)(S.src);let J,O="getFrame"in S?Q(S):S;if(Y&&(O=this._colorSubstitutionHelper.applyColorSubstituition(O,Y)),this._applyAdditionalRenderProps){N||Tt&&(O=this._colorSubstitutionHelper.tintImageData(O,Tt)),J=L.createPattern(O,"repeat");const $=this.transformSize(1);K||(K=0),j?j*=$:j=0,ht?ht*=$:ht=0,A&&(A*=$);const lt=A?A/S.height:1,F=bt&&A?bt*A/S.width:1;if(0!==K||1!==lt||1!==F||0!==j||0!==ht){const u=new DOMMatrix;u.rotateSelf(0,0,-K).translateSelf(j,ht).scaleSelf(F,lt,1),J.setTransform(u)}}else J=L.createPattern(O,"repeat");L.save(),L.fillStyle=J,L.fill("evenodd"),L.restore()}drawPictureStroke(y,k){if(!y)return;let{colorSubstitutions:Y,capStyle:A,joinStyle:j,miterLimit:ht,tintColor:K,url:bt,width:Tt}=k;const T=this._resourceManager.getResource(bt);if((0,oe.Wi)(T))return;let S;if((0,St.oU)(y))S=y.rings;else if((0,St.l9)(y))S=y.paths;else{if(!(0,St.YX)(y))return(0,St.aW)(y)?void console.log("CanvasDrawHelper.drawPictureStroke - No implementation!"):void 0;S=Pt(y).rings}Tt||(Tt=T.width);const L=(0,Yt.TB)(bt)||"src"in T&&(0,Yt.TB)(T.src);let N="getFrame"in T?Q(T):T;Y&&(N=this._colorSubstitutionHelper.applyColorSubstituition(N,Y)),this._applyAdditionalRenderProps&&(L||K&&(N=this._colorSubstitutionHelper.tintImageData(N,K)));const J=Math.max(this.transformSize((0,At.F2)(Tt)),.5),O=J/N.width,$=this._ctx,lt=$.createPattern(N,"repeat-y");let F,u;$.save(),this._setCapStyle(A),this._setJoinStyle(j),void 0!==ht&&($.miterLimit=ht),$.lineWidth=J;for(let R of S)if(R=(0,Ut.d9)(R),ce(R),R&&!(R.length<=1)){F=this.transformPt(R[0]);for(let U=1;U<R.length;U++){u=this.transformPt(R[U]);const ft=pt(F,u),W=new DOMMatrix;W.translateSelf(0,F[1]-J/2).scaleSelf(O,O,1).rotateSelf(0,0,90-ft),lt.setTransform(W),$.strokeStyle=lt,$.beginPath(),$.moveTo(F[0],F[1]),$.lineTo(u[0],u[1]),$.stroke(),F=u}}$.restore()}_buildPath(y,k){const Y=this._ctx;if(Y.beginPath(),y)for(const A of y){const j=A?A.length:0;if(j>1){let ht=this.transformPt(A[0]);Y.moveTo(ht[0],ht[1]);for(let K=1;K<j;K++)ht=this.transformPt(A[K]),Y.lineTo(ht[0],ht[1]);k&&Y.closePath()}}}_setCapStyle(y){switch(y){case Et.kP.Butt:this._ctx.lineCap="butt";break;case Et.kP.Round:this._ctx.lineCap="round";break;case Et.kP.Square:this._ctx.lineCap="square"}}_setJoinStyle(y){switch(y){case Et.r4.Bevel:this._ctx.lineJoin="bevel";break;case Et.r4.Round:this._ctx.lineJoin="round";break;case Et.r4.Miter:this._ctx.lineJoin="miter"}}}function pt(wt,y){return 180/Math.PI*Math.atan2(y[1]-wt[1],y[0]-wt[0])}const Pt=wt=>wt?{spatialReference:wt.spatialReference,rings:[[[wt.xmin,wt.ymin],[wt.xmin,wt.ymax],[wt.xmax,wt.ymax],[wt.xmax,wt.ymin],[wt.xmin,wt.ymin]]]}:null;function Zt(wt,y=1){const k=(0,Yt.BX)(wt),Y=(0,Yt.wi)(wt.fontStyleName),A=(0,gt.BN)(wt.fontFamilyName),{weight:j,style:ht}=Y,K=y*(wt.height||5),bt=(0,Yt.X_)(wt.horizontalAlignment),Tt=(0,Yt.FG)(wt.verticalAlignment),T=(0,Yt.W7)(wt),S=(0,Yt.$Z)(wt.haloSymbol),L=S?y*(0|wt.haloSize):0;return{color:T,size:K,horizontalAlignment:bt,verticalAlignment:Tt,font:{family:A,style:(0,Yt.pJ)(ht),weight:(0,Yt.On)(j),decoration:k},halo:{size:L||0,color:S,style:ht},pixelRatio:1,premultiplyColors:!0}}const ae=1e-4;function ce(wt){let y,k,Y,A,j,ht=wt[0],K=1;for(;K<wt.length;)y=wt[K][0]-ht[0],k=wt[K][1]-ht[1],A=0!==y?k/y:Math.PI/2,void 0!==Y&&A-Y<=ae?(wt.splice(K-1,1),ht=j):(j=ht,ht=wt[K],K++),Y=A}},35909:(Te,pe,ut)=>{ut.d(pe,{B$:()=>vt,E0:()=>Ft,U1:()=>A});var Wt=ut(15861),gt=ut(91558),Ut=ut(986),zt=ut(58817),oe=ut(63290),q=ut(62208),At=ut(4619),Mt=ut(23841),St=(ut(65401),ut(32442),ut(46679)),Xt=ut(97373),Kt=ut(26933),et=ut(7547),at=ut(80991),Et=ut(39236),$t=(ut(86575),ut(39351));ut(25797);const Yt=Math.PI,se=Yt/2,Gt=96/72,Dt=(Math,oe.Z.getLogger("esri.symbols.cim.CIMSymbolHelper"));function Rt(T,S,L){switch(S.type){case"CIMSymbolReference":return Rt(T,S.symbol,L);case"CIMPointSymbol":null==L&&(L={x:0,y:0}),T.drawSymbol(S,L);break;case"CIMLineSymbol":null==L&&(L={paths:[[[0,0],[10,0]]]}),T.drawSymbol(S,L);break;case"CIMPolygonSymbol":null==L&&(L={rings:[[[0,0],[0,10],[10,10],[10,0],[0,0]]]}),T.drawSymbol(S,L);break;case"CIMTextSymbol":T.drawSymbol(S,{x:0,y:0});break;case"CIMVectorMarker":{const N=new Xt.u;T.drawMarker(S,N);break}}return T.envelope()}class vt{static getEnvelope(S,L,N){if(!S)return null;const J=new Kt.uQ(N);if(Array.isArray(S)){let O;for(const $ of S)O?O.union(Rt(J,$,L)):O=Rt(J,$,L);return O}return Rt(J,S,L)}static getTextureAnchor(S,L){const N=this.getEnvelope(S,null,L);if(!N)return[0,0,0];const lt=N.height*Gt+2;return[-(N.x+.5*N.width)*Gt/(N.width*Gt+2),-(N.y+.5*N.height)*Gt/lt,lt]}static rasterize(S,L,N,J,O=!0){const $=N||this.getEnvelope(L,null,J);if(!$)return[null,0,0,0,0];const lt=($.x+.5*$.width)*Gt,F=($.y+.5*$.height)*Gt;S.width=$.width*Gt,S.height=$.height*Gt,N||(S.width+=2,S.height+=2);const u=S.getContext("2d"),R=Kt.zA.createScale(Gt,-Gt);R.translate(.5*S.width-lt,.5*S.height+F);const U=new Kt.cD(u,J,R);switch(L.type){case"CIMPointSymbol":U.drawSymbol(L,{type:"point",x:0,y:0});break;case"CIMVectorMarker":{const mt=new Xt.u;U.drawMarker(L,mt);break}}const ft=u.getImageData(0,0,S.width,S.height),W=new Uint8Array(ft.data);if(O){let mt;for(let rt=0;rt<W.length;rt+=4)mt=W[rt+3]/255,W[rt]=W[rt]*mt,W[rt+1]=W[rt+1]*mt,W[rt+2]=W[rt+2]*mt}return[W,S.width,S.height,-lt/S.width,-F/S.height]}static fromTextSymbol(S){const{angle:L,color:N,font:J,haloColor:O,haloSize:$,horizontalAlignment:lt,kerning:F,text:u,verticalAlignment:R,xoffset:U,yoffset:ft,backgroundColor:W,borderLineColor:mt,borderLineSize:rt}=S;let nt,st,xt,kt,Ht,Ot;J&&(nt=J.family,st=J.style,xt=J.weight,kt=J.size,Ht=J.decoration);let Nt=!1;return u&&(Nt=(0,Ut.E)(u)[1]),(W||rt)&&(Ot={type:"CIMBackgroundCallout",margin:null,backgroundSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",color:wt(W)},{type:"CIMSolidStroke",color:wt(mt),width:rt}]},accentBarSymbol:null,gap:null,leaderLineSymbol:null,lineStyle:null}),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,anchorPointUnits:"Relative",dominantSizeAxis3D:"Y",size:10,billboardMode3D:"FaceNearPlane",frame:{xmin:-5,ymin:-5,xmax:5,ymax:5},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:{type:"CIMTextSymbol",angle:L,blockProgression:et.zV.BTT,depth3D:1,extrapolateBaselines:!0,fontEffects:et.eZ.Normal,fontEncoding:et.DD.Unicode,fontFamilyName:nt||"Arial",fontStyleName:y(st,xt),fontType:et.Ky.Unspecified,haloSize:$,height:kt,hinting:et.Dd.Default,horizontalAlignment:ae(lt??"center"),kerning:F,letterWidth:100,ligatures:!0,lineGapType:"Multiple",offsetX:(0,at.NA)(U),offsetY:(0,at.NA)(ft),strikethrough:"line-through"===Ht,underline:"underline"===Ht,symbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:wt(N)}]},haloSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:wt(O)}]},shadowColor:[0,0,0,255],shadowOffsetX:1,shadowOffsetY:1,textCase:"Normal",textDirection:Nt?et.UX.RTL:et.UX.LTR,verticalAlignment:ce(R??"baseline"),verticalGlyphOrientation:et.RS.Right,wordSpacing:100,billboardMode3D:et.UR.FaceNearPlane,callout:Ot},textString:u}],scaleSymbolsProportionally:!0,respectFrame:!0}],scaleX:1,angleAlignment:"Display"}}static fromPictureFillSymbol(S){const{height:L,outline:N,width:J,xoffset:O,xscale:$,yoffset:lt,yscale:F}=S,u=[],R={type:"CIMPolygonSymbol",symbolLayers:u};if(N){const{cap:rt,join:nt,miterLimit:st,width:xt}=N;u.push({type:"CIMSolidStroke",color:wt(N.color),capStyle:te(rt),joinStyle:Zt(nt),miterLimit:st,width:xt})}let U=S.url;"esriPFS"===S.type&&S.imageData&&(U=S.imageData);const ft="angle"in S?S.angle??0:0;return u.push({type:"CIMPictureFill",invertBackfaceTexture:!1,scaleX:1,textureFilter:et.Qb.Picture,tintColor:null,url:U,height:(L??0)*(F||1),width:(J??0)*($||1),offsetX:(0,at.NA)(O),offsetY:(0,at.NA)(lt),rotation:(0,at.NA)(-ft),colorSubstitutions:null}),R}static fromSimpleFillSymbol(S){const{color:L,style:N,outline:J}=S,O=[],$={type:"CIMPolygonSymbol",symbolLayers:O};let lt=null;if(J){const{cap:F,join:u,style:R}=J;"solid"!==R&&"none"!==R&&"esriSLSSolid"!==R&&"esriSLSNull"!==R&&(lt=[{type:"CIMGeometricEffectDashes",dashTemplate:A(R,F),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]),O.push({type:"CIMSolidStroke",color:wt(J.color),capStyle:te(F),joinStyle:Zt(u),miterLimit:J.miterLimit,width:J.width,effects:lt})}if(N&&"solid"!==N&&"none"!==N&&"esriSFSSolid"!==N&&"esriSFSNull"!==N){const F={type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",color:wt(L),capStyle:et.kP.Butt,joinStyle:et.r4.Miter,width:.75}]};let u=0;const R=(0,Mt.Wz)(K(N)?8:10);switch(N){case"vertical":case"esriSFSVertical":u=90;break;case"forward-diagonal":case"esriSFSForwardDiagonal":case"diagonal-cross":case"esriSFSDiagonalCross":u=-45;break;case"backward-diagonal":case"esriSFSBackwardDiagonal":u=45;break;case"cross":case"esriSFSCross":u=0}O.push({type:"CIMHatchFill",lineSymbol:F,offsetX:0,offsetY:0,rotation:u,separation:R}),"cross"===N||"esriSFSCross"===N?O.push({type:"CIMHatchFill",lineSymbol:(0,zt.d9)(F),offsetX:0,offsetY:0,rotation:90,separation:R}):"diagonal-cross"!==N&&"esriSFSDiagonalCross"!==N||O.push({type:"CIMHatchFill",lineSymbol:(0,zt.d9)(F),offsetX:0,offsetY:0,rotation:45,separation:R})}else!N||"solid"!==N&&"esriSFSSolid"!==N||O.push({type:"CIMSolidFill",enable:!0,color:wt(L)});return $}static fromSimpleLineSymbol(S){const{cap:L,color:N,join:J,marker:O,miterLimit:$,style:lt,width:F}=S;let u=null;"solid"!==lt&&"none"!==lt&&"esriSLSSolid"!==lt&&"esriSLSNull"!==lt&&(u=[{type:"CIMGeometricEffectDashes",dashTemplate:A(lt,L),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]);const R=[];if(O){let U;switch(O.placement){case"begin-end":U=et.Tx.Both;break;case"begin":U=et.Tx.JustBegin;break;case"end":U=et.Tx.JustEnd;break;default:U=et.Tx.None}const ft=vt.fromSimpleMarker(O,F,N).symbolLayers[0];ft.markerPlacement={type:"CIMMarkerPlacementAtExtremities",angleToLine:!0,offset:0,extremityPlacement:U,offsetAlongLine:0},R.push(ft)}return"none"!==lt&&"esriSLSNull"!==lt&&R.push({type:"CIMSolidStroke",color:wt(N),capStyle:te(L),joinStyle:Zt(J),miterLimit:$,width:F,effects:u}),{type:"CIMLineSymbol",symbolLayers:R}}static fromPictureMarker(S){const{angle:L,height:N,width:J,xoffset:O,yoffset:$}=S;let lt=S.url;return"esriPMS"===S.type&&S.imageData&&(lt=S.imageData),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMPictureMarker",invertBackfaceTexture:!1,scaleX:1,textureFilter:et.Qb.Picture,tintColor:null,url:lt,size:N,width:J,offsetX:(0,at.NA)(O),offsetY:(0,at.NA)($),rotation:(0,at.NA)(-L)}]}}static fromSimpleMarker(S,L,N){const{style:J}=S,O=S.color??N;if("path"===J){const u=[];if("outline"in S&&S.outline){const ft=S.outline;u.push({type:"CIMSolidStroke",enable:!0,width:(0,Mt.F2)(Math.round((0,Mt.Wz)(ft.width))),color:wt(ft.color)})}u.push({type:"CIMSolidFill",enable:!0,color:wt(O),path:S.path});const[R,U]=ht("square");return{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,at.NA)(-S.angle),size:(0,at.NA)(S.size||6),offsetX:(0,at.NA)(S.xoffset),offsetY:(0,at.NA)(S.yoffset),frame:R,markerGraphics:[{type:"CIMMarkerGraphic",geometry:U,symbol:{type:"CIMPolygonSymbol",symbolLayers:u}}]}]}}const[$,lt]=ht(J);let F;if(lt&&$){const u=[];if("outline"in S&&S.outline){const U=S.outline;u.push({type:"CIMSolidStroke",enable:!0,width:null!=U.width&&U.width>.667?(0,Mt.F2)(Math.round((0,Mt.Wz)(U.width))):U.width,color:wt(U.color)})}else!L||"line-marker"!==S.type||"cross"!==S.style&&"x"!==S.style||u.push({type:"CIMSolidStroke",enable:!0,width:L,color:wt(O)});u.push({type:"CIMSolidFill",enable:!0,color:wt(O)});const R={type:"CIMPolygonSymbol",symbolLayers:u};F={type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,at.NA)(-S.angle),size:(0,at.NA)(S.size||6*L),offsetX:(0,at.NA)(S.xoffset),offsetY:(0,at.NA)(S.yoffset),frame:$,markerGraphics:[{type:"CIMMarkerGraphic",geometry:lt,symbol:R}]}]}}return F}static fromCIMHatchFill(S,L){const N=L*(S.separation??4),J=N/2,O=(0,zt.d9)(S.lineSymbol);O.symbolLayers?.forEach(F=>{switch(F.type){case"CIMSolidStroke":null!=F.width&&(F.width*=L),F.effects?.forEach(u=>{"CIMGeometricEffectDashes"===u.type&&(u.dashTemplate=u.dashTemplate.map(R=>R*L))});break;case"CIMVectorMarker":{null!=F.size&&(F.size*=L);const u=F.markerPlacement;null!=u&&"placementTemplate"in u&&(u.placementTemplate=u.placementTemplate.map(R=>R*L));break}}});let $=this._getLineSymbolPeriod(O)||4;for(;$<4;)$*=2;const lt=$/2;return{type:"CIMVectorMarker",frame:{xmin:-lt,xmax:lt,ymin:-J,ymax:J},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{paths:[[[-lt,0],[lt,0]]]},symbol:O}],size:N}}static fetchResources(S,L,N){if(S&&L)switch(S.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":{const J=S.symbolLayers;if(!J)return;for(const O of J)switch(Tt(O,L,N),O.type){case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMCharacterMarker":case"CIMPictureMarker":"url"in O&&O.url&&N.push(L.fetchResource(O.url,null));break;case"CIMVectorMarker":{const $=O.markerGraphics;if(!$)continue;for(const lt of $)if(lt){const F=lt.symbol;F&&vt.fetchResources(F,L,N)}}}}}}static _getLineSymbolPeriod(S){if(S){const L=this._getEffectsRepeat(S.effects);if(L)return L;if(S.symbolLayers)for(const N of S.symbolLayers)if(N){const J=this._getEffectsRepeat(N.effects);if(J)return J;switch(N.type){case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":{const O=this._getPlacementRepeat(N.markerPlacement);if(O)return O}}}}return 0}static _getEffectsRepeat(S){if(S)for(const L of S)if(L)switch(L.type){case"CIMGeometricEffectDashes":{const N=L.dashTemplate;if(N&&N.length){let J=0;for(const O of N)J+=O;return 1&N.length&&(J*=2),J}break}case"CIMGeometricEffectWave":return L.period;default:Dt.error(`unsupported geometric effect type ${L.type}`)}return 0}static _getPlacementRepeat(S){if(S)switch(S.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAlongLineVariableSize":{const L=S.placementTemplate;if(L&&L.length){let N=0;for(const J of L)N+=+J;return 1&L.length&&(N*=2),N}break}}return 0}static fromCIMInsidePolygon(S){const L=S.markerPlacement,N={...S};N.markerPlacement=null,N.anchorPoint=null;const J=Math.abs(L.stepX),O=Math.abs(L.stepY),$=(L.randomness??100)/100;let lt,F,u,R;if("Random"===L.gridType){const U=(0,Mt.Wz)($t.C1),ft=Math.max(Math.floor(U/J),1),W=Math.max(Math.floor(U/O),1);lt=ft*J/2,F=W*O/2,u=2*F;const mt=new At.Z(L.seed),rt=$*J/1.5,nt=$*O/1.5;R=[];for(let st=0;st<ft;st++)for(let xt=0;xt<W;xt++){const kt=st*J-lt+rt*(.5-mt.getFloat()),Ht=xt*O-F+nt*(.5-mt.getFloat());R.push({x:kt,y:Ht}),0===st&&R.push({x:kt+2*lt,y:Ht}),0===xt&&R.push({x:kt,y:Ht+2*F})}}else!0===L.shiftOddRows?(lt=J/2,F=O,u=2*O,R=[{x:-lt,y:0},{x:lt,y:0},{x:0,y:F},{x:0,y:-F}]):(lt=J/2,F=O/2,u=O,R=[{x:-J,y:0},{x:0,y:-O},{x:-J,y:-O},{x:0,y:0},{x:J,y:0},{x:0,y:O},{x:J,y:O},{x:-J,y:O},{x:J,y:-O}]);return{type:"CIMVectorMarker",frame:{xmin:-lt,xmax:lt,ymin:-F,ymax:F},markerGraphics:R.map(U=>({type:"CIMMarkerGraphic",geometry:U,symbol:{type:"CIMPointSymbol",symbolLayers:[N]}})),size:u}}static getSize(S){if(S)switch(S.type){case"CIMTextSymbol":return S.height;case"CIMPointSymbol":{let L=0;if(S.symbolLayers)for(const N of S.symbolLayers)if(N)switch(N.type){case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":{const J=N.size;null!=J&&J>L&&(L=J);break}}return L}case"CIMLineSymbol":case"CIMPolygonSymbol":{let L=0;if(S.symbolLayers)for(const N of S.symbolLayers)if(N)switch(N.type){case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":{const J=N.width;null!=J&&J>L&&(L=J);break}case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":if(N.markerPlacement&&(0,at.gJ)(N.markerPlacement)){const J=N.size;null!=J&&J>L&&(L=J)}}return L}}}static getMarkerScaleRatio(S){return S&&"CIMVectorMarker"===S.type&&!1!==S.scaleSymbolsProportionally&&S.frame&&null!=S.size?S.size/(S.frame.ymax-S.frame.ymin):1}}class Ft{static findApplicableOverrides(S,L,N){if(S&&L){if(S.primitiveName){let J=!1;for(const O of N)if(O.primitiveName===S.primitiveName){J=!0;break}if(!J)for(const O of L)O.primitiveName===S.primitiveName&&N.push(O)}switch(S.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(S.effects)for(const J of S.effects)Ft.findApplicableOverrides(J,L,N);if(S.symbolLayers)for(const J of S.symbolLayers)Ft.findApplicableOverrides(J,L,N);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(S.effects)for(const J of S.effects)Ft.findApplicableOverrides(J,L,N);if(S.markerPlacement&&Ft.findApplicableOverrides(S.markerPlacement,L,N),"CIMVectorMarker"===S.type){if(S.markerGraphics)for(const J of S.markerGraphics)Ft.findApplicableOverrides(J,L,N),Ft.findApplicableOverrides(J.symbol,L,N)}else"CIMCharacterMarker"===S.type?Ft.findApplicableOverrides(S.symbol,L,N):"CIMHatchFill"===S.type?Ft.findApplicableOverrides(S.lineSymbol,L,N):"CIMPictureMarker"===S.type&&Ft.findApplicableOverrides(S.animatedSymbolProperties,L,N)}}}static findEffectOverrides(S,L,N){if(!L||!S)return;const J=S.length;for(let O=0;O<J;O++){const $=S[O]?.primitiveName;if($){let lt=!1;for(const F of N)if(F.primitiveName===$){lt=!0;break}if(!lt)for(const F of L)F.primitiveName===$&&N.push(F)}}}static resolveSymbolOverrides(S,L,N,J,O,$,lt){return(0,Wt.Z)(function*(){if(!S||!S.symbol)return null;let{symbol:F,primitiveOverrides:u}=S;const R=!!u;if(!R&&!J)return F;F=(0,zt.d9)(F);let U=!0;if(L||(L={attributes:{}},U=!1),R){if(U||(u=u.filter(ft=>!ft.valueExpressionInfo?.expression.includes("$feature"))),lt||(u=u.filter(ft=>!ft.valueExpressionInfo?.expression.includes("$view"))),u.length>0){const ft=(0,at.Qf)(L.attributes);yield Ft.evaluateOverrides(u,L,{spatialReference:N,fields:ft,geometryType:O},$,lt)}Ft.applyOverrides(F,u)}return J&&Ft.applyDictionaryTextOverrides(F,L,J),F})()}static evaluateOverrides(S,L,N,J,O){return(0,Wt.Z)(function*(){if(!L)return;let $;for(const lt of S){const F=lt.valueExpressionInfo;if(F&&N&&N.geometryType){$||($=[]),lt.value=void 0;const u=(0,St.Yi)(F.expression,N.spatialReference,N.fields).then(R=>{lt.value=(0,Et.Z)(R,L,{$view:O},N.geometryType,J)});$.push(u)}}void 0!==$&&$.length>0&&(yield Promise.all($))})()}static applyDictionaryTextOverrides(S,L,N,J="Normal"){if(S&&S.type)switch(S.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const O=S.symbolLayers;if(!O)return;for(const $ of O)$&&"CIMVectorMarker"===$.type&&Ft.applyDictionaryTextOverrides($,L,N,"CIMTextSymbol"===S.type?S.textCase:J)}break;case"CIMVectorMarker":{const O=S.markerGraphics;if(!O)return;for(const $ of O)$&&Ft.applyDictionaryTextOverrides($,L,N)}break;case"CIMMarkerGraphic":{const O=S.textString;if(O&&O.includes("[")){const $=(0,at.H1)(O,N);S.textString=(0,at.E_)(L,$,J)}}}}static applyOverrides(S,L,N,J){if(S.primitiveName)for(const O of L)if(O.primitiveName===S.primitiveName){const $=bt(O.propertyName);if(J&&J.push({cim:S,nocapPropertyName:$,value:S[$]}),O.expression&&(O.value=Ft.toValue(O.propertyName,O.expression)),N){let lt=!1;for(const F of N)F.primitiveName===S.primitiveName&&(lt=!0);lt||N.push(O)}(0,q.pC)(O.value)&&(S[$]=O.value)}switch(S.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(S.effects)for(const O of S.effects)Ft.applyOverrides(O,L,N,J);if(S.symbolLayers)for(const O of S.symbolLayers)Ft.applyOverrides(O,L,N,J);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(S.effects)for(const O of S.effects)Ft.applyOverrides(O,L,N,J);if("CIMVectorMarker"===S.type&&S.markerGraphics)for(const O of S.markerGraphics)Ft.applyOverrides(O,L,N,J),Ft.applyOverrides(O.symbol,L,N,J)}}static restoreOverrides(S){for(const L of S)L.cim[L.nocapPropertyName]=L.value}static buildOverrideKey(S){let L="";for(const N of S)void 0!==N.value&&(L+=`${N.primitiveName}${N.propertyName}${JSON.stringify(N.value)}`);return L}static toValue(S,L){if("DashTemplate"===S)return L.split(" ").map(N=>Number(N));if("Color"===S){const N=new gt.Z(L).toRgba();return N[3]*=255,N}return L}}const te=T=>{if(!T)return et.kP.Butt;switch(T){case"butt":return et.kP.Butt;case"square":return et.kP.Square;case"round":return et.kP.Round}},Zt=T=>{if(!T)return et.r4.Miter;switch(T){case"miter":return et.r4.Miter;case"round":return et.r4.Round;case"bevel":return et.r4.Bevel}},ae=T=>{if((0,q.Wi)(T))return"Center";switch(T){case"left":return"Left";case"right":return"Right";case"center":return"Center"}},ce=T=>{if((0,q.Wi)(T))return"Center";switch(T){case"baseline":return"Baseline";case"top":return"Top";case"middle":return"Center";case"bottom":return"Bottom"}},wt=T=>{if(!T)return[0,0,0,0];const{r:S,g:L,b:N,a:J}=T;return[S,L,N,255*J]},y=(T,S)=>{const L=k(S),N=Y(T);return L&&N?`${L}-${N}`:`${L}${N}`},k=T=>{if(!T)return"";switch(T.toLowerCase()){case"bold":case"bolder":return"bold"}return""},Y=T=>{if(!T)return"";switch(T.toLowerCase()){case"italic":case"oblique":return"italic"}return""},A=(T,S)=>{const L="butt"===S;switch(T){case"dash":case"esriSLSDash":return L?[4,3]:[3,4];case"dash-dot":case"esriSLSDashDot":return L?[4,3,1,3]:[3,4,0,4];case"dot":case"esriSLSDot":return L?[1,3]:[0,4];case"long-dash":case"esriSLSLongDash":return L?[8,3]:[7,4];case"long-dash-dot":case"esriSLSLongDashDot":return L?[8,3,1,3]:[7,4,0,4];case"long-dash-dot-dot":case"esriSLSDashDotDot":return L?[8,3,1,3,1,3]:[7,4,0,4,0,4];case"short-dash":case"esriSLSShortDash":return L?[4,1]:[3,2];case"short-dash-dot":case"esriSLSShortDashDot":return L?[4,1,1,1]:[3,2,0,2];case"short-dash-dot-dot":case"esriSLSShortDashDotDot":return L?[4,1,1,1,1,1]:[3,2,0,2,0,2];case"short-dot":case"esriSLSShortDot":return L?[1,1]:[0,2];case"solid":case"esriSLSSolid":case"none":return Dt.error("Unexpected: style does not require rasterization"),[0,0];default:return Dt.error(`Tried to rasterize SLS, but found an unexpected style: ${T}!`),[0,0]}},ht=T=>{let N,J;const O=T;if("circle"===O||"esriSMSCircle"===O){let lt=Math.acos(.995),F=Math.ceil(Yt/lt/4);0===F&&(F=1),lt=se/F,F*=4;const u=[];u.push([50,0]);for(let R=1;R<F;R++)u.push([50*Math.cos(R*lt),-50*Math.sin(R*lt)]);u.push([50,0]),N={rings:[u]},J={xmin:-50,ymin:-50,xmax:50,ymax:50}}else if("cross"===O||"esriSMSCross"===O)N={rings:[[[0,50],[0,0],[50,0],[50,-0],[0,-0],[0,-50],[-0,-50],[-0,-0],[-50,-0],[-50,0],[-0,0],[-0,50],[0,50]]]},J={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("diamond"===O||"esriSMSDiamond"===O)N={rings:[[[-50,0],[0,50],[50,0],[0,-50],[-50,0]]]},J={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("square"===O||"esriSMSSquare"===O)N={rings:[[[-50,-50],[-50,50],[50,50],[50,-50],[-50,-50]]]},J={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("x"===O||"esriSMSX"===O)N={rings:[[[0,0],[50,50],[50,50],[0,0],[50,-50],[50,-50],[0,-0],[-50,-50],[-50,-50],[-0,0],[-50,50],[-50,50],[0,0]]]},J={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("triangle"===O||"esriSMSTriangle"===O){const $=57.735026918962575,lt=-$,F=2/3*100,u=F-100;N={rings:[[[lt,u],[0,F],[$,u],[lt,u]]]},J={xmin:lt,ymin:u,xmax:$,ymax:F}}else"arrow"===O&&(N={rings:[[[-50,50],[50,0],[-50,-50],[-33,-20],[-33,20],[-50,50]]]},J={xmin:-50,ymin:-50,xmax:50,ymax:50});return[J,N]},K=T=>"vertical"===T||"horizontal"===T||"cross"===T||"esriSFSCross"===T||"esriSFSVertical"===T||"esriSFSHorizontal"===T,bt=T=>T&&T.charAt(0).toLowerCase()+T.substr(1);function Tt(T,S,L){if(T.effects&&!(0,q.pC)(S.geometryEngine)){if(S.geometryEnginePromise)return void L.push(S.geometryEnginePromise);(0,at.Cc)(T.effects)&&(S.geometryEnginePromise=(0,at.RI)(),L.push(S.geometryEnginePromise),S.geometryEnginePromise.then(N=>S.geometryEngine=N))}}},31375:(Te,pe,ut)=>{ut.d(pe,{Z:()=>Wt});class Wt{constructor(Ut=0,zt=0,oe=0,q=0){this.x=Ut,this.y=zt,this.width=oe,this.height=q}get isEmpty(){return this.width<=0||this.height<=0}union(Ut){this.x=Math.min(this.x,Ut.x),this.y=Math.min(this.y,Ut.y),this.width=Math.max(this.width,Ut.width),this.height=Math.max(this.height,Ut.height)}}},47139:(Te,pe,ut)=>{ut.d(pe,{Fp:()=>zt,RL:()=>_t,UV:()=>Lt,bk:()=>Mt});var Wt=ut(36161),gt=ut(91179),Ut=ut(31375);function zt(et){if(!et)return null;switch(et.type){case"CIMPointSymbol":{const at=et.symbolLayers;return at&&1===at.length?zt(at[0]):null}case"CIMVectorMarker":{const at=et.markerGraphics;if(!at||1!==at.length)return null;const Et=at[0];if(!Et)return null;const Q=Et.geometry;if(!Q)return null;const $t=Et.symbol;return!$t||"CIMPolygonSymbol"!==$t.type&&"CIMLineSymbol"!==$t.type||$t.symbolLayers?.some(jt=>!!jt.effects)?null:{geom:Q,asFill:"CIMPolygonSymbol"===$t.type}}case"sdf":return{geom:et.geom,asFill:et.asFill}}return null}function At(et){let at=1/0,Et=-1/0,Q=1/0,$t=-1/0;for(const jt of et)for(const Yt of jt)Yt[0]<at&&(at=Yt[0]),Yt[0]>Et&&(Et=Yt[0]),Yt[1]<Q&&(Q=Yt[1]),Yt[1]>$t&&($t=Yt[1]);return[at,Q,Et,$t]}function Mt(et){return et?et.rings?At(et.rings):et.paths?At(et.paths):(0,gt.YX)(et)?[et.xmin,et.ymin,et.xmax,et.ymax]:null:null}function Lt(et,at,Et,Q,$t){const[jt,Yt,se,he]=et;if(se<jt||he<Yt)return[0,0,0];const it=se-jt,Ct=he-Yt,Dt=Math.floor(31.5),ee=(128-2*(Dt+1))/Math.max(it,Ct),Rt=Math.round(it*ee)+2*Dt,ct=Math.round(Ct*ee)+2*Dt;let yt=1;at&&(yt=ct/ee/(at.ymax-at.ymin));let pt=0,Pt=0,vt=1;Q&&($t?at&&Et&&at.ymax-at.ymin>0&&(vt=(at.xmax-at.xmin)/(at.ymax-at.ymin),pt=Q.x/(Et*vt),Pt=Q.y/Et):(pt=Q.x,Pt=Q.y)),at&&(pt=.5*(at.xmax+at.xmin)+pt*(at.xmax-at.xmin),Pt=.5*(at.ymax+at.ymin)+Pt*(at.ymax-at.ymin)),pt-=jt,Pt-=Yt,pt*=ee,Pt*=ee,pt+=Dt,Pt+=Dt;let Ft=pt/Rt-.5,te=Pt/ct-.5;return $t&&Et&&(Ft*=Et*vt,te*=Et),[yt,Ft,te]}function _t(et){const at=function oe(et){return et?et.rings?et.rings:et.paths?et.paths:void 0!==et.xmin&&void 0!==et.ymin&&void 0!==et.xmax&&void 0!==et.ymax?[[[et.xmin,et.ymin],[et.xmin,et.ymax],[et.xmax,et.ymax],[et.xmax,et.ymin],[et.xmin,et.ymin]]]:null:null}(et.geom),Et=function q(et){let at=1/0,Et=-1/0,Q=1/0,$t=-1/0;for(const jt of et)for(const Yt of jt)Yt[0]<at&&(at=Yt[0]),Yt[0]>Et&&(Et=Yt[0]),Yt[1]<Q&&(Q=Yt[1]),Yt[1]>$t&&($t=Yt[1]);return new Ut.Z(at,Q,Et-at,$t-Q)}(at),jt=Math.floor(31.5),Yt=(128-2*(jt+1))/Math.max(Et.width,Et.height),se=Math.round(Et.width*Yt)+2*jt,he=Math.round(Et.height*Yt)+2*jt,it=[];for(const Gt of at)if(Gt&&Gt.length>1){const qt=[];for(const Dt of Gt){let[ee,Rt]=Dt;ee-=Et.x,Rt-=Et.y,ee*=Yt,Rt*=Yt,ee+=jt-.5,Rt+=jt-.5,qt.push(et.asFill?[ee,Rt]:[Math.round(ee),Math.round(Rt)])}if(et.asFill){const Dt=qt.length-1;qt[0][0]===qt[Dt][0]&&qt[0][1]===qt[Dt][1]||qt.push(qt[0])}it.push(qt)}const Ct=function St(et,at,Et,Q){const $t=at*Et,jt=new Array($t),Yt=Q*Q+1;for(let se=0;se<$t;++se)jt[se]=Yt;for(const se of et){const he=se.length;for(let it=1;it<he;++it){const Ct=se[it-1],Gt=se[it];let qt,Dt,ee,Rt;Ct[0]<Gt[0]?(qt=Ct[0],Dt=Gt[0]):(qt=Gt[0],Dt=Ct[0]),Ct[1]<Gt[1]?(ee=Ct[1],Rt=Gt[1]):(ee=Gt[1],Rt=Ct[1]);let ct=Math.floor(qt)-Q,yt=Math.floor(Dt)+Q,pt=Math.floor(ee)-Q,Pt=Math.floor(Rt)+Q;ct<0&&(ct=0),yt>at&&(yt=at),pt<0&&(pt=0),Pt>Et&&(Pt=Et);const vt=Gt[0]-Ct[0],Ft=Gt[1]-Ct[1],te=vt*vt+Ft*Ft;for(let Zt=ct;Zt<yt;Zt++)for(let ae=pt;ae<Pt;ae++){let ce,wt,y=(Zt-Ct[0])*vt+(ae-Ct[1])*Ft;y<0?(ce=Ct[0],wt=Ct[1]):y>te?(ce=Gt[0],wt=Gt[1]):(y/=te,ce=Ct[0]+y*vt,wt=Ct[1]+y*Ft);const k=(Zt-ce)*(Zt-ce)+(ae-wt)*(ae-wt),Y=(Et-ae-1)*at+Zt;k<jt[Y]&&(jt[Y]=k)}}}for(let se=0;se<$t;++se)jt[se]=Math.sqrt(jt[se]);return jt}(it,se,he,jt);return et.asFill&&function Xt(et,at,Et,Q,$t){for(const jt of et){const Yt=jt.length;for(let se=1;se<Yt;++se){const he=jt[se-1],it=jt[se];let Ct,Gt,qt,Dt;he[0]<it[0]?(Ct=he[0],Gt=it[0]):(Ct=it[0],Gt=he[0]),he[1]<it[1]?(qt=he[1],Dt=it[1]):(qt=it[1],Dt=he[1]);let ee=Math.floor(Ct),Rt=Math.floor(Gt)+1,ct=Math.floor(qt),yt=Math.floor(Dt)+1;ee<Q&&(ee=Q),Rt>at-Q&&(Rt=at-Q),ct<Q&&(ct=Q),yt>Et-Q&&(yt=Et-Q);for(let pt=ct;pt<yt;++pt){if(he[1]>pt==it[1]>pt)continue;const Pt=(Et-pt-1)*at;for(let vt=ee;vt<Rt;++vt)vt<(it[0]-he[0])*(pt-he[1])/(it[1]-he[1])+he[0]&&($t[Pt+vt]=-$t[Pt+vt]);for(let vt=Q;vt<ee;++vt)$t[Pt+vt]=-$t[Pt+vt]}}}}(it,se,he,jt,Ct),[Kt(Ct,jt),se,he]}function Kt(et,at){const Et=2*at,Q=et.length,$t=new Uint8Array(4*Q);for(let jt=0;jt<Q;++jt)(0,Wt.I)(.5-et[jt]/Et,$t,4*jt);return $t}},68937:(Te,pe,ut)=>{ut.d(pe,{Z:()=>zt});var Wt=ut(23841);class zt{constructor(At){At&&(this._textRasterizationCanvas=At)}rasterizeText(At,Mt){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const Lt=this._textRasterizationCanvas,_t=Lt.getContext("2d");this._setFontProperties(_t,Mt),this._parameters=Mt,this._textLines=At.split(/\r?\n/),this._lineHeight=this._computeLineHeight();const St=this._computeTextWidth(_t,Mt),{decoration:Xt,weight:Kt}=Mt.font;this._lineThroughWidthOffset=Xt&&"line-through"===Xt?.1*this._lineHeight:0;const et=this._lineHeight*this._textLines.length;Lt.width=St+2*this._lineThroughWidthOffset,Lt.height=et,this._renderedLineHeight=Math.round(this._lineHeight*Mt.pixelRatio),this._renderedHaloSize=Mt.halo.size*Mt.pixelRatio,this._renderedWidth=St*Mt.pixelRatio,this._renderedHeight=et*Mt.pixelRatio,this._lineThroughWidthOffset*=Mt.pixelRatio;const Et=Mt.halo&&Mt.halo.color?Mt.halo.color:[0,0,0,0];this._fillStyle=function Ut(q){return`rgba(${q.slice(0,3).toString()},${q[3]})`}(Mt.color??[0,0,0,0]),this._haloStyle=function gt(q){return`rgb(${q.slice(0,3).toString()})`}(Et);const Q=this._renderedLineHeight,$t=this._renderedHaloSize;_t.save(),_t.clearRect(0,0,Lt.width,Lt.height),this._setFontProperties(_t,Mt);const jt=function oe(q,At){return"center"===q?.5*At:"right"===q?At:0}(_t.textAlign,this._renderedWidth)+$t,Yt=$t,se=$t>0;let he=this._lineThroughWidthOffset,it=0;se&&this._renderHalo(_t,jt,Yt,he,it,Mt),it+=Yt,he+=jt;for(const ct of this._textLines)se?(_t.globalCompositeOperation="destination-out",_t.fillStyle="rgb(0, 0, 0)",_t.fillText(ct,he,it),_t.globalCompositeOperation="source-over",_t.fillStyle=this._fillStyle,_t.fillText(ct,he,it)):(_t.fillStyle=this._fillStyle,_t.fillText(ct,he,it)),Xt&&"none"!==Xt&&this._renderDecoration(_t,he,it,Xt,Kt),it+=Q;_t.restore();const Ct=this._renderedWidth+2*this._lineThroughWidthOffset,Gt=this._renderedHeight,qt=_t.getImageData(0,0,Ct,Gt),Dt=new Uint8Array(qt.data);if(Mt.premultiplyColors){let ct;for(let yt=0;yt<Dt.length;yt+=4)ct=Dt[yt+3]/255,Dt[yt]=Dt[yt]*ct,Dt[yt+1]=Dt[yt+1]*ct,Dt[yt+2]=Dt[yt+2]*ct}let ee,Rt;switch(Mt.horizontalAlignment){case"left":ee=-.5;break;case"right":ee=.5;break;default:ee=0}switch(Mt.verticalAlignment){case"bottom":Rt=-.5;break;case"top":Rt=.5;break;default:Rt=0}return{size:[Ct,Gt],image:new Uint32Array(Dt.buffer),sdf:!1,simplePattern:!1,anchorX:ee,anchorY:Rt,canvas:Lt}}_renderHalo(At,Mt,Lt,_t,St,Xt){const Kt=this._renderedWidth,et=this._renderedHeight;this._haloRasterizationCanvas||(this._haloRasterizationCanvas=document.createElement("canvas")),this._haloRasterizationCanvas.width=Kt,this._haloRasterizationCanvas.height=et;const at=this._haloRasterizationCanvas,Et=at.getContext("2d");Et.clearRect(0,0,Kt,et),this._setFontProperties(Et,Xt);const{decoration:Q,weight:$t}=Xt.font;Et.fillStyle=this._haloStyle,Et.strokeStyle=this._haloStyle,Et.lineJoin="round",this._renderHaloNative(Et,Mt,Lt,Q,$t),At.globalAlpha=this._parameters.halo.color[3],At.drawImage(at,0,0,Kt,et,_t,St,Kt,et),At.globalAlpha=1}_renderHaloNative(At,Mt,Lt,_t,St){const Xt=this._renderedLineHeight,Kt=this._renderedHaloSize;for(const et of this._textLines){const at=2*Kt,Et=5,Q=.1;for(let $t=0;$t<Et;$t++){const jt=(1-(Et-1)*Q+$t*Q)*at;At.lineWidth=jt,At.strokeText(et,Mt,Lt),_t&&"none"!==_t&&this._renderDecoration(At,Mt,Lt,_t,St,jt)}Lt+=Xt}}_setFontProperties(At,Mt){const Lt=Math.max(Mt.size,.5),_t=Mt.font,St=`${_t.style} ${_t.weight} ${(0,Wt.F2)(Lt*Mt.pixelRatio).toFixed(1)}px ${_t.family}, sans-serif`;let Xt;switch(At.font=St,At.textBaseline="top",Mt.horizontalAlignment){case"left":default:Xt="left";break;case"right":Xt="right";break;case"center":Xt="center"}At.textAlign=Xt}computeTextSize(At,Mt){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const Lt=this._textRasterizationCanvas,_t=Lt.getContext("2d");this._setFontProperties(_t,Mt),this._parameters=Mt,this._textLines=At.split(/\r?\n/),this._lineHeight=this._computeLineHeight();const St=this._computeTextWidth(_t,Mt),Xt=this._lineHeight*this._textLines.length;return Lt.width=St,Lt.height=Xt,[St*Mt.pixelRatio,Xt*Mt.pixelRatio]}_computeTextWidth(At,Mt){let Lt=0;for(const St of this._textLines)Lt=Math.max(Lt,At.measureText(St).width);const _t=Mt.font;return("italic"===_t.style||"oblique"===_t.style||"string"==typeof _t.weight&&("bold"===_t.weight||"bolder"===_t.weight)||"number"==typeof _t.weight&&_t.weight>600)&&(Lt+=.3*At.measureText("w").width),Lt+=2*this._parameters.halo.size,Math.round(Lt)}_computeLineHeight(){let At=1.275*this._parameters.size;const Mt=this._parameters.font.decoration;return Mt&&"underline"===Mt&&(At*=1.3),Math.round(At+2*this._parameters.halo.size)}_renderDecoration(At,Mt,Lt,_t,St,Xt){const Kt=.9*this._lineHeight,et="bold"===St?.06:"bolder"===St?.09:.04;switch(At.textAlign){case"center":Mt-=this._renderedWidth/2;break;case"right":Mt-=this._renderedWidth}const at=At.textBaseline;if("underline"===_t)switch(at){case"top":Lt+=Kt;break;case"middle":Lt+=Kt/2}else if("line-through"===_t)switch(at){case"top":Lt+=Kt/1.5;break;case"middle":Lt+=Kt/3}const Et=Xt?1.5*Xt:Math.ceil(Kt*et);At.save(),At.beginPath(),At.strokeStyle=At.fillStyle,At.lineWidth=Et,At.moveTo(Mt-this._lineThroughWidthOffset,Lt),At.lineTo(Mt+this._renderedWidth+2*this._lineThroughWidthOffset,Lt),At.stroke(),At.restore()}}},93678:(Te,pe,ut)=>{ut.d(pe,{S:()=>$,c:()=>ct});var Wt=ut(15861),gt=ut(91558),Ut=ut(17002),zt=ut(58817),oe=ut(63290),q=ut(62208),At=ut(23841),Mt=ut(77275),Lt=ut(46679),_t=ut(35909),St=ut(7547);const Xt=.05,et=new Set(["StartTimeOffset","Duration","RepeatDelay"]);function at(u,R){return et.has(R)?function Kt(u){return Math.max(Math.round(u/Xt),1)*Xt}(u):u}var Et=ut(47139),Q=ut(80991),$t=ut(73608),jt=ut(39236),Yt=ut(39351);const it=53290320,Ct=10,Gt=oe.Z.getLogger("esri.symbols.cim.cimAnalyzer");function qt(u){switch(u){case"Butt":return St.RL.BUTT;case"Square":return St.RL.SQUARE;default:return St.RL.ROUND}}function Dt(u){switch(u){case"Bevel":return St.AH.BEVEL;case"Miter":return St.AH.MITER;default:return St.AH.ROUND}}function ee(u,R,U,ft){let W;u[R]?W=u[R]:(W={},u[R]=W),W[U]=ft}function Rt(u){const R=u.markerPlacement;return R&&R.angleToLine?St.v2.MAP:St.v2.SCREEN}function ct(u,R,U,ft,W){return yt.apply(this,arguments)}function yt(){return(yt=(0,Wt.Z)(function*(u,R,U,ft,W){const mt=ft??[];if(!u)return mt;let rt,nt;const st={};if("CIMSymbolReference"!==u.type)return Gt.error("Expect cim type to be 'CIMSymbolReference'"),mt;if(rt=u.symbol,nt=u.primitiveOverrides,nt){const kt=[];for(const Ht of nt){const Ot=Ht.valueExpressionInfo;if(Ot&&R){const le=(0,Lt.Yi)(Ot.expression,R.spatialReference,R.fields).then(Qt=>{(0,q.Wi)(Qt)||ee(st,Ht.primitiveName,Ht.propertyName,Qt)});kt.push(le)}else null!=Ht.value&&ee(st,Ht.primitiveName,Ht.propertyName,Ht.value)}kt.length>0&&(yield Promise.all(kt))}const xt=[];switch(_t.B$.fetchResources(rt,U,xt),xt.length>0&&(yield Promise.all(xt)),rt?.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":!function pt(u,R,U,ft,W,mt,rt){if(!u)return;const nt=u.symbolLayers;if(!nt)return;const st=u.effects;let xt=St.v2.SCREEN;const kt=_t.B$.getSize(u)??0;"CIMPointSymbol"===u.type&&"Map"===u.angleAlignment&&(xt=St.v2.MAP);let Ht=nt.length;for(;Ht--;){const Ot=nt[Ht];if(!Ot||!1===Ot.enable)continue;let Nt;st&&st.length&&(Nt=[...st]);const le=Ot.effects;le&&le.length&&(st?Nt.push(...le):Nt=[...le]);const Qt=[];let Jt;_t.E0.findEffectOverrides(Nt,R,Qt),Jt=Qt.length>0?L(Nt,Qt,U,ft):Nt;const ie=[];switch(_t.E0.findApplicableOverrides(Ot,R,ie),Ot.type){case"CIMSolidFill":Pt(Ot,Jt,U,ie,ft,W);break;case"CIMPictureFill":vt(Ot,Jt,U,ie,ft,mt,W);break;case"CIMHatchFill":Ft(Ot,Jt,U,ie,ft,W);break;case"CIMGradientFill":te(Ot,Jt,U,ie,ft,W);break;case"CIMSolidStroke":Zt(Ot,Jt,U,ie,ft,W,"CIMPolygonSymbol"===u.type,kt);break;case"CIMPictureStroke":ae(Ot,Jt,U,ie,ft,W,"CIMPolygonSymbol"===u.type,kt);break;case"CIMGradientStroke":ce(Ot,Jt,U,ie,ft,W,"CIMPolygonSymbol"===u.type,kt);break;case"CIMCharacterMarker":if(wt(Ot,Jt,U,ie,ft,W))break;break;case"CIMPictureMarker":if(wt(Ot,Jt,U,ie,ft,W))break;"CIMLineSymbol"===u.type&&(xt=Rt(Ot)),y(Ot,Jt,U,ie,ft,mt,W,xt,kt);break;case"CIMVectorMarker":if(wt(Ot,Jt,U,ie,ft,W))break;"CIMLineSymbol"===u.type&&(xt=Rt(Ot)),k(Ot,Jt,U,ie,ft,W,mt,xt,kt,rt);break;default:Gt.error("Cannot analyze CIM layer",Ot.type)}}}(rt,nt,st,R,mt,U,!!W)}return mt})).apply(this,arguments)}function Pt(u,R,U,ft,W,mt){const rt=u.primitiveName,nt=(0,Q.NO)(u.color),[st,xt]=lt(ft,rt,R,null,null),kt=(0,Mt.hP)(JSON.stringify(u)+xt).toString();mt.push({type:"fill",templateHash:kt,materialHash:st?()=>kt:kt,cim:u,materialOverrides:null,colorLocked:!!u.colorLocked,color:T(rt,U,"Color",W,nt,Tt),height:0,angle:0,offsetX:0,offsetY:0,scaleX:1,effects:R,applyRandomOffset:!1,sampleAlphaOnly:!0})}function vt(u,R,U,ft,W,mt,rt){const nt=u.primitiveName,st=(0,Q.cO)(u),[xt,kt]=lt(ft,nt,R,null,null),Ht=(0,Mt.hP)(JSON.stringify(u)+kt).toString(),Ot=(0,Mt.hP)(`${u.url}${JSON.stringify(u.colorSubstitutions)}`).toString();let Nt=(0,Q.NA)(u.scaleX);if("width"in u&&"number"==typeof u.width){const le=u.width;let Qt=1;const Jt=mt.getResource(u.url);(0,q.pC)(Jt)&&(Qt=Jt.width/Jt.height),Nt/=Qt*(u.height/le)}rt.push({type:"fill",templateHash:Ht,materialHash:xt?()=>Ot:Ot,cim:u,materialOverrides:null,colorLocked:!!u.colorLocked,effects:R,color:T(nt,U,"TintColor",W,st,Tt),height:T(nt,U,"Height",W,u.height),scaleX:T(nt,U,"ScaleX",W,Nt),angle:T(nt,U,"Rotation",W,(0,Q.NA)(u.rotation)),offsetX:T(nt,U,"OffsetX",W,(0,Q.NA)(u.offsetX)),offsetY:T(nt,U,"OffsetY",W,(0,Q.NA)(u.offsetY)),url:u.url,applyRandomOffset:!1,sampleAlphaOnly:!1})}function Ft(u,R,U,ft,W,mt){const rt=["Rotation","OffsetX","OffsetY"],nt=ft.filter(Jt=>Jt.primitiveName!==u.primitiveName||!rt.includes(Jt.propertyName)),st=u.primitiveName;let[xt,kt]=lt(ft,st,R,null,null);const Ht=(0,Mt.hP)(JSON.stringify(u)+kt).toString(),Ot=(0,Mt.hP)(`${u.separation}${JSON.stringify(u.lineSymbol)}`).toString();let Nt={r:255,g:255,b:255,a:1},le=!1;const Qt=u.lineSymbol?.symbolLayers?.find(Jt=>"CIMSolidStroke"===Jt.type&&null!=U[Jt.primitiveName]?.Color);if(Qt){Nt=(0,Q.NO)(Qt.color),Nt=T(Qt.primitiveName,U,"Color",W,Nt,Tt);const Jt="function"==typeof Nt;xt=xt||Jt,le=null!=Qt.color||Jt}mt.push({type:"fill",templateHash:Ht,materialHash:xt?O(Ot,U,nt,W):Ot,cim:u,materialOverrides:nt,colorLocked:!!u.colorLocked,effects:R,color:Nt,height:T(st,U,"Separation",W,u.separation),scaleX:1,angle:T(st,U,"Rotation",W,(0,Q.NA)(u.rotation)),offsetX:T(st,U,"OffsetX",W,(0,Q.NA)(u.offsetX)),offsetY:T(st,U,"OffsetY",W,(0,Q.NA)(u.offsetY)),applyRandomOffset:!1,sampleAlphaOnly:!0,hasUnresolvedReplacementColor:!le})}function te(u,R,U,ft,W,mt){const rt=u.primitiveName,[nt,st]=lt(ft,rt,R,null,null),xt=(0,Mt.hP)(JSON.stringify(u)+st).toString();mt.push({type:"fill",templateHash:xt,materialHash:nt?O(xt,U,ft,W):xt,cim:u,materialOverrides:null,colorLocked:!!u.colorLocked,effects:R,color:{r:128,g:128,b:128,a:1},height:0,angle:0,offsetX:0,offsetY:0,scaleX:1,applyRandomOffset:!1,sampleAlphaOnly:!1})}function Zt(u,R,U,ft,W,mt,rt,nt){const st=u.primitiveName,xt=(0,Q.NO)(u.color),kt=null!=u.width?u.width:4,Ht=qt(u.capStyle),Ot=Dt(u.joinStyle),Nt=u.miterLimit,[le,Qt]=lt(ft,st,R,null,null),Jt=(0,Mt.hP)(JSON.stringify(u)+Qt).toString();let ie,ue;if(R&&R instanceof Array&&R.length>0){const be=R[R.length-1];if("CIMGeometricEffectDashes"===be.type&&"NoConstraint"===be.lineDashEnding&&null===be.offsetAlongLine){const Me=(R=[...R]).pop();ie=Me.dashTemplate,ue=Me.scaleDash}}mt.push({type:"line",templateHash:Jt,materialHash:le?()=>Jt:Jt,cim:u,materialOverrides:null,isOutline:rt,colorLocked:!!u.colorLocked,effects:R,color:T(st,U,"Color",W,xt,Tt),width:T(st,U,"Width",W,kt),cap:T(st,U,"CapStyle",W,Ht),join:T(st,U,"JoinStyle",W,Ot),miterLimit:Nt&&T(st,U,"MiterLimit",W,Nt),referenceWidth:nt,zOrder:bt(u.name),dashTemplate:ie,scaleDash:ue,sampleAlphaOnly:!0})}function ae(u,R,U,ft,W,mt,rt,nt){const st=(0,Mt.hP)(`${u.url}${JSON.stringify(u.colorSubstitutions)}`).toString(),xt=u.primitiveName,kt=(0,Q.cO)(u),Ht=null!=u.width?u.width:4,Ot=qt(u.capStyle),Nt=Dt(u.joinStyle),le=u.miterLimit,[Qt,Jt]=lt(ft,xt,R,null,null),ie=(0,Mt.hP)(JSON.stringify(u)+Jt).toString();mt.push({type:"line",templateHash:ie,materialHash:Qt?()=>st:st,cim:u,materialOverrides:null,isOutline:rt,colorLocked:!!u.colorLocked,effects:R,color:T(xt,U,"TintColor",W,kt,Tt),width:T(xt,U,"Width",W,Ht),cap:T(xt,U,"CapStyle",W,Ot),join:T(xt,U,"JoinStyle",W,Nt),miterLimit:le&&T(xt,U,"MiterLimit",W,le),referenceWidth:nt,zOrder:bt(u.name),dashTemplate:null,scaleDash:!1,url:u.url,sampleAlphaOnly:!1})}function ce(u,R,U,ft,W,mt,rt,nt){const st=u.primitiveName,xt=null!=u.width?u.width:4,kt=qt(u.capStyle),Ht=Dt(u.joinStyle),Ot=u.miterLimit,[Nt,le]=lt(ft,st,R,null,null),Qt=(0,Mt.hP)(JSON.stringify(u)+le).toString();mt.push({type:"line",templateHash:Qt,materialHash:Nt?O(Qt,U,ft,W):Qt,cim:u,materialOverrides:null,isOutline:rt,colorLocked:!!u.colorLocked,effects:R,color:{r:128,g:128,b:128,a:1},width:T(st,U,"Width",W,xt),cap:T(st,U,"CapStyle",W,kt),join:T(st,U,"JoinStyle",W,Ht),miterLimit:Ot&&T(st,U,"MiterLimit",W,Ot),referenceWidth:nt,zOrder:bt(u.name),dashTemplate:null,scaleDash:!1,sampleAlphaOnly:!1})}function wt(u,R,U,ft,W,mt){const{markerPlacement:rt,type:nt}=u;if(!rt||"CIMMarkerPlacementInsidePolygon"!==rt.type)return!1;if("CIMVectorMarker"===nt||"CIMPictureMarker"===nt){const fe=u.primitiveName;if(fe){const[ge,Ce]=lt(ft,fe,R,null,null);if(ge)return!1}const we=rt.primitiveName;if(we){const[ge,Ce]=lt(ft,we,R,null,null);if(ge)return!1}if("CIMVectorMarker"===nt){const{markerGraphics:ge}=u;if(ge)for(const Ce of ge){const{symbol:_e}=Ce;if("CIMPolygonSymbol"===_e?.type&&_e.symbolLayers){const{symbolLayers:me}=_e;for(const ve of me)if("CIMSolidStroke"===ve.type)return!1}}}else{const{animatedSymbolProperties:ge}=u;if(ge)return!1}}const st=rt,xt=Math.abs(st.stepX),kt=Math.abs(st.stepY);if(0===xt||0===kt)return!0;const Ht=["Rotation","OffsetX","OffsetY"],Ot=ft.filter(fe=>fe.primitiveName!==u.primitiveName||!Ht.includes(fe.propertyName)),Nt="url"in u&&"string"==typeof u.url?u.url:void 0,[le,Qt]=lt(ft,st.primitiveName,R,null,null),Jt=(0,Mt.hP)(JSON.stringify(u)+Qt).toString();let ie,ue,be=null;if("Random"===rt.gridType){const fe=(0,At.Wz)(Yt.C1),we=Math.max(Math.floor(fe/xt),1),ge=Math.max(Math.floor(fe/kt),1);ie=kt*ge,be=Ce=>Ce?Ce*ge:0,ue=we*xt/ie}else rt.shiftOddRows?(ie=2*kt,be=fe=>fe?2*fe:0,ue=xt/kt*.5):(ie=kt,be=null,ue=xt/kt);const Me=(0,Q.cO)(u);return mt.push({type:"fill",templateHash:Jt,materialHash:le?O(Jt,U,Ot,W):Jt,cim:u,materialOverrides:Ot,colorLocked:!!u.colorLocked,effects:R,color:T(st.primitiveName,U,"TintColor",W,Me,Tt),height:T(st.primitiveName,U,"StepY",W,ie,be),scaleX:ue,angle:T(st.primitiveName,U,"GridAngle",W,st.gridAngle),offsetX:T(st.primitiveName,U,"OffsetX",W,(0,Q.NA)(st.offsetX)),offsetY:T(st.primitiveName,U,"OffsetY",W,(0,Q.NA)(st.offsetY)),url:Nt,applyRandomOffset:"Random"===rt.gridType,sampleAlphaOnly:!Nt,hasUnresolvedReplacementColor:!0}),!0}function y(u,R,U,ft,W,mt,rt,nt,st){const xt=u.primitiveName,kt=(0,Q.NA)(u.size);let Ht=(0,Q.NA)(u.scaleX,1);const Ot=(0,Q.NA)(u.rotation),Nt=(0,Q.NA)(u.offsetX),le=(0,Q.NA)(u.offsetY),Qt=(0,Q.cO)(u),Jt=(0,Mt.hP)(`${u.url}${JSON.stringify(u.colorSubstitutions)}${JSON.stringify(u.animatedSymbolProperties)}`).toString(),ie=N(u.markerPlacement,ft,U,W),ue=function J(u,R,U,ft){const W=[];if(_t.E0.findApplicableOverrides(u,R,W),null==u||0===W.length)return u;for(const mt of W)if(mt.valueExpressionInfo&&ft?.geometryType){const rt=U[mt.primitiveName]&&U[mt.primitiveName][mt.propertyName];rt instanceof Lt.mz&&(mt.fn=(nt,st,xt)=>(0,jt.Z)(rt,nt,{$view:xt},ft.geometryType,st))}return(mt,rt,nt)=>{for(const kt of W)kt.fn&&(kt.value=kt.fn(mt,rt,nt));const st=(0,zt.d9)(u),xt=u.primitiveName;for(const kt of W)if(kt.primitiveName===xt){const Ht=S(kt.propertyName);if(null!=kt.value){const Ot=at(kt.value,kt.propertyName);Ot!==st[Ht]&&(st[Ht]=Ot)}}return st}}(u.animatedSymbolProperties,ft,U,W),[be,Me]=lt(ft,xt,R,ie,ue),fe=(0,Mt.hP)(JSON.stringify(u)+Me).toString(),we=u.anchorPoint??{x:0,y:0};if("width"in u&&"number"==typeof u.width){const _e=u.width;let me=1;const ve=mt.getResource(u.url);(0,q.pC)(ve)&&(me=ve.width/ve.height),Ht/=me*(kt/_e)}function ge(_e,me){return(0,q.pC)(ue)?(0,Q.hf)(ue,_e,me):null}rt.push({type:"marker",templateHash:fe,materialHash:u.animatedSymbolProperties&&!0===u.animatedSymbolProperties.randomizeStartTime?(_e,me,ve,ze)=>{const Ae=function he(u){return Math.floor(function se(u,R){let U;if("string"==typeof u)U=(0,Mt.hP)(u+`-seed(${R})`);else{let ft=12;U=u^R;do{U=107*(U>>8^U)+ft|0}while(0!=--ft)}return(1+U/(1<<31))/2}(u,it)*Ct)}(ze??0),Ne=ge(_e,me);return Jt+`-MATERIALGROUP(${Ae})-ASP(${JSON.stringify(Ne)})`}:be?(_e,me)=>{const ve=ge(_e,me);return Jt+`-ASP(${JSON.stringify(ve)})`}:Jt,cim:u,materialOverrides:null,colorLocked:!!u.colorLocked,effects:R,scaleSymbolsProportionally:!1,alignment:nt,size:T(xt,U,"Size",W,kt),scaleX:T(xt,U,"ScaleX",W,Ht),rotation:T(xt,U,"Rotation",W,Ot),offsetX:T(xt,U,"OffsetX",W,Nt),offsetY:T(xt,U,"OffsetY",W,le),color:T(xt,U,"TintColor",W,Qt,Tt),anchorPoint:{x:we.x,y:-we.y},isAbsoluteAnchorPoint:"Relative"!==u.anchorPointUnits,outlineColor:{r:0,g:0,b:0,a:0},outlineWidth:0,frameHeight:0,rotateClockwise:!!u.rotateClockwise,referenceSize:st,sizeRatio:1,markerPlacement:ie,url:u.url,animatedSymbolProperties:ue})}function k(u,R,U,ft,W,mt,rt,nt,st,xt){const kt=u.markerGraphics;if(!kt)return;let Ht=0;if(u.scaleSymbolsProportionally){const Nt=u.frame;Nt&&(Ht=Nt.ymax-Nt.ymin)}const Ot=N(u.markerPlacement,ft,U,W);for(const Nt of kt)if(Nt){const le=Nt.symbol;if(!le)continue;switch(le.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":A(u,R,Ot,null,Nt,ft,U,W,mt,rt,nt,st,Ht,!!xt);break;case"CIMTextSymbol":Y(u,R,Ot,Nt,U,ft,W,mt,nt,st,Ht)}}}function Y(u,R,U,ft,W,mt,rt,nt,st,xt,kt){_t.E0.findApplicableOverrides(ft,mt,[]);const Ot=ft.geometry;if(!("x"in Ot)||!("y"in Ot))return;const Nt=ft.symbol,le=(0,Q.BX)(Nt),Qt=(0,Q.wi)(Nt.fontStyleName),Jt=(0,Ut.BN)(Nt.fontFamilyName);Nt.font={family:Jt,decoration:le,...Qt};const ie=u.frame,ue=Ot.x-.5*(ie.xmin+ie.xmax),be=Ot.y-.5*(ie.ymin+ie.ymax),Me=u.size/kt,fe=u.primitiveName,we=(0,Q.NA)(Nt.height)*Me,ge=(0,Q.NA)(Nt.angle),Ce=(0,Q.NA)(u.offsetX)+((0,Q.NA)(Nt.offsetX)+ue)*Me,_e=(0,Q.NA)(u.offsetY)+((0,Q.NA)(Nt.offsetY)+be)*Me,me=(0,Q.NO)((0,Q.W7)(Nt));let ve=(0,Q.NO)((0,Q.$Z)(Nt)),ze=(0,Q.F)(Nt)??0;ze||(ve=(0,Q.NO)((0,Q.W7)(Nt.haloSymbol)),Nt.haloSize&&(ze=Nt.haloSize*Me));let Ae=null,Ne=null,Fe=0;if(Nt.callout&&"CIMBackgroundCallout"===Nt.callout.type){const Xe=Nt.callout;if(Xe.backgroundSymbol){const He=Xe.backgroundSymbol.symbolLayers;if(He)for(const Ie of He)"CIMSolidFill"===Ie.type?Ae=(0,Q.NO)(Ie.color):"CIMSolidStroke"===Ie.type&&(Ne=(0,Q.NO)(Ie.color),Fe=(0,Q.NA)(Ie.width))}}const[Ue,Oe]=lt(mt,fe,R,U,null),ke=JSON.stringify(u.effects)+Number(u.colorLocked).toString()+JSON.stringify(u.anchorPoint)+u.anchorPointUnits+JSON.stringify(u.markerPlacement)+u.size.toString(),Ge=(0,Mt.hP)(JSON.stringify(ft)+ke+Oe).toString();let ye=T(ft.primitiveName,W,"TextString",rt,ft.textString??"",Q.QI,Nt.textCase);if(null==ye)return;const{fontStyleName:De}=Nt,Se=Jt+(De?"-"+De.toLowerCase():"-regular"),Be=Se;"string"==typeof ye&&ye.includes("[")&&Nt.fieldMap&&(ye=(0,Q.Qs)(Nt.fieldMap,ye,Nt.textCase)),nt.push({type:"text",templateHash:Ge,materialHash:Ue||"function"==typeof ye||ye.match(/\[(.*?)\]/)?(Xe,He,Ie)=>Be+"-"+(0,Q.hf)(ye,Xe,He,Ie):Be+"-"+(0,Mt.hP)(ye),cim:Nt,materialOverrides:null,colorLocked:!!u.colorLocked,effects:R,alignment:st,anchorPoint:{x:u.anchorPoint?u.anchorPoint.x:0,y:u.anchorPoint?u.anchorPoint.y:0},isAbsoluteAnchorPoint:"Relative"!==u.anchorPointUnits,fontName:Se,decoration:le,weight:T(fe,W,"Weight",rt,Qt.weight),style:T(fe,W,"Size",rt,Qt.style),size:T(fe,W,"Size",rt,we),angle:T(fe,W,"Rotation",rt,ge),offsetX:T(fe,W,"OffsetX",rt,Ce),offsetY:T(fe,W,"OffsetY",rt,_e),horizontalAlignment:(0,Q.X_)(Nt.horizontalAlignment),verticalAlignment:(0,Q.FG)(Nt.verticalAlignment),text:ye,color:me,outlineColor:ve,outlineSize:ze,backgroundColor:Ae,borderLineColor:Ne,borderLineWidth:Fe,referenceSize:xt,sizeRatio:1,markerPlacement:U})}function A(u,R,U,ft,W,mt,rt,nt,st,xt,kt,Ht,Ot,Nt){const le=W.symbol,Qt=le.symbolLayers;if(!Qt)return;if(Nt)return void ht(u,R,U,ft,W,rt,mt,nt,st,xt,kt,Ht,Ot);let Jt=Qt.length;if(F(Qt))return void function j(u,R,U,ft,W,mt,rt,nt,st,xt,kt,Ht,Ot){const Nt=W.geometry,le=mt[0],Qt=mt[1],Jt=(0,Et.bk)(Nt);if(!Jt)return;const ie="Relative"!==u.anchorPointUnits,[ue,be,Me]=(0,Et.UV)(Jt,u.frame,u.size,u.anchorPoint,ie),fe={type:"sdf",geom:Nt,asFill:!0},we=u.primitiveName,ge=(0,Q.NA)(u.size),Ce=(0,Q.NA)(u.rotation),_e=(0,Q.NA)(u.offsetX),me=(0,Q.NA)(u.offsetY),ve=Qt.path,ze=Qt.primitiveName,Ae=le.primitiveName,Ne=(0,Q.NO)((0,Q.W7)(Qt)),Fe=(0,Q.NO)((0,Q.$Z)(le)),Ue=(0,Q.F)(le)??0;let Oe=!1,ke="";for(const Se of rt)Se.primitiveName!==ze&&Se.primitiveName!==Ae&&Se.primitiveName!==we||(void 0!==Se.value?ke+=`-${Se.primitiveName}-${Se.propertyName}-${JSON.stringify(Se.value)}`:Se.valueExpressionInfo&&(Oe=!0));(0,q.pC)(U)&&"function"==typeof U&&(Oe=!0);const Ge=JSON.stringify({...u,markerGraphics:null}),ye=(0,Mt.hP)(JSON.stringify(fe)+ve).toString(),De={type:"marker",templateHash:(0,Mt.hP)(JSON.stringify(W)+JSON.stringify(Qt)+JSON.stringify(le)+Ge+ke).toString(),materialHash:Oe?()=>ye:ye,cim:fe,materialOverrides:null,colorLocked:!!u.colorLocked,effects:R,scaleSymbolsProportionally:!!u.scaleSymbolsProportionally,alignment:kt,anchorPoint:{x:be,y:Me},isAbsoluteAnchorPoint:ie,size:T(u.primitiveName,nt,"Size",st,ge),rotation:T(u.primitiveName,nt,"Rotation",st,Ce),offsetX:T(u.primitiveName,nt,"OffsetX",st,_e),offsetY:T(u.primitiveName,nt,"OffsetY",st,me),scaleX:1,frameHeight:Ot,rotateClockwise:!!u.rotateClockwise,referenceSize:Ht,sizeRatio:ue,color:T(ze,nt,"Color",st,Ne,Tt),outlineColor:T(Ae,nt,"Color",st,Fe,Tt),outlineWidth:T(Ae,nt,"Width",st,Ue),markerPlacement:U,path:ve,animatedSymbolProperties:ft};xt.push(De)}(u,R,U,ft,W,Qt,mt,rt,nt,st,kt,Ht,Ot);const ie=$t.j.applyEffects(le.effects,W.geometry,xt.geometryEngine);if(ie)for(;Jt--;){const ue=Qt[Jt];if(ue&&!1!==ue.enable)switch(ue.type){case"CIMSolidFill":case"CIMSolidStroke":{const be=$t.j.applyEffects(ue.effects,ie,xt.geometryEngine),Me=(0,Et.bk)(be);if(!Me)continue;const fe="Relative"!==u.anchorPointUnits,[we,ge,Ce]=(0,Et.UV)(Me,u.frame,u.size,u.anchorPoint,fe),_e="CIMSolidFill"===ue.type,me={type:"sdf",geom:be,asFill:_e},ve=u.primitiveName,ze=(0,Q.NA)(u.size)??10,Ae=(0,Q.NA)(u.rotation),Ne=(0,Q.NA)(u.offsetX),Fe=(0,Q.NA)(u.offsetY),Ue=ue.path,Oe=ue.primitiveName,ke=(0,Q.NO)(_e?(0,Q.W7)(ue):(0,Q.$Z)(ue)),Ge=_e?{r:0,g:0,b:0,a:0}:(0,Q.NO)((0,Q.$Z)(ue)),ye=(0,Q.F)(ue)??0;if(!_e&&!ye)break;let De=!1,Se="";for(const Ie of mt)Ie.primitiveName!==Oe&&Ie.primitiveName!==ve||(void 0!==Ie.value?Se+=`-${Ie.primitiveName}-${Ie.propertyName}-${JSON.stringify(Ie.value)}`:Ie.valueExpressionInfo&&(De=!0));((0,q.pC)(R)&&"function"==typeof R||(0,q.pC)(U)&&"function"==typeof U)&&(De=!0);const Be=JSON.stringify({...u,markerGraphics:null}),Xe=(0,Mt.hP)(JSON.stringify(me)+Ue).toString(),He={type:"marker",templateHash:(0,Mt.hP)(JSON.stringify(W)+JSON.stringify(ue)+Be+Se).toString(),materialHash:De?()=>Xe:Xe,cim:me,materialOverrides:null,colorLocked:!!u.colorLocked,effects:R,scaleSymbolsProportionally:!!u.scaleSymbolsProportionally,alignment:kt,anchorPoint:{x:ge,y:Ce},isAbsoluteAnchorPoint:fe,size:T(u.primitiveName,rt,"Size",nt,ze),rotation:T(u.primitiveName,rt,"Rotation",nt,Ae),offsetX:T(u.primitiveName,rt,"OffsetX",nt,Ne),offsetY:T(u.primitiveName,rt,"OffsetY",nt,Fe),scaleX:1,frameHeight:Ot,rotateClockwise:!!u.rotateClockwise,referenceSize:Ht,sizeRatio:we,color:T(Oe,rt,"Color",nt,ke,Tt),outlineColor:T(Oe,rt,"Color",nt,Ge,Tt),outlineWidth:T(Oe,rt,"Width",nt,ye),markerPlacement:U,animatedSymbolProperties:ft,path:Ue};st.push(He);break}default:ht(u,R,U,ft,W,rt,mt,nt,st,xt,kt,Ht,Ot)}}}function ht(u,R,U,ft,W,mt,rt,nt,st,xt,kt,Ht,Ot){const Nt=function K(u,R){return{type:u.type,enable:!0,name:u.name,colorLocked:u.colorLocked,primitiveName:u.primitiveName,anchorPoint:u.anchorPoint,anchorPointUnits:u.anchorPointUnits,offsetX:0,offsetY:0,rotateClockwise:u.rotateClockwise,rotation:0,size:u.size,billboardMode3D:u.billboardMode3D,depth3D:u.depth3D,frame:u.frame,markerGraphics:[R],scaleSymbolsProportionally:u.scaleSymbolsProportionally,respectFrame:u.respectFrame,clippingPath:u.clippingPath}}(u,W),le=["Rotation","OffsetX","OffsetY"],Qt=rt.filter(me=>me.primitiveName!==u.primitiveName||!le.includes(me.propertyName));let Jt="";for(const me of rt)void 0!==me.value&&(Jt+=`-${me.primitiveName}-${me.propertyName}-${JSON.stringify(me.value)}`);const[ie,ue,be]=_t.B$.getTextureAnchor(Nt,xt),Me=u.primitiveName,fe=(0,Q.NA)(u.rotation),we=(0,Q.NA)(u.offsetX),ge=(0,Q.NA)(u.offsetY),Ce=(0,Mt.hP)(JSON.stringify(Nt)+Jt).toString(),_e={type:"marker",templateHash:Ce,materialHash:Qt.length>0||(0,q.pC)(R)&&"function"==typeof R?O(Ce,mt,Qt,nt):Ce,cim:Nt,materialOverrides:Qt,colorLocked:!!u.colorLocked,effects:R,scaleSymbolsProportionally:!!u.scaleSymbolsProportionally,alignment:kt,anchorPoint:{x:ie,y:ue},isAbsoluteAnchorPoint:!1,size:(0,Q.NA)(u.size),rotation:T(Me,mt,"Rotation",nt,fe),offsetX:T(Me,mt,"OffsetX",nt,we),offsetY:T(Me,mt,"OffsetY",nt,ge),color:{r:255,g:255,b:255,a:1},outlineColor:{r:0,g:0,b:0,a:0},outlineWidth:0,scaleX:1,frameHeight:Ot,rotateClockwise:!!u.rotateClockwise,referenceSize:Ht,sizeRatio:be/(0,At.F2)(u.size),markerPlacement:U,animatedSymbolProperties:ft,avoidSDFRasterization:!0};st.push(_e)}function bt(u){if(u&&0===u.indexOf("Level_")){const R=parseInt(u.substr(6),10);if(!isNaN(R))return R}return 0}function Tt(u){if(!u||0===u.length)return null;const R=new gt.Z(u).toRgba();return{r:R[0],g:R[1],b:R[2],a:R[3]}}function T(u,R,U,ft,W,mt,rt){if(null==u)return W;const nt=R[u];if(nt){const st=nt[U];if("string"==typeof st||"number"==typeof st||st instanceof Array)return mt?mt.call(null,st,rt):st;if(null!=st&&st instanceof Lt.mz&&ft?.geometryType)return(xt,kt,Ht)=>{let Ot=(0,jt.Z)(st,xt,{$view:Ht},ft.geometryType,kt);return null!==Ot&&mt&&(Ot=mt.call(null,Ot,rt)),null!==Ot?Ot:W}}return W}function S(u){return u&&u.charAt(0).toLowerCase()+u.substr(1)}function L(u,R,U,ft){for(const W of R)if(W.valueExpressionInfo&&ft?.geometryType){const mt=U[W.primitiveName]&&U[W.primitiveName][W.propertyName];mt instanceof Lt.mz&&(W.fn=(rt,nt,st)=>(0,jt.Z)(mt,rt,{$view:st},ft.geometryType,nt))}return(W,mt,rt)=>{for(const st of R)st.fn&&(st.value=st.fn(W,mt,rt));const nt=[];for(let st of u){const xt=st?.primitiveName;if(xt){let kt=!1;for(const Ht of R)if(Ht.primitiveName===xt){const Ot=S(Ht.propertyName);null!=Ht.value&&Ht.value!==st[Ot]&&(kt||(st=(0,zt.d9)(st),kt=!0),st[Ot]=Ht.value)}}nt.push(st)}return nt}}function N(u,R,U,ft){const W=[];if(_t.E0.findApplicableOverrides(u,R,W),null==u||0===W.length)return u;for(const mt of W)if(mt.valueExpressionInfo&&ft?.geometryType){const rt=U[mt.primitiveName]&&U[mt.primitiveName][mt.propertyName];rt instanceof Lt.mz&&(mt.fn=(nt,st,xt)=>(0,jt.Z)(rt,nt,{$view:xt},ft.geometryType,st))}return(mt,rt,nt)=>{for(const kt of W)kt.fn&&(kt.value=kt.fn(mt,rt,nt));const st=(0,zt.d9)(u),xt=u.primitiveName;for(const kt of W)if(kt.primitiveName===xt){const Ht=S(kt.propertyName);null!=kt.value&&kt.value!==st[Ht]&&(st[Ht]=kt.value)}return st}}function O(u,R,U,ft){for(const W of U)if(W.valueExpressionInfo&&ft?.geometryType){const mt=R[W.primitiveName]&&R[W.primitiveName][W.propertyName];mt instanceof Lt.mz&&(W.fn=(rt,nt,st)=>(0,jt.Z)(mt,rt,{$view:st},ft.geometryType,nt))}return(W,mt,rt)=>{for(const nt of U)nt.fn&&(nt.value=nt.fn(W,mt,rt));return(0,Mt.hP)(u+_t.E0.buildOverrideKey(U)).toString()}}function $(u,R){if(!R||0===R.length)return u;const U=(0,zt.d9)(u);return _t.E0.applyOverrides(U,R),U}function lt(u,R,U,ft,W){let mt=!1,rt="";for(const nt of u)nt.primitiveName===R&&(void 0!==nt.value?rt+=`-${nt.primitiveName}-${nt.propertyName}-${JSON.stringify(nt.value)}`:nt.valueExpressionInfo&&(mt=!0));return(0,q.pC)(U)&&"function"==typeof U&&(mt=!0),(0,q.pC)(ft)&&"function"==typeof ft&&(mt=!0),(0,q.pC)(W)&&"function"==typeof W&&(mt=!0),[mt,rt]}const F=u=>u&&2===u.length&&u[0].enable&&u[1].enable&&"CIMSolidStroke"===u[0].type&&"CIMSolidFill"===u[1].type&&!u[0].effects&&!u[1].effects},73608:(Te,pe,ut)=>{ut.d(pe,{j:()=>q});var Wt=ut(91179),gt=ut(72283),Ut=ut(29214),zt=ut(95727);class q{static executeEffects(Mt,Lt,_t,St){const Xt=(0,gt.GP)(Lt);let et=new Ut.MU(Xt);for(const at of Mt){const Et=(0,zt.h)(at);Et&&(et=Et.execute(et,at,1.3333333333333333,_t,St))}return et}static next(Mt){const Lt=Mt.next();return(0,gt.wp)(Lt),Lt}static applyEffects(Mt,Lt,_t){if(!Mt)return Lt;let St=new Ut.MU(Lt);for(const et of Mt){const at=(0,zt.h)(et);at&&(St=at.execute(St,et,1,null,_t))}let Xt,Kt=null;for(;Xt=St.next();)Kt?(0,Wt.l9)(Kt)?(0,Wt.l9)(Xt)&&Kt.paths.push(...Xt.paths):(0,Wt.oU)(Kt)&&(0,Wt.oU)(Xt)&&Kt.rings.push(...Xt.rings):Kt=Xt;return Kt}}},40028:(Te,pe,ut)=>{var Wt,gt,_t;function Ut(_t){switch(_t){case"left":return Wt.Left;case"right":return Wt.Right;case"center":return Wt.Center}}function zt(_t){switch(_t){case"top":return gt.Top;case"middle":return gt.Center;case"baseline":return gt.Baseline;case"bottom":return gt.Bottom}}function oe(_t){switch(_t){case"above-left":case"esriServerPointLabelPlacementAboveLeft":return[Wt.Right,gt.Bottom];case"above-center":case"above-along":case"esriServerPointLabelPlacementAboveCenter":case"esriServerLinePlacementAboveAlong":return[Wt.Center,gt.Bottom];case"above-right":case"esriServerPointLabelPlacementAboveRight":return[Wt.Left,gt.Bottom];case"center-left":case"esriServerPointLabelPlacementCenterLeft":return[Wt.Right,gt.Center];case"center-center":case"center-along":case"esriServerPointLabelPlacementCenterCenter":case"esriServerLinePlacementCenterAlong":case"always-horizontal":case"esriServerPolygonPlacementAlwaysHorizontal":return[Wt.Center,gt.Center];case"center-right":case"esriServerPointLabelPlacementCenterRight":return[Wt.Left,gt.Center];case"below-left":case"esriServerPointLabelPlacementBelowLeft":return[Wt.Right,gt.Top];case"below-center":case"below-along":case"esriServerPointLabelPlacementBelowCenter":case"esriServerLinePlacementBelowAlong":return[Wt.Center,gt.Top];case"below-right":case"esriServerPointLabelPlacementBelowRight":return[Wt.Left,gt.Top];default:return console.debug(`Found invalid placement type ${_t}`),[Wt.Center,gt.Center]}}function q(_t){switch(_t){case Wt.Right:return-1;case Wt.Center:return 0;case Wt.Left:return 1;default:return console.debug(`Found invalid horizontal alignment ${_t}`),0}}function At(_t){switch(_t){case gt.Top:return 1;case gt.Center:return 0;case gt.Bottom:case gt.Baseline:return-1;default:return console.debug(`Found invalid vertical alignment ${_t}`),0}}function Mt(_t){switch(_t){case"left":return Wt.Left;case"right":return Wt.Right;case"center":return Wt.Center}}function Lt(_t){switch(_t){case"above-along":case"below-along":case"center-along":case"esriServerLinePlacementAboveAlong":case"esriServerLinePlacementBelowAlong":case"esriServerLinePlacementCenterAlong":return!0;default:return!1}}ut.d(pe,{Hd:()=>Mt,NS:()=>Lt,TR:()=>gt,b7:()=>zt,g:()=>q,kH:()=>Ut,qv:()=>oe,tf:()=>At}),(_t=Wt||(Wt={}))[_t.Left=-1]="Left",_t[_t.Center=0]="Center",_t[_t.Right=1]="Right",function(_t){_t[_t.Top=1]="Top",_t[_t.Center=0]="Center",_t[_t.Bottom=-1]="Bottom",_t[_t.Baseline=2]="Baseline"}(gt||(gt={}))},25797:(Te,pe,ut)=>{ut.d(pe,{Nr:()=>ee});var Wt=ut(23841),gt=ut(31478),Ut=ut(12225),zt=ut(67831),oe=ut(9545),q=ut(40028),At=ut(5254),Mt=ut(84439);class Lt{constructor(ct,yt,pt,Pt){this.center=(0,oe.f)(ct,yt),this.centerT=(0,oe.c)(),this.halfWidth=pt/2,this.halfHeight=Pt/2,this.width=pt,this.height=Pt}get x(){return this.center[0]}get y(){return this.center[1]}get blX(){return this.center[0]+this.halfWidth}get blY(){return this.center[1]+this.halfHeight}get trX(){return this.center[0]-this.halfWidth}get trY(){return this.center[1]-this.halfHeight}get xmin(){return this.x-this.halfWidth}get xmax(){return this.x+this.halfWidth}get ymin(){return this.y-this.halfHeight}get ymax(){return this.y+this.halfHeight}set x(ct){this.center[0]=ct}set y(ct){this.center[1]=ct}clone(){return new Lt(this.x,this.y,this.width,this.height)}serialize(ct){return ct.writeF32(this.center[0]),ct.writeF32(this.center[1]),ct.push(this.width),ct.push(this.height),ct}findCollisionDelta(ct,yt=4){const pt=Math.abs(ct.centerT[0]-this.centerT[0]),Pt=Math.abs(ct.centerT[1]-this.centerT[1]),te=Math.min((ct.halfWidth+this.halfWidth+yt)/pt,(ct.halfHeight+this.halfHeight+yt)/Pt);return Math.log2(te)}extend(ct){const yt=Math.min(this.xmin,ct.xmin),pt=Math.min(this.ymin,ct.ymin),Pt=Math.max(this.xmax,ct.xmax)-yt,vt=Math.max(this.ymax,ct.ymax)-pt,Ft=yt+Pt/2,te=pt+vt/2;this.width=Pt,this.height=vt,this.halfWidth=Pt/2,this.halfHeight=vt/2,this.x=Ft,this.y=te}static deserialize(ct){const yt=ct.readF32(),pt=ct.readF32(),Pt=ct.readInt32(),vt=ct.readInt32();return new Lt(yt,pt,Pt,vt)}}const _t=26,St=4,Xt=_t+St,Kt=_t-6,et=3,at=8,Et=Math.PI/180;class jt{constructor(ct,yt,pt,Pt){this._rotationT=(0,Ut.c)(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const vt=pt.rect,Ft=new Float32Array(8);ct*=Pt,yt*=Pt;const te=pt.code?vt.width*Pt:pt.metrics.width,Zt=pt.code?vt.height*Pt:pt.metrics.height;this.width=te,this.height=Zt,Ft[0]=ct,Ft[1]=yt,Ft[2]=ct+te,Ft[3]=yt,Ft[4]=ct,Ft[5]=yt+Zt,Ft[6]=ct+te,Ft[7]=yt+Zt,this._data=Ft,this._setTextureCoords(vt),this._scale=Pt,this._mosaic=pt,this.x=ct,this.y=yt,this.maxOffset=Math.max(ct+te,yt+Zt)}get mosaic(){return this._mosaic}set angle(ct){this._angle=ct,(0,gt.b)(this._rotationT,-ct),this._setOffsets(this._data)}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(this._data),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:ct,width:yt}=this._mosaic.metrics,pt=yt*this._scale,Pt=Math.abs(ct)*this._scale,vt=new Float32Array(8);vt[0]=this.x,vt[1]=this.y,vt[2]=this.x+pt,vt[3]=this.y,vt[4]=this.x,vt[5]=this.y+Pt,vt[6]=this.x+pt,vt[7]=this.y+Pt;const Ft=(0,gt.m)((0,Ut.c)(),this._rotationT,this._transform);(0,Ut.t)(vt,vt,Ft);let te=1/0,Zt=1/0,ae=0,ce=0;for(let A=0;A<4;A++){const j=vt[2*A],ht=vt[2*A+1];te=Math.min(te,j),Zt=Math.min(Zt,ht),ae=Math.max(ae,j),ce=Math.max(ce,ht)}const wt=ae-te,y=ce-Zt;this._bounds=new Lt(te+wt/2,Zt+y/2,wt,y)}return this._bounds}setTransform(ct){this._transform=ct,this._offsets=null}_setOffsets(ct){this._offsets||(this._offsets={upperLeft:0,upperRight:0,lowerLeft:0,lowerRight:0});const yt=this._offsets,pt=new Float32Array(8),Pt=(0,gt.m)((0,Ut.c)(),this._rotationT,this._transform);(0,Ut.t)(pt,ct,Pt),yt.upperLeft=(0,At.UJ)(pt[0]*at,pt[1]*at),yt.upperRight=(0,At.UJ)(pt[2]*at,pt[3]*at),yt.lowerLeft=(0,At.UJ)(pt[4]*at,pt[5]*at),yt.lowerRight=(0,At.UJ)(pt[6]*at,pt[7]*at)}_setTextureCoords({x:ct,y:yt,width:pt,height:Pt}){this._texcoords={upperLeft:(0,At.UJ)(ct,yt),upperRight:(0,At.UJ)(ct+pt,yt),lowerLeft:(0,At.UJ)(ct,yt+Pt),lowerRight:(0,At.UJ)(ct+pt,yt+Pt)}}}const Yt=(Rt,ct)=>({code:0,page:0,sdf:!0,rect:new Mt.Z(0,0,11,8),textureBinding:ct,metrics:{advance:0,height:4,width:Rt,left:0,top:0}});function se(Rt,ct){return Rt.forEach(yt=>(0,zt.t)(yt,yt,ct)),{upperLeft:(0,At.UJ)(at*Rt[0][0],at*Rt[0][1]),upperRight:(0,At.UJ)(at*Rt[1][0],at*Rt[1][1]),lowerLeft:(0,At.UJ)(at*Rt[2][0],at*Rt[2][1]),lowerRight:(0,At.UJ)(at*Rt[3][0],at*Rt[3][1])}}class he{constructor(ct,yt,pt){this._rotation=0,this._decorate(ct,yt,pt),this.glyphs=ct,this.bounds=this._createBounds(ct),this.isMultiline=yt.length>1,this._hasRotation=0!==pt.angle,this._transform=this._createGlyphTransform(this.bounds,pt),this._borderLineSize=pt.borderLineSize,(pt.borderLineSize||pt.hasBackground)&&([this.bounds,this.background]=this.shapeBackground(this._transform));for(const Pt of ct)Pt.setTransform(this._transform)}setRotation(ct){if(0===ct&&0===this._rotation)return;this._rotation=ct;const yt=this._transform,pt=(0,gt.b)((0,Ut.c)(),ct);(0,gt.m)(yt,pt,yt);for(const Pt of this.glyphs)Pt.setTransform(this._transform)}_decorate(ct,yt,pt){if(!pt.decoration||"none"===pt.decoration||!ct.length)return;const Pt=pt.scale,vt="underline"===pt.decoration?Xt:Kt,Ft=ct[0].textureBinding;for(const te of yt)ct.push(new jt(te.startX*Pt,te.startY*Pt+vt*Pt,Yt((te.width+te.glyphWidthEnd)*Pt,Ft),1))}shapeBackground(ct){const pt=(1.5+(0,Wt.F2)(this._borderLineSize||0))/2,Pt=this._borderLineSize?pt:0,{xmin:vt,ymin:Ft,xmax:te,ymax:Zt,x:ae,y:ce,width:wt,height:y}=this.bounds,k=[vt-8,Ft-8],Y=[te+8,Ft-8],A=[vt-8,Zt+8],j=[te+8,Zt+8],ht=se([[k[0]-pt,k[1]-pt],[Y[0]+pt,Y[1]-pt],[k[0]+Pt,k[1]+Pt],[Y[0]-Pt,Y[1]+Pt]],ct),K=se([[A[0]+Pt,A[1]-Pt],[j[0]-Pt,j[1]-Pt],[A[0]-pt,A[1]+pt],[j[0]+pt,j[1]+pt]],ct),bt=se([[k[0]-pt,k[1]-pt],[k[0]+Pt,k[1]+Pt],[A[0]-pt,A[1]+pt],[A[0]+Pt,A[1]-Pt]],ct),Tt=se([[Y[0]-Pt,Y[1]+Pt],[Y[0]+pt,Y[1]-pt],[j[0]-Pt,j[1]-Pt],[j[0]+pt,j[1]+pt]],ct),T={main:se([k,Y,A,j],ct),top:ht,bot:K,left:bt,right:Tt};return[new Lt(ae,ce,wt+2*pt,y+2*pt),T]}get boundsT(){const ct=this.bounds,yt=(0,zt.s)((0,oe.c)(),ct.x,ct.y);if((0,zt.t)(yt,yt,this._transform),this._hasRotation){const pt=Math.max(ct.width,ct.height);return new Lt(yt[0],yt[1],pt,pt)}return new Lt(yt[0],yt[1],ct.width,ct.height)}_createBounds(ct){let yt=1/0,pt=1/0,Pt=0,vt=0;for(const Zt of ct)yt=Math.min(yt,Zt.xTopLeft),pt=Math.min(pt,Zt.yTopLeft),Pt=Math.max(Pt,Zt.xBottomRight),vt=Math.max(vt,Zt.yBottomRight);const Ft=Pt-yt,te=vt-pt;return new Lt(yt+Ft/2,pt+te/2,Ft,te)}_createGlyphTransform(ct,yt){const pt=Et*yt.angle,Pt=(0,Ut.c)(),vt=(0,oe.c)();return(0,gt.t)(Pt,Pt,(0,zt.s)(vt,yt.xOffset,-yt.yOffset)),yt.isCIM?(0,gt.r)(Pt,Pt,pt):((0,gt.t)(Pt,Pt,(0,zt.s)(vt,ct.x,ct.y)),(0,gt.r)(Pt,Pt,pt),(0,gt.t)(Pt,Pt,(0,zt.s)(vt,-ct.x,-ct.y))),Pt}}class it{constructor(ct,yt,pt,Pt,vt,Ft){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(yt,pt)),this.end=Math.max(0,Math.max(yt,pt)),this.end<ct.length&&(this.glyphWidthEnd=ct[this.end].metrics.width),this.width=Pt,this.yMin=vt,this.yMax=Ft}}const Ct=Rt=>10===Rt,Gt=Rt=>32===Rt;function ee(Rt,ct,yt){const pt=yt.scale,Pt=new Array,vt=function qt(Rt,ct,yt){const pt=new Array,vt=yt.maxLineWidth*(1/yt.scale),Ft=ct?Rt.length-1:0,te=ct?-1:Rt.length,Zt=ct?-1:1;let ae=Ft,ce=0,wt=0,y=ae,k=y,Y=0,A=1/0,j=0;for(;ae!==te;){const{code:K,metrics:bt}=Rt[ae],Tt=Math.abs(bt.top);Ct(K)||Gt(K)||(A=Math.min(A,Tt),j=Math.max(j,Tt+bt.height)),Ct(K)?(ae!==Ft&&(pt.push(new it(Rt,y,ae-Zt,ce,A,j)),A=1/0,j=0),ce=0,y=ae+Zt,k=ae+Zt,wt=0):Gt(K)?(k=ae+Zt,wt=0,Y=bt.advance,ce+=bt.advance):ce>vt?(k!==y?(ce-=Y,pt.push(new it(Rt,y,k-2*Zt,ce-wt,A,j)),A=1/0,j=0,y=k,ce=wt):(pt.push(new it(Rt,y,ae-Zt,ce,A,j)),A=1/0,j=0,y=ae,k=ae,ce=0),ce+=bt.advance,wt+=bt.advance):(ce+=bt.advance,wt+=bt.advance),ae+=Zt}const ht=new it(Rt,y,ae-Zt,ce,A,j);return ht.start>=0&&ht.end<Rt.length&&pt.push(ht),pt}(Rt,ct,yt),Ft=function Dt(Rt,ct){let yt=0;for(let vt=0;vt<Rt.length;vt++){const{width:Ft}=Rt[vt];yt=Math.max(Ft,yt)}const Pt=Rt[0].yMin;return{x:0,y:Pt,height:Rt[Rt.length-1].yMax+ct.lineHeight*(Rt.length-1)+("underline"===ct.decoration?St:0)-Pt,width:yt}}(vt,yt),{vAlign:te,hAlign:Zt}=yt,ae=te===q.TR.Baseline?1:0,wt=(1-ae)*-Ft.y+Ft.height/2*(ae?0:te-1)+(ae?1:0)*-_t;for(let y=0;y<vt.length;y++){const{start:k,end:Y,width:A}=vt[y];let j=-1*(Zt+1)*(A/2)-et;const ht=y*yt.lineHeight+wt-et;vt[y].startX=j,vt[y].startY=ht;for(let K=k;K<=Y;K++){const bt=Rt[K];if(Ct(bt.code))continue;const Tt=new jt(j+bt.metrics.left,ht-bt.metrics.top,bt,pt);j+=bt.metrics.advance,Pt.push(Tt)}}return new he(Pt,vt,yt)}}}]);