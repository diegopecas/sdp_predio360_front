"use strict";(self.webpackChunkpredio360_app=self.webpackChunkpredio360_app||[]).push([[9651],{13160:(pe,ae,x)=>{var X,N,b;x.d(ae,{E9:()=>T,I6:()=>J,Vl:()=>X,bN:()=>H}),(b=X||(X={}))[b.Unknown=0]="Unknown",b[b.Point=1]="Point",b[b.LineString=2]="LineString",b[b.Polygon=3]="Polygon";class T{constructor(r,a){this.x=r,this.y=a}clone(){return new T(this.x,this.y)}equals(r,a){return r===this.x&&a===this.y}isEqual(r){return r.x===this.x&&r.y===this.y}setCoords(r,a){this.x=r,this.y=a}normalize(){const r=this.x,a=this.y,d=Math.sqrt(r*r+a*a);this.x/=d,this.y/=d}rightPerpendicular(){const r=this.x;this.x=this.y,this.y=-r}move(r,a){this.x+=r,this.y+=a}assign(r){this.x=r.x,this.y=r.y}assignAdd(r,a){this.x=r.x+a.x,this.y=r.y+a.y}assignSub(r,a){this.x=r.x-a.x,this.y=r.y-a.y}rotate(r,a){const d=this.x,g=this.y;this.x=d*r-g*a,this.y=d*a+g*r}scale(r){this.x*=r,this.y*=r}length(){const r=this.x,a=this.y;return Math.sqrt(r*r+a*a)}static distance(r,a){const d=a.x-r.x,g=a.y-r.y;return Math.sqrt(d*d+g*g)}static add(r,a){return new T(r.x+a.x,r.y+a.y)}static sub(r,a){return new T(r.x-a.x,r.y-a.y)}}class ne{constructor(r,a,d){this.ratio=r,this.x=a,this.y=d}}class H{constructor(r,a,d,g=8,f=8){this._lines=[],this._starts=[],this.validateTessellation=!0,this._pixelRatio=g,this._pixelMargin=f,this._tileSize=512*g,this._dz=r,this._yPos=a,this._xPos=d}setPixelMargin(r){r!==this._pixelMargin&&(this._pixelMargin=r,this.setExtent(this._extent))}setExtent(r){this._extent=r,this._finalRatio=this._tileSize/r*(1<<this._dz);let a=this._pixelRatio*this._pixelMargin;a/=this._finalRatio;const d=r>>this._dz;a>d&&(a=d),this._margin=a,this._xmin=d*this._xPos-a,this._ymin=d*this._yPos-a,this._xmax=this._xmin+d+2*a,this._ymax=this._ymin+d+2*a}reset(r){this._type=r,this._lines=[],this._starts=[],this._line=null,this._start=0}moveTo(r,a){this._pushLine(),this._prevIsIn=this._isIn(r,a),this._moveTo(r,a,this._prevIsIn),this._prevPt=new T(r,a),this._firstPt=new T(r,a),this._dist=0}lineTo(r,a){const d=this._isIn(r,a),g=new T(r,a),f=T.distance(this._prevPt,g);let y,S,p,_,ie,se,$,q;if(d)this._prevIsIn?this._lineTo(r,a,!0):(y=this._prevPt,S=g,p=this._intersect(S,y),this._start=this._dist+f*(1-this._r),this._lineTo(p.x,p.y,!0),this._lineTo(S.x,S.y,!0));else if(this._prevIsIn)S=this._prevPt,y=g,p=this._intersect(S,y),this._lineTo(p.x,p.y,!0),this._lineTo(y.x,y.y,!1);else{const I=this._prevPt,V=g;if(I.x<=this._xmin&&V.x<=this._xmin||I.x>=this._xmax&&V.x>=this._xmax||I.y<=this._ymin&&V.y<=this._ymin||I.y>=this._ymax&&V.y>=this._ymax)this._lineTo(V.x,V.y,!1);else{const G=[];if((I.x<this._xmin&&V.x>this._xmin||I.x>this._xmin&&V.x<this._xmin)&&(_=(this._xmin-I.x)/(V.x-I.x),q=I.y+_*(V.y-I.y),q<=this._ymin?se=!1:q>=this._ymax?se=!0:G.push(new ne(_,this._xmin,q))),(I.x<this._xmax&&V.x>this._xmax||I.x>this._xmax&&V.x<this._xmax)&&(_=(this._xmax-I.x)/(V.x-I.x),q=I.y+_*(V.y-I.y),q<=this._ymin?se=!1:q>=this._ymax?se=!0:G.push(new ne(_,this._xmax,q))),(I.y<this._ymin&&V.y>this._ymin||I.y>this._ymin&&V.y<this._ymin)&&(_=(this._ymin-I.y)/(V.y-I.y),$=I.x+_*(V.x-I.x),$<=this._xmin?ie=!1:$>=this._xmax?ie=!0:G.push(new ne(_,$,this._ymin))),(I.y<this._ymax&&V.y>this._ymax||I.y>this._ymax&&V.y<this._ymax)&&(_=(this._ymax-I.y)/(V.y-I.y),$=I.x+_*(V.x-I.x),$<=this._xmin?ie=!1:$>=this._xmax?ie=!0:G.push(new ne(_,$,this._ymax))),0===G.length)this._lineTo(ie?this._xmax:this._xmin,se?this._ymax:this._ymin,!0);else if(G.length>1&&G[0].ratio>G[1].ratio)this._start=this._dist+f*G[1].ratio,this._lineTo(G[1].x,G[1].y,!0),this._lineTo(G[0].x,G[0].y,!0);else{this._start=this._dist+f*G[0].ratio;for(let ee=0;ee<G.length;ee++)this._lineTo(G[ee].x,G[ee].y,!0)}this._lineTo(V.x,V.y,!1)}}this._dist+=f,this._prevIsIn=d,this._prevPt=g}close(){if(this._line.length>2){const r=this._firstPt,a=this._prevPt;r.x===a.x&&r.y===a.y||this.lineTo(r.x,r.y);const d=this._line;let g=d.length;for(;g>=4&&(d[0].x===d[1].x&&d[0].x===d[g-2].x||d[0].y===d[1].y&&d[0].y===d[g-2].y);)d.pop(),d[0].x=d[g-2].x,d[0].y=d[g-2].y,--g}}result(r=!0){return this._pushLine(),0===this._lines.length?null:(this._type===X.Polygon&&r&&te.simplify(this._tileSize,this._margin*this._finalRatio,this._lines),this._lines)}resultWithStarts(){if(this._type!==X.LineString)throw new Error("Only valid for lines");this._pushLine();const r=this._lines,a=r.length;if(0===a)return null;const d=[];for(let g=0;g<a;g++)d.push({line:r[g],start:this._starts[g]||0});return d}_isIn(r,a){return r>=this._xmin&&r<=this._xmax&&a>=this._ymin&&a<=this._ymax}_intersect(r,a){let d,g,f;if(a.x>=this._xmin&&a.x<=this._xmax)g=a.y<=this._ymin?this._ymin:this._ymax,f=(g-r.y)/(a.y-r.y),d=r.x+f*(a.x-r.x);else if(a.y>=this._ymin&&a.y<=this._ymax)d=a.x<=this._xmin?this._xmin:this._xmax,f=(d-r.x)/(a.x-r.x),g=r.y+f*(a.y-r.y);else{g=a.y<=this._ymin?this._ymin:this._ymax,d=a.x<=this._xmin?this._xmin:this._xmax;const y=(d-r.x)/(a.x-r.x),S=(g-r.y)/(a.y-r.y);y<S?(f=y,g=r.y+y*(a.y-r.y)):(f=S,d=r.x+S*(a.x-r.x))}return this._r=f,new T(d,g)}_pushLine(){this._line&&(this._type===X.Point?this._line.length>0&&(this._lines.push(this._line),this._starts.push(this._start)):this._type===X.LineString?this._line.length>1&&(this._lines.push(this._line),this._starts.push(this._start)):this._type===X.Polygon&&this._line.length>3&&(this._lines.push(this._line),this._starts.push(this._start))),this._line=[],this._start=0}_moveTo(r,a,d){this._type!==X.Polygon?d&&(r=Math.round((r-(this._xmin+this._margin))*this._finalRatio),a=Math.round((a-(this._ymin+this._margin))*this._finalRatio),this._line.push(new T(r,a))):(d||(r<this._xmin&&(r=this._xmin),r>this._xmax&&(r=this._xmax),a<this._ymin&&(a=this._ymin),a>this._ymax&&(a=this._ymax)),r=Math.round((r-(this._xmin+this._margin))*this._finalRatio),a=Math.round((a-(this._ymin+this._margin))*this._finalRatio),this._line.push(new T(r,a)),this._isH=!1,this._isV=!1)}_lineTo(r,a,d){let g,f;if(this._type!==X.Polygon)if(d){if(r=Math.round((r-(this._xmin+this._margin))*this._finalRatio),a=Math.round((a-(this._ymin+this._margin))*this._finalRatio),this._line.length>0&&(g=this._line[this._line.length-1],g.equals(r,a)))return;this._line.push(new T(r,a))}else this._line&&this._line.length>0&&this._pushLine();else if(d||(r<this._xmin&&(r=this._xmin),r>this._xmax&&(r=this._xmax),a<this._ymin&&(a=this._ymin),a>this._ymax&&(a=this._ymax)),r=Math.round((r-(this._xmin+this._margin))*this._finalRatio),a=Math.round((a-(this._ymin+this._margin))*this._finalRatio),this._line&&this._line.length>0){g=this._line[this._line.length-1];const y=g.x===r,S=g.y===a;if(y&&S)return;this._isH&&y||this._isV&&S?(g.x=r,g.y=a,f=this._line[this._line.length-2],f.x===r&&f.y===a?(this._line.pop(),this._line.length<=1?(this._isH=!1,this._isV=!1):(f=this._line[this._line.length-2],this._isH=f.x===r,this._isV=f.y===a)):(this._isH=f.x===r,this._isV=f.y===a)):(this._line.push(new T(r,a)),this._isH=y,this._isV=S)}else this._line.push(new T(r,a))}}class J{setExtent(r){this._ratio=4096===r?1:4096/r}get validateTessellation(){return this._ratio<1}reset(r){this._lines=[],this._line=null}moveTo(r,a){this._line&&this._lines.push(this._line),this._line=[];const d=this._ratio;this._line.push(new T(r*d,a*d))}lineTo(r,a){const d=this._ratio;this._line.push(new T(r*d,a*d))}close(){const r=this._line;r&&!r[0].isEqual(r[r.length-1])&&r.push(r[0])}result(){return this._line&&this._lines.push(this._line),0===this._lines.length?null:this._lines}}!function(b){b[b.sideLeft=0]="sideLeft",b[b.sideRight=1]="sideRight",b[b.sideTop=2]="sideTop",b[b.sideBottom=3]="sideBottom"}(N||(N={}));class te{static simplify(r,a,d){if(!d)return;const g=-a,f=r+a,y=-a,S=r+a,p=[],_=[],ie=d.length;for(let $=0;$<ie;++$){const q=d[$];if(!q||q.length<2)continue;let I,V=q[0];const G=q.length;for(let ee=1;ee<G;++ee)I=q[ee],V.x===I.x&&(V.x<=g&&(V.y>I.y?(p.push($),p.push(ee),p.push(N.sideLeft),p.push(-1)):(_.push($),_.push(ee),_.push(N.sideLeft),_.push(-1))),V.x>=f&&(V.y<I.y?(p.push($),p.push(ee),p.push(N.sideRight),p.push(-1)):(_.push($),_.push(ee),_.push(N.sideRight),_.push(-1)))),V.y===I.y&&(V.y<=y&&(V.x<I.x?(p.push($),p.push(ee),p.push(N.sideTop),p.push(-1)):(_.push($),_.push(ee),_.push(N.sideTop),_.push(-1))),V.y>=S&&(V.x>I.x?(p.push($),p.push(ee),p.push(N.sideBottom),p.push(-1)):(_.push($),_.push(ee),_.push(N.sideBottom),_.push(-1)))),V=I}if(0===p.length||0===_.length)return;te.fillParent(d,_,p),te.fillParent(d,p,_);const se=[];te.calcDeltas(se,_,p),te.calcDeltas(se,p,_),te.addDeltas(se,d)}static fillParent(r,a,d){const g=d.length,f=a.length;for(let y=0;y<f;y+=4){const S=a[y],p=a[y+1],_=a[y+2],ie=r[S][p-1],se=r[S][p];let $=8092,q=-1;for(let I=0;I<g;I+=4){if(d[I+2]!==_)continue;const V=d[I],G=d[I+1],ee=r[V][G-1],me=r[V][G];switch(_){case N.sideLeft:case N.sideRight:if(Q(ie.y,ee.y,me.y)&&Q(se.y,ee.y,me.y)){const de=Math.abs(me.y-ee.y);de<$&&($=de,q=I)}break;case N.sideTop:case N.sideBottom:if(Q(ie.x,ee.x,me.x)&&Q(se.x,ee.x,me.x)){const de=Math.abs(me.x-ee.x);de<$&&($=de,q=I)}}}a[y+3]=q}}static calcDeltas(r,a,d){const g=a.length;for(let f=0;f<g;f+=4){const S=te.calcDelta(f,a,d,[]);r.push(a[f]),r.push(a[f+1]),r.push(a[f+2]),r.push(S)}}static calcDelta(r,a,d,g){const f=a[r+3];if(-1===f)return 0;const y=g.length;return y>1&&g[y-2]===f?0:(g.push(f),te.calcDelta(f,d,a,g)+1)}static addDeltas(r,a){const d=r.length;let g=0;for(let f=0;f<d;f+=4){const y=r[f+3];y>g&&(g=y)}for(let f=0;f<d;f+=4){const y=a[r[f]],S=r[f+1],p=g-r[f+3];switch(r[f+2]){case N.sideLeft:y[S-1].x-=p,y[S].x-=p,1===S&&(y[y.length-1].x-=p),S===y.length-1&&(y[0].x-=p);break;case N.sideRight:y[S-1].x+=p,y[S].x+=p,1===S&&(y[y.length-1].x+=p),S===y.length-1&&(y[0].x+=p);break;case N.sideTop:y[S-1].y-=p,y[S].y-=p,1===S&&(y[y.length-1].y-=p),S===y.length-1&&(y[0].y-=p);break;case N.sideBottom:y[S-1].y+=p,y[S].y+=p,1===S&&(y[y.length-1].y+=p),S===y.length-1&&(y[0].y+=p)}}}}const Q=(b,r,a)=>b>=r&&b<=a||b>=a&&b<=r},26996:(pe,ae,x)=>{x.d(ae,{Y:()=>T,m:()=>ne});var j=x(36161),X=x(21286);const N=H=>"vertical"===H||"horizontal"===H||"cross"===H||"esriSFSCross"===H||"esriSFSVertical"===H||"esriSFSHorizontal"===H;function T(H,J,te){const Q=(0,X.fp)(Math.ceil(te)),b=N(J)?8*Q:16*Q,r=2*Q;H.width=b,H.height=b;const a=H.getContext("2d");a.strokeStyle="#FFFFFF",a.lineWidth=Q,a.beginPath(),"vertical"!==J&&"cross"!==J&&"esriSFSCross"!==J&&"esriSFSVertical"!==J||(a.moveTo(b/2,-r),a.lineTo(b/2,b+r)),"horizontal"!==J&&"cross"!==J&&"esriSFSCross"!==J&&"esriSFSHorizontal"!==J||(a.moveTo(-r,b/2),a.lineTo(b+r,b/2)),"forward-diagonal"!==J&&"diagonal-cross"!==J&&"esriSFSDiagonalCross"!==J&&"esriSFSForwardDiagonal"!==J||(a.moveTo(-r,-r),a.lineTo(b+r,b+r),a.moveTo(b-r,-r),a.lineTo(b+r,r),a.moveTo(-r,b-r),a.lineTo(r,b+r)),"backward-diagonal"!==J&&"diagonal-cross"!==J&&"esriSFSBackwardDiagonal"!==J&&"esriSFSDiagonalCross"!==J||(a.moveTo(b+r,-r),a.lineTo(-r,b+r),a.moveTo(r,-r),a.lineTo(-r,r),a.moveTo(b+r,b-r),a.lineTo(b-r,b+r)),a.stroke();const d=a.getImageData(0,0,H.width,H.height),g=new Uint8Array(d.data);let f;for(let y=0;y<g.length;y+=4)f=g[y+3]/255,g[y]=g[y]*f,g[y+1]=g[y+1]*f,g[y+2]=g[y+2]*f;return[g,H.width,H.height]}function ne(H,J){const te="Butt"===J,Q="Square"===J,b=!te&&!Q;H.length%2==1&&(H=[...H,...H]);const r=15.5;let d=0;for(const q of H)d+=q;const g=Math.round(d*r),f=new Float32Array(31*g),y=7.75;let S=0,p=0,_=.5,ie=!0;for(const q of H){for(S=p,p+=q*r;_<=p;){let I=.5;for(;I<31;){const V=(I-.5)*g+_-.5,G=b?(I-r)*(I-r):Math.abs(I-r);f[V]=ie?te?Math.max(Math.max(S+y-_,G),Math.max(_-p+y,G)):G:b?Math.min((_-S)*(_-S)+G,(_-p)*(_-p)+G):Q?Math.min(Math.max(_-S,G),Math.max(p-_,G)):Math.min(Math.max(_-S+y,G),Math.max(p+y-_,G)),I++}_++}ie=!ie}const se=f.length,$=new Uint8Array(4*se);for(let q=0;q<se;++q){const I=(b?Math.sqrt(f[q]):f[q])/r;(0,j.I)(I,$,4*q)}return[$,g,31]}},86575:(pe,ae,x)=>{x.d(ae,{B1:()=>j,DQ:()=>te,DT:()=>H,JJ:()=>X,Or:()=>Q,_U:()=>N,k3:()=>r,sX:()=>d});const j=Number.POSITIVE_INFINITY,X=Math.PI,N=2*X,T=128/X,H=X/180,J=1/Math.LN2;function te(f,y){return(f%=y)>=0?f:f+y}function Q(f){return te(f*T,256)}function r(f){return Math.log(f)*J}function d(f,y,S){return f*(1-S)+y*S}},84439:(pe,ae,x)=>{x.d(ae,{Z:()=>j});class j{constructor(N=0,T=0,ne=0,H=0){this.x=N,this.y=T,this.width=ne,this.height=H}get isEmpty(){return this.width<=0||this.height<=0}union(N){this.x=Math.min(this.x,N.x),this.y=Math.min(this.y,N.y),this.width=Math.max(this.width,N.width),this.height=Math.max(this.height,N.height)}}},5254:(pe,ae,x)=>{x.d(ae,{Au:()=>a,Jz:()=>f,UJ:()=>g});const j=new Float32Array(1);function a(p){return[255&p,(65280&p)>>>8,(16711680&p)>>>16,(4278190080&p)>>>24]}function g(p,_){return 65535&p|_<<16}function f(p,_,ie,se){return 255&p|(255&_)<<8|(255&ie)<<16|se<<24}new Uint32Array(j.buffer)},19702:(pe,ae,x)=>{x.d(ae,{A:()=>r});var j=x(15861),X=x(17626),N=x(54024),T=x(10699),ne=x(32917),H=x(77712),Q=(x(90912),x(85931),x(76898)),b=x(36947);const r=a=>{let d=class extends a{constructor(){super(...arguments),this.slicePlaneEnabled=!1,this.supportsHeightUnitConversion=!1}postscript(g){super.postscript(g),(0,b.qC)(this.layer)&&this.addResolvingPromise(this._validateHeightModelInfo())}_validateHeightModelInfo(){var g=this;return(0,j.Z)(function*(){const f=new AbortController,y=f.signal;g.handles.add((0,N.kB)(()=>f.abort())),yield(0,ne.N1)(()=>g.view.defaultsFromMap?.heightModelInfoReady,y),(0,T.k_)(y);const S=(0,b.Wt)(g.layer,g.view.heightModelInfo,g.supportsHeightUnitConversion);if(S)throw S})()}canResume(){const g=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return super.canResume()&&(!g||!g.minScale||!g.maxScale||g.minScale>=g.maxScale)}getSuspendInfo(){const g=super.getSuspendInfo(),f=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return f&&f.minScale&&f.maxScale&&f.minScale<f.maxScale&&(g.outsideScaleRange=!0),g}};return(0,X._)([(0,H.Cb)()],d.prototype,"view",void 0),(0,X._)([(0,H.Cb)()],d.prototype,"slicePlaneEnabled",void 0),d=(0,X._)([(0,Q.j)("esri.views.3d.layers.LayerView3D")],d),d}},63038:(pe,ae,x)=>{x.r(ae),x.d(ae,{default:()=>Lt});var j=x(15861),X=x(17626),N=x(26584),T=x(62208),ne=x(10699),H=x(32917),J=x(77712),b=(x(90912),x(85931),x(76898));class r{constructor(e,i){this._lockedSchemaPixelSize=e,this._isGCS=i}getLevelRowColumn(e){return this._isGCS?[e[0],e[1]>>1,e[2]>>1]:256===this._lockedSchemaPixelSize&&e[0]>0?[e[0]-1,e[1]>>1,e[2]>>1]:e}adjustLevel(e){return this._isGCS?e:256===this._lockedSchemaPixelSize?e>0?e-1:0:e}getShift(e,i){let t=0,n=0;return(256===this._lockedSchemaPixelSize||this._isGCS)&&(e[2]%2&&(t=i),e[1]%2&&(n=i)),[t,n]}getScale(e){if(this._isGCS){if(512===this._lockedSchemaPixelSize)return 4}else if(256===this._lockedSchemaPixelSize&&0===e)return 1;return 2}}var a=x(1036),d=x(49966),g=x(65401),f=x(21726),y=x(59289),S=x(84439);class p{constructor(e,i){this._width=0,this._height=0,this._free=[],this._width=e,this._height=i,this._free.push(new S.Z(0,0,e,i))}get width(){return this._width}get height(){return this._height}allocate(e,i){if(e>this._width||i>this._height)return new S.Z;let t=null,n=-1;for(let s=0;s<this._free.length;++s){const o=this._free[s];e<=o.width&&i<=o.height&&(null===t||o.y<=t.y&&o.x<=t.x)&&(t=o,n=s)}return null===t?new S.Z:(this._free.splice(n,1),t.width<t.height?(t.width>e&&this._free.push(new S.Z(t.x+e,t.y,t.width-e,i)),t.height>i&&this._free.push(new S.Z(t.x,t.y+i,t.width,t.height-i))):(t.width>e&&this._free.push(new S.Z(t.x+e,t.y,t.width-e,t.height)),t.height>i&&this._free.push(new S.Z(t.x,t.y+i,e,t.height-i))),new S.Z(t.x,t.y,e,i))}release(e){for(let i=0;i<this._free.length;++i){const t=this._free[i];if(t.y===e.y&&t.height===e.height&&t.x+t.width===e.x)t.width+=e.width;else if(t.x===e.x&&t.width===e.width&&t.y+t.height===e.y)t.height+=e.height;else if(e.y===t.y&&e.height===t.height&&e.x+e.width===t.x)t.x=e.x,t.width+=e.width;else{if(e.x!==t.x||e.width!==t.width||e.y+e.height!==t.y)continue;t.y=e.y,t.height+=e.height}this._free.splice(i,1),this.release(e)}this._free.push(e)}}var _=x(67969),ie=x(55086);class se{constructor(e,i,t){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=e,this.height=i,this._glyphSource=t,this._binPack=new p(e-4,i-4),this._glyphData.push(new Uint8Array(e*i)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(e,i){const t=[],n=this._glyphSource,s=new Set;for(const h of i){const c=Math.floor(.00390625*h);s.add(c)}const l=[];return s.forEach(h=>{if(h<=256){const c=e+h;if(this._rangePromises.has(c))l.push(this._rangePromises.get(c));else{const v=n.getRange(e,h).then(()=>{this._rangePromises.delete(c)},()=>{this._rangePromises.delete(c)});this._rangePromises.set(c,v),l.push(v)}}}),Promise.all(l).then(()=>{let h=this._glyphIndex[e];h||(h={},this._glyphIndex[e]=h);for(const c of i){const v=h[c];if(v){t[c]={sdf:!0,rect:v.rect,metrics:v.metrics,page:v.page,code:c};continue}const w=n.getGlyph(e,c);if(!w||!w.metrics)continue;const P=w.metrics;let u;if(0===P.width)u=new S.Z(0,0,0,0);else{const D=P.width+6,E=P.height+6;let M=D%4?4-D%4:4,C=E%4?4-E%4:4;1===M&&(M=5),1===C&&(C=5),u=this._binPack.allocate(D+M,E+C),u.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new p(this.width-4,this.height-4),u=this._binPack.allocate(D+M,E+C));const W=this._glyphData[this._currentPage],F=w.bitmap;let U,k;if(F)for(let A=0;A<E;A++){U=D*A,k=this.width*(u.y+A+1)+u.x;for(let L=0;L<D;L++)W[k+L+1]=F[U+L]}}h[c]={rect:u,metrics:P,tileIDs:null,page:this._currentPage},t[c]={sdf:!0,rect:u,metrics:P,page:this._currentPage,code:c},this._dirties[this._currentPage]=!0}return t})}removeGlyphs(e){for(const i in this._glyphIndex){const t=this._glyphIndex[i];if(!t)continue;let n;for(const s in t)if(n=t[s],n.tileIDs.delete(e),0===n.tileIDs.size){const o=this._glyphData[n.page],l=n.rect;let h,c;for(let v=0;v<l.height;v++)for(h=this.width*(l.y+v)+l.x,c=0;c<l.width;c++)o[h+c]=0;delete t[s],this._dirties[n.page]=!0}}}bind(e,i,t,n=0){this._textures[t]||(this._textures[t]=new ie.x(e,{pixelFormat:_.VI.ALPHA,dataType:_.Br.UNSIGNED_BYTE,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));const s=this._textures[t];s.setSamplingMode(i),this._dirties[t]&&s.setData(this._glyphData[t]),e.bindTexture(s,n),this._dirties[t]=!1}dispose(){this._binPack=null;for(const e of this._textures)e&&e.dispose();this._textures.length=0}}var $=x(84792),q=x(24192);class I{constructor(e){if(this._metrics=[],this._bitmaps=[],e)for(;e.next();)switch(e.tag()){case 1:{const i=e.getMessage();for(;i.next();)switch(i.tag()){case 3:{const t=i.getMessage();let n,s,o,l,h,c,v;for(;t.next();)switch(t.tag()){case 1:n=t.getUInt32();break;case 2:s=t.getBytes();break;case 3:o=t.getUInt32();break;case 4:l=t.getUInt32();break;case 5:h=t.getSInt32();break;case 6:c=t.getSInt32();break;case 7:v=t.getUInt32();break;default:t.skip()}t.release(),n&&(this._metrics[n]={width:o,height:l,left:h,top:c,advance:v},this._bitmaps[n]=s);break}default:i.skip()}i.release();break}default:e.skip()}}getMetrics(e){return this._metrics[e]}getBitmap(e){return this._bitmaps[e]}}class V{constructor(){this._ranges=[]}getRange(e){return this._ranges[e]}addRange(e,i){this._ranges[e]=i}}class G{constructor(e){this._glyphInfo={},this._baseURL=e}getRange(e,i){const t=this._getFontStack(e);if(t.getRange(i))return Promise.resolve();const n=256*i,s=n+255;if(this._baseURL){const o=this._baseURL.replace("{fontstack}",e).replace("{range}",n+"-"+s);return(0,$.default)(o,{responseType:"array-buffer"}).then(l=>{t.addRange(i,new I(new q.Z(new Uint8Array(l.data),new DataView(l.data))))}).catch(()=>{t.addRange(i,new I)})}return t.addRange(i,new I),Promise.resolve()}getGlyph(e,i){const t=this._getFontStack(e);if(!t)return;const n=Math.floor(i/256);if(n>256)return;const s=t.getRange(n);return s?{metrics:s.getMetrics(i),bitmap:s.getBitmap(i)}:void 0}_getFontStack(e){let i=this._glyphInfo[e];return i||(i=this._glyphInfo[e]=new V),i}}var ee=x(26996);class de{constructor(e,i,t=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,(e<=0||i<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=i,t>0&&(this._maxItemSize=t),this._binPack=new p(e-4,i-4)}dispose(){this._binPack=null,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}getPageSize(e){return e>=this._size.length?null:this._size[e]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new p(this._pageWidth-4,this._pageHeight-4);const i=Math.floor(this._pageWidth),t=Math.floor(this._pageHeight),n=new Uint32Array(i*t);this._mosaicsData[0]=n,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e,i=!1){let t,n,s=this._mosaicRects[e];if(s)return s;if(!this._sprites||"loaded"!==this._sprites.loadStatus||(e&&e.startsWith("dasharray-")?([t,n]=this._rasterizeDash(e),i=!0):t=this._sprites.getSpriteInfo(e),!t||!t.width||!t.height||t.width<0||t.height<0))return null;const o=t.width,l=t.height,[h,c,v]=this._allocateImage(o,l);return h.width<=0?null:(this._copy(h,t,c,v,i,n),s={rect:h,width:o,height:l,sdf:t.sdf,simplePattern:!1,pixelRatio:t.pixelRatio,page:c},this._mosaicRects[e]=s,s)}getSpriteItems(e){const i={};for(const t of e)i[t.name]=this.getSpriteItem(t.name,t.repeat);return i}getMosaicItemPosition(e,i){const t=this.getSpriteItem(e,i),n=t&&t.rect;return n?(n.width=t.width,n.height=t.height,{tl:[n.x+2,n.y+2],br:[n.x+2+t.width,n.y+2+t.height],page:t.page}):null}bind(e,i,t=0,n=0){if(t>=this._size.length||t>=this._mosaicsData.length)return;this._textures[t]||(this._textures[t]=new ie.x(e,{pixelFormat:_.VI.RGBA,dataType:_.Br.UNSIGNED_BYTE,wrapMode:_.e8.CLAMP_TO_EDGE,width:this._size[t][0],height:this._size[t][1]},new Uint8Array(this._mosaicsData[t].buffer)));const s=this._textures[t];s.setSamplingMode(i),this._dirties[t]&&s.setData(new Uint8Array(this._mosaicsData[t].buffer)),e.bindTexture(s,n),this._dirties[t]=!1}static _copyBits(e,i,t,n,s,o,l,h,c,v,w){let P=n*i+t,u=h*o+l;if(w){u-=o;for(let R=-1;R<=v;R++,P=((R+v)%v+n)*i+t,u+=o)for(let D=-1;D<=c;D++)s[u+D]=e[P+(D+c)%c]}else for(let R=0;R<v;R++){for(let D=0;D<c;D++)s[u+D]=e[P+D];P+=i,u+=o}}_copy(e,i,t,n,s,o){if(!this._sprites||"loaded"!==this._sprites.loadStatus||t>=this._mosaicsData.length)return;const l=new Uint32Array(o?o.buffer:this._sprites.image.buffer),h=this._mosaicsData[t];h&&l||console.error("Source or target images are uninitialized!"),de._copyBits(l,o?i.width:this._sprites.width,i.x,i.y,h,n[0],e.x+2,e.y+2,i.width,i.height,s),this._dirties[t]=!0}_allocateImage(e,i){e+=2,i+=2;const t=Math.max(e,i);if(this._maxItemSize&&this._maxItemSize<t){const l=new S.Z(0,0,e,i);return this._mosaicsData.push(new Uint32Array(e*i)),this._dirties.push(!0),this._size.push([e,i]),this._textures.push(void 0),[l,this._mosaicsData.length-1,[e,i]]}let n=e%4?4-e%4:4,s=i%4?4-i%4:4;1===n&&(n=5),1===s&&(s=5);const o=this._binPack.allocate(e+n,i+s);return o.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new p(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,i)):[o,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(e){const t=e.match(/\[(.*?)\]/);if(!t)return null;const n=t[1].split(",").map(Number),s=e.slice(e.lastIndexOf("-")+1),[o,l,h]=(0,ee.m)(n,s);return[{x:0,y:0,width:l,height:h,sdf:!0,pixelRatio:1},new Uint8Array(o.buffer)]}}var xe=x(58098);class Ke{constructor(e,i,t){this._layer=e,this._styleRepository=i,this.devicePixelRatio=t,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null}destroy(){this._connection?.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic=null,this._glyphMosaic=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}start(e){var i=this;return(0,j.Z)(function*(){i._spriteSourcePromise=i._layer.loadSpriteSource(i.devicePixelRatio,e),i._spriteSourcePromise.then(s=>{i._spriteMosaic=new de(1024,1024,250),i._spriteMosaic.setSpriteSource(s)});const t=i._layer.currentStyleInfo.glyphsUrl,n=new G(t?(0,f.fl)(t,{...i._layer.customParameters,token:i._layer.apiKey}):null);i._glyphMosaic=new se(1024,1024,n),i._broadcastPromise=(0,y.bA)("WorkerTileHandler",{client:i,schedule:e.schedule,signal:e.signal}).then(s=>{if(i._connection=s,i._layer&&!i._connection.closed){const o=s.broadcast("setStyle",i._layer.currentStyleInfo.style,e);Promise.all(o).catch(l=>(0,ne.H9)(l))}})})()}updateStyle(e){var i=this;return(0,j.Z)(function*(){return yield i._broadcastPromise,i._broadcastPromise=Promise.all(i._connection.broadcast("updateStyle",e)),i._broadcastPromise})()}setSpriteSource(e){const i=new de(1024,1024,250);return i.setSpriteSource(e),this._spriteMosaic=i,this._spriteSourcePromise=Promise.resolve(e),i}setStyle(e,i){var t=this;return(0,j.Z)(function*(){yield t._broadcastPromise,t._styleRepository=e,t._spriteSourcePromise=t._layer.loadSpriteSource(t.devicePixelRatio,null),t._spriteSourcePromise.then(s=>{t._spriteMosaic=new de(1024,1024,250),t._spriteMosaic.setSpriteSource(s)});const n=new G(t._layer.currentStyleInfo.glyphsUrl?(0,f.fl)(t._layer.currentStyleInfo.glyphsUrl,{...t._layer.customParameters,token:t._layer.apiKey}):null);return t._glyphMosaic=new se(1024,1024,n),t._broadcastPromise=Promise.all(t._connection.broadcast("setStyle",i)),t._broadcastPromise})()}fetchTileData(e,i){return this._getRefKeys(e,i).then(t=>{const n=this._layer.sourceNameToSource,s=[];for(const o in n)s.push(o);return this._getSourcesData(s,t,i)})}parseTileData(e,i){const t=e&&e.data;if(!t)return Promise.resolve(null);const{sourceName2DataAndRefKey:n,transferList:s}=t;return 0===Object.keys(n).length?Promise.resolve(null):this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:n,styleLayerUIDs:e.styleLayerUIDs},{...i,transferList:s}))}getSprites(e){var i=this;return(0,j.Z)(function*(){return yield i._spriteSourcePromise,i._spriteMosaic.getSpriteItems(e)})()}getGlyphs(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)}_getTilePayload(e,i,t){var n=this;return(0,j.Z)(function*(){const s=xe.Z.pool.acquire(e.id),o=n._layer.sourceNameToSource[i],{level:l,row:h,col:c}=s;xe.Z.pool.release(s);try{return{protobuff:yield o.requestTile(l,h,c,t),sourceName:i}}catch(v){if((0,ne.D_)(v))throw v;return{protobuff:null,sourceName:i}}})()}_getRefKeys(e,i){const t=this._layer.sourceNameToSource,n=new Array;for(const s in t){const o=t[s].getRefKey(e,i);n.push(o)}return(0,ne.as)(n)}_getSourcesData(e,i,t){const n=[];for(let s=0;s<i.length;s++)if(null==i[s].value||null==e[s])n.push(null);else{const o=this._getTilePayload(i[s].value,e[s],t);n.push(o)}return(0,ne.as)(n).then(s=>{const o={},l=[];for(let h=0;h<s.length;h++){const c=s[h].value;c&&c.protobuff&&c.protobuff.byteLength>0&&(o[c.sourceName]={refKey:i[h].value.id,protobuff:c.protobuff},l.push(c.protobuff))}return{sourceName2DataAndRefKey:o,transferList:l}})}}var je=x(54540),Je=x(51200),Ie=x(47132),Se=x(76763),K=x(1268);function Ze(m,e,i,t,n,s){const{iconRotationAlignment:o,textRotationAlignment:l,iconTranslate:h,iconTranslateAnchor:c,textTranslate:v,textTranslateAnchor:w}=t;let P=0;for(const u of m.colliders){const[R,D]=0===u.partIndex?h:v,E=0===u.partIndex?c:w,M=u.minLod<=s&&s<=u.maxLod;P+=M?0:1,u.enabled=M,u.xScreen=u.xTile*n[0]+u.yTile*n[3]+n[6],u.yScreen=u.xTile*n[1]+u.yTile*n[4]+n[7],E===K.fD.MAP?(u.xScreen+=i*R-e*D,u.yScreen+=e*R+i*D):(u.xScreen+=R,u.yScreen+=D),K.aF.VIEWPORT===(0===u.partIndex?o:l)?(u.dxScreen=u.dxPixels,u.dyScreen=u.dyPixels):(u.dxScreen=i*(u.dxPixels+u.width/2)-e*(u.dyPixels+u.height/2)-u.width/2,u.dyScreen=e*(u.dxPixels+u.width/2)+i*(u.dyPixels+u.height/2)-u.height/2)}m.colliders.length>0&&P===m.colliders.length&&(m.unique.show=!1)}class Xe{constructor(e,i,t,n,s,o){this._symbols=e,this._styleRepository=n,this._zoom=s,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new Se.HX(i,t,Ie.PF),this._si=Math.sin(Math.PI*o/180),this._co=Math.cos(Math.PI*o/180);for(const l of e)for(const h of l.symbols)this._allNeededMatrices.has(h.tile)||this._allNeededMatrices.set(h.tile,(0,d.a)(h.tile.transforms.tileUnitsToPixels))}work(e){const i=this._gridIndex;function t(s){const o=s.xScreen+s.dxScreen,l=s.yScreen+s.dyScreen,h=o+s.width,c=l+s.height,[v,w,P,u]=i.getCellSpan(o,l,h,c);for(let R=w;R<=u;R++)for(let D=v;D<=P;D++){const E=i.cells[R][D];for(const M of E){const C=M.xScreen+M.dxScreen,W=M.yScreen+M.dyScreen;if(!(h<C||o>C+M.width||c<W||l>W+M.height))return!0}}return!1}const n=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const s=this._symbols[this._currentLayerCursor],o=this._getProperties(s.styleLayerUID);for(;this._currentSymbolCursor<s.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-n>e)return!1;const l=s.symbols[this._currentSymbolCursor];if(!l.unique.show)continue;Ze(l,this._si,this._co,o,this._allNeededMatrices.get(l.tile),this._zoom);const h=l.unique;if(!h.show)continue;const{iconAllowOverlap:c,iconIgnorePlacement:v,textAllowOverlap:w,textIgnorePlacement:P}=o;for(const u of l.colliders){if(!u.enabled)continue;const R=h.parts[u.partIndex];R.show&&!(u.partIndex?w:c)&&t(u)&&(u.hard?h.show=!1:R.show=!1)}if(h.show)for(const u of l.colliders){if(!u.enabled||(u.partIndex?P:v)||!h.parts[u.partIndex].show)continue;const R=u.xScreen+u.dxScreen,D=u.yScreen+u.dyScreen,E=R+u.width,M=D+u.height,[C,W,F,U]=this._gridIndex.getCellSpan(R,D,E,M);for(let k=W;k<=U;k++)for(let A=C;A<=F;A++)this._gridIndex.cells[k][A].push(u)}}}return!0}_getProperties(e){const i=this._styleProps.get(e);if(i)return i;const t=this._zoom,n=this._styleRepository.getStyleLayerByUID(e),s=n.getLayoutValue("symbol-placement",t)!==K.R.POINT;let o=n.getLayoutValue("icon-rotation-alignment",t);o===K.aF.AUTO&&(o=s?K.aF.MAP:K.aF.VIEWPORT);let l=n.getLayoutValue("text-rotation-alignment",t);l===K.aF.AUTO&&(l=s?K.aF.MAP:K.aF.VIEWPORT);const h=n.getPaintValue("icon-translate",t),c=n.getPaintValue("icon-translate-anchor",t),v=n.getPaintValue("text-translate",t),w=n.getPaintValue("text-translate-anchor",t),P={iconAllowOverlap:n.getLayoutValue("icon-allow-overlap",t),iconIgnorePlacement:n.getLayoutValue("icon-ignore-placement",t),textAllowOverlap:n.getLayoutValue("text-allow-overlap",t),textIgnorePlacement:n.getLayoutValue("text-ignore-placement",t),iconRotationAlignment:o,textRotationAlignment:l,iconTranslateAnchor:c,iconTranslate:h,textTranslateAnchor:w,textTranslate:v};return this._styleProps.set(e,P),P}}function Ye(m,e){if(m.priority-e.priority)return m.priority-e.priority;const i=m.tile.key,t=e.tile.key;return i.world-t.world?i.world-t.world:i.level-t.level?i.level-t.level:i.row-t.row?i.row-t.row:i.col-t.col?i.col-t.col:m.xTile-e.xTile?m.xTile-e.xTile:m.yTile-e.yTile}class $e{get running(){return this._running}constructor(e,i,t,n,s,o){this._visibleTiles=e,this._symbolRepository=i,this._createCollisionJob=t,this._assignTileSymbolsOpacity=n,this._symbolLayerSorter=s,this._isLayerVisible=o,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}setScreenSize(e,i){this._screenWidth===e&&this._screenHeight===i||this.restart(),this._screenWidth=e,this._screenHeight=i}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(e){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const i=performance.now();if(!this._selectionJob.work(e)||(this._selectionJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-i)))))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const i=performance.now();if(!this._collisionJob.work(e)||(this._collisionJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-i)))))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const i=performance.now();if(!this._opacityJob.work(e)||(this._opacityJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-i)))))return!1}return this._running=!1,!0}_createSelectionJob(){const e=this._symbolRepository.uniqueSymbols;for(let h=0;h<e.length;h++){const c=e[h];for(let v=0;v<c.uniqueSymbols.length;v++){const w=c.uniqueSymbols[v];for(const P of w.tileSymbols)P.selectedForRendering=!1}}const i=[];let t=0,n=0;const s=this._isLayerVisible,l=this._symbolLayerSorter;return{work:function o(h){let c;const v=performance.now();for(;n<e.length;n++,t=0){const w=e[n],P=w.styleLayerUID;if(!s(P)){i[n]||(i[n]={styleLayerUID:P,symbols:[]});continue}i[n]=i[n]||{styleLayerUID:P,symbols:[]};const u=i[n];for(;t<w.uniqueSymbols.length;t++){if(c=w.uniqueSymbols[t],t%100==99&&performance.now()-v>h)return!1;let R=null,D=!1,E=!1;for(const M of c.tileSymbols)if(!E||!D){const C=M.tile;(!R||C.isCoverage||C.neededForCoverage&&!D)&&(R=M,(C.neededForCoverage||C.isCoverage)&&(E=!0),C.isCoverage&&(D=!0))}if(R.selectedForRendering=!0,E){u.symbols.push(R),c.show=!0;for(const M of c.parts)M.show=!0}else c.show=!1}}for(const w of i)w.symbols.sort(Ye);return!0},get sortedSymbols(){return i.sort(l)}}}_createOpacityJob(){const e=this._assignTileSymbolsOpacity,i=this._visibleTiles;let t=0;function n(s,o){const l=s.symbols;for(const[h,c]of l)qe(c,o);e(s,o);for(const h of s.childrenTiles)n(h,o)}return{work(s){const o=performance.now();for(;t<i.length;t++){if(performance.now()-o>s)return!1;const l=i[t];(0,T.pC)(l.parentTile)||n(l,performance.now())}return!0}}}}function qe(m,e){for(const i of m){const t=i.unique;for(const n of t.parts)n.startOpacity+=(e-n.startTime)/Ie.nN*(n.targetOpacity>.5?1:-1),n.startOpacity=Math.min(Math.max(n.startOpacity,0),1),n.startTime=e,n.targetOpacity=t.show&&n.show?1:0}}class it{constructor(e,i,t){this.tileCoordRange=e,this._visibleTiles=i,this._createUnique=t,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return(0,T.Wi)(this._uniqueSymbolLayerArray)&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}add(e,i){this._uniqueSymbolLayerArray=null;let t=this._tiles.get(e.id);t||(t={symbols:new Map},this._tiles.set(e.id,t));const n=new Map;if(i)for(const l of i)t.symbols.has(l)&&(n.set(l,t.symbols.get(l)),t.symbols.delete(l));else for(const[l,h]of e.layerData)t.symbols.has(l)&&(n.set(l,t.symbols.get(l)),t.symbols.delete(l));this._removeSymbols(n);const s=e.symbols,o=new Map;for(const[l,h]of s){let c=h.length;if(c>=32){let v=this.tileCoordRange;do{v/=2,c/=4}while(c>8&&v>64);const w=new Se.HX(this.tileCoordRange,this.tileCoordRange,v);o.set(l,{flat:h,index:w}),t.symbols.set(l,{flat:h,index:w});for(const P of h)w.getCell(P.xTile,P.yTile).push(P)}else o.set(l,{flat:h}),t.symbols.set(l,{flat:h})}this._addSymbols(e.key,s)}deleteStyleLayers(e){this._uniqueSymbolLayerArray=null;for(const[i,t]of this._tiles){const n=new Map;for(const s of e)t.symbols.has(s)&&(n.set(s,t.symbols.get(s)),t.symbols.delete(s));this._removeSymbols(n),0===t.symbols.size&&this._tiles.delete(i)}}removeTile(e){this._uniqueSymbolLayerArray=null;const i=this._tiles.get(e.id);if(!i)return;const t=new Map;for(const[n,s]of e.symbols)i.symbols.has(n)&&(t.set(n,i.symbols.get(n)),i.symbols.delete(n));this._removeSymbols(t),0===i.symbols.size&&this._tiles.delete(e.id)}_removeSymbols(e){for(const[i,{flat:t}]of e)for(const n of t){const s=n.unique,o=s.tileSymbols,l=o.length-1;for(let h=0;h<l;h++)if(o[h]===n){o[h]=o[l];break}if(o.length=l,0===l){const h=this._uniqueSymbolsReferences.get(i);h.delete(s),0===h.size&&this._uniqueSymbolsReferences.delete(i)}n.unique=null}}_addSymbols(e,i){if(0===i.size)return;const t=this._visibleTiles;for(const n of t)n.parentTile||n.key.world!==e.world||n.key.level===e.level&&!n.key.equals(e)||this._matchSymbols(n,e,i);for(const[n,s]of i)for(const o of s)if((0,T.Wi)(o.unique)){const l=this._createUnique();o.unique=l,l.tileSymbols.push(o);let h=this._uniqueSymbolsReferences.get(n);h||(h=new Set,this._uniqueSymbolsReferences.set(n,h)),h.add(l)}}_matchSymbols(e,i,t){if(e.key.level>i.level){const s=e.key.level-i.level;if(e.key.row>>s!==i.row||e.key.col>>s!==i.col)return}if(i.level>e.key.level){const s=i.level-e.key.level;if(i.row>>s!==e.key.row||i.col>>s!==e.key.col)return}if(i.equals(e.key)){for(const s of e.childrenTiles)this._matchSymbols(s,i,t);return}const n=new Map;for(const[s,o]of t){const l=[];for(const w of o){const P=(0,Se.co)(this.tileCoordRange,w.xTile,i.level,i.col,e.key.level,e.key.col),u=(0,Se.co)(this.tileCoordRange,w.yTile,i.level,i.row,e.key.level,e.key.row);P>=0&&P<this.tileCoordRange&&u>=0&&u<this.tileCoordRange&&l.push({symbol:w,xTransformed:P,yTransformed:u})}const h=[],c=e.key.level<i.level?1:1<<e.key.level-i.level,v=this._tiles.get(e.id).symbols.get(s);if(v){const w=v.flat;for(const P of l){let u,R=!1;const D=P.xTransformed,E=P.yTransformed;u=(0,T.pC)(v.index)?v.index.getCell(D,E):w;const M=P.symbol,C=M.hash;for(const W of u)if(C===W.hash&&Math.abs(D-W.xTile)<=c&&Math.abs(E-W.yTile)<=c){const F=W.unique;M.unique=F,F.tileSymbols.push(M),R=!0;break}R||h.push(M)}}h.length>0&&n.set(s,h)}for(const s of e.childrenTiles)this._matchSymbols(s,i,n)}_createUniqueSymbolLayerArray(){const e=this._uniqueSymbolsReferences,i=new Array(e.size);let t,n=0;for(const[s,o]of e){const l=new Array(o.size);t=0;for(const h of o)l[t++]=h;i[n]={styleLayerUID:s,uniqueSymbols:l},n++}return i}}var st=x(2584),rt=x(9598);class ot extends rt.Z{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(e){const i=xe.Z.pool.acquire(e),t=0===i.level?null:xe.Z.getId(i.level-1,i.row>>1,i.col>>1,i.world);return xe.Z.pool.release(i),t}getTileCoverage(e,i,t){const n=super.getTileCoverage(e,i,t);if(!n)return n;const s=1<<n.lodInfo.level;return n.spans=n.spans.filter(o=>o.row>=0&&o.row<s),n}scaleToLevel(e){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[e])return this._levelByScale[e];{const i=this._fullCacheLodInfos;if(e>i[0].scale)return i[0].level;let t,n;for(let s=0;s<i.length-1;s++)if(n=i[s+1],e>n.scale)return t=i[s],t.level+(t.scale-e)/(t.scale-n.scale);return i[i.length-1].level}}_initializeFullCacheLODs(e){let i;i=0===e[0].level?e.map(t=>({level:t.level,resolution:t.resolution,scale:t.scale})):st.Z.create({size:this.tileInfo.size[0],spatialReference:this.tileInfo.spatialReference}).lods.map(s=>({level:s.level,resolution:s.resolution,scale:s.scale}));for(let t=0;t<i.length;t++)this._levelByScale[i[t].scale]=i[t].level;this._fullCacheLodInfos=i}}class De extends Ke{constructor(e,i,t,n,s){super(e,i,t),this._memCache=n,this._loader=s,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map,this._tileInfoView=new ot(e.tileInfo,e.fullExtent)}destroy(){super.destroy(),this._ongoingRequestToController.forEach(e=>e.abort()),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}getVectorTile(e,i,t,n){var s=this;return(0,j.Z)(function*(){const o=new xe.Z(e,i,t,0);let l=s._memCache.get(o.id);if((0,T.pC)(l))return l.retain(),l;const h=yield s._getVectorTileData(o);if((0,ne.k_)(n),!s._layer)return null;if(l=s._memCache.get(o.id),(0,T.pC)(l))return l.retain(),l;const c=s._layer.tileInfo.getTileBounds((0,g.Ue)(),o),v=s._tileInfoView.getTileResolution(e);return l=new je.i(o,v,c[0],c[3],512,512,s._styleRepository,s._memCache),(0,T.pC)(h)?(l.setData(h),l.retain(),s._memCache.put(o.id,l,l.memoryUsage*l.referenced,a.an)):l.setData(null),l.neededForCoverage=!0,l.transforms.tileUnitsToPixels=(0,d.f)(1/8,0,0,0,1/8,0,0,0,1),function nt(m,e){const i=[],t=new it(4096,i,()=>{const s=new Je.J;return s.show=!1,s.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),s.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),s}),n=new $e(i,t,(s,o,l)=>new Xe(s,o,l,m.styleRepository,m.key.level,0),(s,o)=>{(0,Se.C$)(s,o,!1)},()=>0,s=>{const o=e.getStyleLayerByUID(s).getLayoutProperty("visibility");return!o||o.getValue()!==K.EE.NONE});i.push(m),t.add(m),n.setScreenSize(512,512),n.continue(1/0)}(l,s._styleRepository),l})()}_getVectorTileData(e){const i=e.id;if(this._ongoingTileRequests.has(i))return this._ongoingTileRequests.get(i);const t=new AbortController,s=this._getParsedVectorTileData(e,{signal:t.signal}).then(o=>(this._ongoingTileRequests.delete(i),this._ongoingRequestToController.delete(i),o)).catch(()=>(this._ongoingTileRequests.delete(i),this._ongoingRequestToController.delete(i),null));return this._ongoingTileRequests.set(i,s),this._ongoingRequestToController.set(i,t),s}_getParsedVectorTileData(e,i){return this.fetchTileData(e,i).then(t=>this.parseTileData({key:e,data:t},i))}request(e,i){return this._loader.request(e,"binary",i)}}var Re=x(21286),at=x(67709),le=x(39351),_e=x(39406),Te=x(5254);class Me{constructor(){this.name=this.constructor.name||"UnnamedBrush",this.brushEffect=null}prepareState(e,i){}draw(e,i,t){}drawMany(e,i,t){for(const n of i)n.visible&&this.draw(e,n,t)}}var lt=x(83994),ht=x(49353);const Ce=1/65536;var Ee=x(9545),Ue=x(43289);const pt={vtlBackground:class ct extends Me{constructor(){super(...arguments),this._color=(0,at.f)(1,0,0,1),this._patternMatrix=(0,d.c)(),this._programOptions={id:!1,pattern:!1}}dispose(){this._vao&&(this._vao.dispose(),this._vao=null)}drawMany(e,i){const{context:t,painter:n,styleLayerUID:s,requestRender:o,allowDelayedRender:l}=e;this._loadWGLResources(e);const h=e.displayLevel,c=e.styleLayer,v=c.backgroundMaterial,w=n.vectorTilesMaterialManager,P=c.getPaintValue("background-color",h),u=c.getPaintValue("background-opacity",h),R=c.getPaintValue("background-pattern",h),D=void 0!==R,E=P[3]*u,M=1|window.devicePixelRatio,C=e.spriteMosaic;let W,F;const U=M>le.a?2:1,k=e.drawPhase===_e.jx.HITTEST,A=this._programOptions;A.id=k,A.pattern=D;const L=w.getMaterialProgram(t,v,A);if(l&&(0,T.pC)(o)&&!L.compiled)o();else{if(t.bindVAO(this._vao),t.useProgram(L),D){const O=C.getMosaicItemPosition(R,!0);if((0,T.pC)(O)){const{tl:B,br:z,page:Y}=O;W=z[0]-B[0],F=z[1]-B[1];const Z=C.getPageSize(Y);(0,T.pC)(Z)&&(C.bind(t,_.cw.LINEAR,Y,le.V4),L.setUniform4f("u_tlbr",B[0],B[1],z[0],z[1]),L.setUniform2fv("u_mosaicSize",Z),L.setUniform1i("u_texture",le.V4))}L.setUniform1f("u_opacity",u)}else this._color[0]=E*P[0],this._color[1]=E*P[1],this._color[2]=E*P[2],this._color[3]=E,L.setUniform4fv("u_color",this._color);if(L.setUniform1f("u_depth",c.z||0),k){const O=(0,Te.Au)(s+1);L.setUniform4fv("u_id",O)}for(const O of i){if(L.setUniform1f("u_coord_range",O.rangeX),L.setUniformMatrix3fv("u_dvsMat3",O.transforms.dvs),D){const B=Math.max(2**(Math.round(h)-O.key.level),1),z=U*O.width*B,Y=z/(0,Re.fp)(W),Z=z/(0,Re.fp)(F);this._patternMatrix[0]=Y,this._patternMatrix[4]=Z,L.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix)}t.setStencilFunction(_.wb.EQUAL,0,255),t.drawArrays(_.MX.TRIANGLE_STRIP,0,4)}}}_loadWGLResources(e){if(this._vao)return;const{context:i,styleLayer:t}=e,n=t.backgroundMaterial,s=new Int8Array([0,0,1,0,0,1,1,1]),o=lt.f.createVertex(i,_.l1.STATIC_DRAW,s),l=new ht.U(i,n.getAttributeLocations(),n.getLayoutInfo(),{geometry:o});this._vao=l}},vtlFill:class dt extends Me{constructor(){super(...arguments),this._fillProgramOptions={id:!1,pattern:!1},this._outlineProgramOptions={id:!1}}dispose(){}drawMany(e,i){const{displayLevel:t,drawPhase:n,renderPass:s,spriteMosaic:o,styleLayerUID:l}=e;let h=!1;for(const U of i)if(U.layerData.has(l)){const k=U.layerData.get(l);if(k.fillIndexCount>0||k.outlineIndexCount>0){h=!0;break}}if(!h)return;const c=e.styleLayer,v=c.getPaintProperty("fill-pattern"),w=void 0!==v,P=w&&v.isDataDriven;let u;if(w&&!P){const U=v.getValue(t);u=o.getMosaicItemPosition(U,!0)}const R=!w&&c.getPaintValue("fill-antialias",t);let M,D=!0,E=1;if(!w){const U=c.getPaintProperty("fill-color"),k=c.getPaintProperty("fill-opacity");if(!U?.isDataDriven&&!k?.isDataDriven){const A=c.getPaintValue("fill-color",t);E=c.getPaintValue("fill-opacity",t)*A[3],E>=1&&(D=!1)}}if(D&&"opaque"===s)return;n===_e.jx.HITTEST&&(M=(0,Te.Au)(l+1));const C=c.getPaintValue("fill-translate",t),W=c.getPaintValue("fill-translate-anchor",t);(D||"translucent"!==s)&&this._drawFill(e,l,c,i,C,W,w,u,P,M),R&&"opaque"!==s&&!(!c.hasDataDrivenOutlineColor&&c.outlineUsesFillColor&&E<1)&&this._drawOutline(e,l,c,i,C,W,M)}_drawFill(e,i,t,n,s,o,l,h,c,v){if(l&&!c&&(0,T.Wi)(h))return;const{context:w,displayLevel:P,state:u,drawPhase:R,painter:D,pixelRatio:E,spriteMosaic:M,requestRender:C,allowDelayedRender:W}=e,F=t.fillMaterial,U=D.vectorTilesMaterialManager,k=E>le.a?2:1,A=R===_e.jx.HITTEST,L=this._fillProgramOptions;L.id=A,L.pattern=l;const O=U.getMaterialProgram(w,F,L);if(W&&(0,T.pC)(C)&&!O.compiled)return void C();if(w.useProgram(O),(0,T.pC)(h)){const{page:z}=h,Y=M.getPageSize(z);(0,T.pC)(Y)&&(M.bind(w,_.cw.LINEAR,z,le.V4),O.setUniform2fv("u_mosaicSize",Y),O.setUniform1i("u_texture",le.V4))}O.setUniformMatrix3fv("u_displayMat3",o===K.fD.VIEWPORT?u.displayMat3:u.displayViewMat3),O.setUniform2fv("u_fillTranslation",s),O.setUniform1f("u_depth",t.z+Ce),A&&O.setUniform4fv("u_id",v);let B=-1;for(const z of n){if(!z.layerData.has(i))continue;z.key.level!==B&&(B=z.key.level,F.setDataUniforms(O,P,t,B,M));const Y=z.layerData.get(i);if(!Y.fillIndexCount)continue;Y.prepareForRendering(w);const Z=Y.fillVertexArrayObject;if(!(0,T.Wi)(Z)){if(w.bindVAO(Z),O.setUniformMatrix3fv("u_dvsMat3",z.transforms.dvs),w.setStencilFunction(_.wb.EQUAL,z.stencilRef,255),l){const he=Math.max(2**(Math.round(P)-z.key.level),1);O.setUniform1f("u_patternFactor",z.rangeX/(k*z.width*he))}if(c){const he=Y.patternMap;if(!he)continue;for(const[oe,ye]of he){const ve=M.getPageSize(oe);(0,T.pC)(ve)&&(M.bind(w,_.cw.LINEAR,oe,le.V4),O.setUniform2fv("u_mosaicSize",ve),O.setUniform1i("u_texture",le.V4),w.drawElements(_.MX.TRIANGLES,ye[1],_.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*ye[0]))}}else w.drawElements(_.MX.TRIANGLES,Y.fillIndexCount,_.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*Y.fillIndexStart);z.triangleCount+=Y.fillIndexCount/3}}}_drawOutline(e,i,t,n,s,o,l){const{context:h,displayLevel:c,state:v,drawPhase:w,painter:P,pixelRatio:u,spriteMosaic:R,requestRender:D,allowDelayedRender:E}=e,M=t.outlineMaterial,C=P.vectorTilesMaterialManager,W=.75/u,F=w===_e.jx.HITTEST,U=this._outlineProgramOptions;U.id=F;const k=C.getMaterialProgram(h,M,U);if(E&&(0,T.pC)(D)&&!k.compiled)return void D();h.useProgram(k),k.setUniformMatrix3fv("u_displayMat3",o===K.fD.VIEWPORT?v.displayMat3:v.displayViewMat3),k.setUniform2fv("u_fillTranslation",s),k.setUniform1f("u_depth",t.z+Ce),k.setUniform1f("u_outline_width",W),F&&k.setUniform4fv("u_id",l);let A=-1;for(const L of n){if(!L.layerData.has(i))continue;L.key.level!==A&&(A=L.key.level,M.setDataUniforms(k,c,t,A,R));const O=L.layerData.get(i);if(O.prepareForRendering(h),!O.outlineIndexCount)continue;const B=O.outlineVertexArrayObject;(0,T.Wi)(B)||(h.bindVAO(B),k.setUniformMatrix3fv("u_dvsMat3",L.transforms.dvs),h.setStencilFunction(_.wb.EQUAL,L.stencilRef,255),h.drawElements(_.MX.TRIANGLES,O.outlineIndexCount,_.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*O.outlineIndexStart),L.triangleCount+=O.outlineIndexCount/3)}}},vtlLine:class _t extends Me{constructor(){super(...arguments),this._programOptions={id:!1,pattern:!1,sdf:!1}}dispose(){}drawMany(e,i){const{context:t,displayLevel:n,state:s,drawPhase:o,painter:l,pixelRatio:h,spriteMosaic:c,styleLayerUID:v,requestRender:w,allowDelayedRender:P}=e;if(!i.some(Z=>Z.layerData.get(v)?.lineIndexCount??!1))return;const u=e.styleLayer,R=u.lineMaterial,D=l.vectorTilesMaterialManager,E=u.getPaintValue("line-translate",n),M=u.getPaintValue("line-translate-anchor",n),C=u.getPaintProperty("line-pattern"),W=void 0!==C,F=W&&C.isDataDriven;let U,k;if(W&&!F){const Z=C.getValue(n);U=c.getMosaicItemPosition(Z)}let A=!1;if(!W){const Z=u.getPaintProperty("line-dasharray");if(k=void 0!==Z,A=k&&Z.isDataDriven,k&&!A){const he=Z.getValue(n),oe=u.getDashKey(he,u.getLayoutValue("line-cap",n));U=c.getMosaicItemPosition(oe)}}const L=1/h,O=o===_e.jx.HITTEST,B=this._programOptions;B.id=O,B.pattern=W,B.sdf=k;const z=D.getMaterialProgram(t,R,B);if(P&&(0,T.pC)(w)&&!z.compiled)return void w();if(t.useProgram(z),z.setUniformMatrix3fv("u_displayViewMat3",s.displayViewMat3),z.setUniformMatrix3fv("u_displayMat3",M===K.fD.VIEWPORT?s.displayMat3:s.displayViewMat3),z.setUniform2fv("u_lineTranslation",E),z.setUniform1f("u_depth",u.z),z.setUniform1f("u_antialiasing",L),O){const Z=(0,Te.Au)(v+1);z.setUniform4fv("u_id",Z)}if(U&&(0,T.pC)(U)){const{page:Z}=U,he=c.getPageSize(Z);(0,T.pC)(he)&&(c.bind(t,_.cw.LINEAR,Z,le.V4),z.setUniform2fv("u_mosaicSize",he),z.setUniform1i("u_texture",le.V4))}let Y=-1;for(const Z of i){if(!Z.layerData.has(v))continue;Z.key.level!==Y&&(Y=Z.key.level,R.setDataUniforms(z,n,u,Y,c)),z.setUniform1f("u_zoomFactor",2**(n-Y)/h);const oe=Z.layerData.get(v);if(!oe.lineIndexCount)continue;oe.prepareForRendering(t);const ye=oe.lineVertexArrayObject;if(!(0,T.Wi)(ye)){if(t.bindVAO(ye),z.setUniformMatrix3fv("u_dvsMat3",Z.transforms.dvs),t.setStencilFunction(_.wb.EQUAL,Z.stencilRef,255),F||A){const ve=oe.patternMap;if(!ve)continue;for(const[be,re]of ve){const Pe=c.getPageSize(be);(0,T.pC)(Pe)&&(c.bind(t,_.cw.LINEAR,be,le.V4),z.setUniform2fv("u_mosaicSize",Pe),z.setUniform1i("u_texture",le.V4),t.drawElements(_.MX.TRIANGLES,re[1],_.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*re[0]))}}else t.drawElements(_.MX.TRIANGLES,oe.lineIndexCount,_.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*oe.lineIndexStart);Z.triangleCount+=oe.lineIndexCount/3}}}},vtlCircle:class ut extends Me{constructor(){super(...arguments),this._programOptions={id:!1}}dispose(){}drawMany(e,i){const{context:t,displayLevel:n,requiredLevel:s,state:o,drawPhase:l,painter:h,spriteMosaic:c,styleLayerUID:v,requestRender:w,allowDelayedRender:P}=e;if(!i.some(A=>A.layerData.get(v)?.circleIndexCount??!1))return;const u=e.styleLayer,R=u.circleMaterial,D=h.vectorTilesMaterialManager,M=u.getPaintValue("circle-translate",n),C=u.getPaintValue("circle-translate-anchor",n),W=l===_e.jx.HITTEST,F=this._programOptions;F.id=W;const U=D.getMaterialProgram(t,R,F);if(P&&(0,T.pC)(w)&&!U.compiled)return void w();t.useProgram(U),U.setUniformMatrix3fv("u_displayMat3",C===K.fD.VIEWPORT?o.displayMat3:o.displayViewMat3),U.setUniform2fv("u_circleTranslation",M),U.setUniform1f("u_depth",u.z),U.setUniform1f("u_antialiasingWidth",1.2);let k=-1;if(W){const A=(0,Te.Au)(v+1);U.setUniform4fv("u_id",A)}for(const A of i){if(!A.layerData.has(v))continue;A.key.level!==k&&(k=A.key.level,R.setDataUniforms(U,n,u,k,c));const L=A.layerData.get(v);if(!L.circleIndexCount)continue;L.prepareForRendering(t);const O=L.circleVertexArrayObject;(0,T.Wi)(O)||(t.bindVAO(O),U.setUniformMatrix3fv("u_dvsMat3",A.transforms.dvs),s!==A.key.level?t.setStencilFunction(_.wb.EQUAL,A.stencilRef,255):t.setStencilFunction(_.wb.GREATER,255,255),t.drawElements(_.MX.TRIANGLES,L.circleIndexCount,_.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*L.circleIndexStart),A.triangleCount+=L.circleIndexCount/3)}}},vtlSymbol:class mt extends Me{constructor(){super(...arguments),this._iconProgramOptions={id:!1,sdf:!1},this._sdfProgramOptions={id:!1},this._spritesTextureSize=(0,Ee.c)()}dispose(){}drawMany(e,i){const{drawPhase:t,styleLayerUID:n}=e,s=e.styleLayer;let o;t===_e.jx.HITTEST&&(o=(0,Te.Au)(n+1)),this._drawIcons(e,s,i,o),this._drawText(e,s,i,o)}_drawIcons(e,i,t,n){const{context:s,displayLevel:o,drawPhase:l,painter:h,spriteMosaic:c,state:v,styleLayerUID:w,requestRender:P,allowDelayedRender:u}=e,R=i.iconMaterial,D=h.vectorTilesMaterialManager;let E,M=!1;for(const Y of t)if(Y.layerData.has(w)&&(E=Y.layerData.get(w),E.iconPerPageElementsMap.size>0)){M=!0;break}if(!M)return;const C=i.getPaintValue("icon-translate",o),W=i.getPaintValue("icon-translate-anchor",o);let F=i.getLayoutValue("icon-rotation-alignment",o);F===K.aF.AUTO&&(F=i.getLayoutValue("symbol-placement",o)===K.R.POINT?K.aF.VIEWPORT:K.aF.MAP);const U=F===K.aF.MAP,k=i.getLayoutValue("icon-keep-upright",o)&&U,A=E.isIconSDF,L=l===_e.jx.HITTEST,O=this._iconProgramOptions;O.id=L,O.sdf=A;const B=D.getMaterialProgram(s,R,O);if(u&&(0,T.pC)(P)&&!B.compiled)return void P();s.useProgram(B),B.setUniformMatrix3fv("u_displayViewMat3",F===K.aF.MAP?v.displayViewMat3:v.displayMat3),B.setUniformMatrix3fv("u_displayMat3",W===K.fD.VIEWPORT?v.displayMat3:v.displayViewMat3),B.setUniform2fv("u_iconTranslation",C),B.setUniform1f("u_depth",i.z),B.setUniform1f("u_mapRotation",(0,Ue.s5)(v.rotation)),B.setUniform1f("u_keepUpright",k?1:0),B.setUniform1f("u_level",10*o),B.setUniform1i("u_texture",le.V4),B.setUniform1f("u_fadeDuration",Ie.nN/1e3),L&&B.setUniform4fv("u_id",n);let z=-1;for(const Y of t){if(!Y.layerData.has(w)||(Y.key.level!==z&&(z=Y.key.level,R.setDataUniforms(B,o,i,z,c)),E=Y.layerData.get(w),0===E.iconPerPageElementsMap.size))continue;E.prepareForRendering(s),E.updateOpacityInfo();const Z=E.iconVertexArrayObject;if(!(0,T.Wi)(Z)){s.bindVAO(Z),B.setUniformMatrix3fv("u_dvsMat3",Y.transforms.dvs),B.setUniform1f("u_time",(performance.now()-E.lastOpacityUpdate)/1e3);for(const[he,oe]of E.iconPerPageElementsMap)this._renderIconRange(e,B,oe,he,Y)}}}_renderIconRange(e,i,t,n,s){const{context:o,spriteMosaic:l}=e;this._spritesTextureSize[0]=l.getWidth(n)/4,this._spritesTextureSize[1]=l.getHeight(n)/4,i.setUniform2fv("u_mosaicSize",this._spritesTextureSize),l.bind(o,_.cw.LINEAR,n,le.V4),o.setStencilTestEnabled(!0),o.setStencilFunction(_.wb.GREATER,255,255),o.setStencilWriteMask(0),o.drawElements(_.MX.TRIANGLES,t[1],_.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),s.triangleCount+=t[1]/3}_drawText(e,i,t,n){const{context:s,displayLevel:o,drawPhase:l,glyphMosaic:h,painter:c,pixelRatio:v,spriteMosaic:w,state:P,styleLayerUID:u,requestRender:R,allowDelayedRender:D}=e,E=i.textMaterial,M=c.vectorTilesMaterialManager;let C,W=!1;for(const fe of t)if(fe.layerData.has(u)&&(C=fe.layerData.get(u),C.glyphPerPageElementsMap.size>0)){W=!0;break}if(!W)return;const F=i.getPaintProperty("text-opacity");if(F&&!F.isDataDriven&&0===F.getValue(o))return;const U=i.getPaintProperty("text-color"),k=!U||U.isDataDriven||U.getValue(o)[3]>0,A=i.getPaintProperty("text-halo-width"),L=i.getPaintProperty("text-halo-color"),O=(!A||A.isDataDriven||A.getValue(o)>0)&&(!L||L.isDataDriven||L.getValue(o)[3]>0);if(!k&&!O)return;let z=i.getLayoutValue("text-rotation-alignment",o);z===K.aF.AUTO&&(z=i.getLayoutValue("symbol-placement",o)===K.R.POINT?K.aF.VIEWPORT:K.aF.MAP);const Y=z===K.aF.MAP,Z=i.getLayoutValue("text-keep-upright",o)&&Y,he=l===_e.jx.HITTEST,oe=.8*3/v;this._glyphTextureSize||(this._glyphTextureSize=(0,Ee.f)(h.width/4,h.height/4));const ye=i.getPaintValue("text-translate",o),ve=i.getPaintValue("text-translate-anchor",o),be=this._sdfProgramOptions;be.id=he;const re=M.getMaterialProgram(s,E,be);if(D&&(0,T.pC)(R)&&!re.compiled)return void R();s.useProgram(re),re.setUniformMatrix3fv("u_displayViewMat3",z===K.aF.MAP?P.displayViewMat3:P.displayMat3),re.setUniformMatrix3fv("u_displayMat3",ve===K.fD.VIEWPORT?P.displayMat3:P.displayViewMat3),re.setUniform2fv("u_textTranslation",ye),re.setUniform1f("u_depth",i.z+152587890625e-16),re.setUniform2fv("u_mosaicSize",this._glyphTextureSize),re.setUniform1f("u_mapRotation",(0,Ue.s5)(P.rotation)),re.setUniform1f("u_keepUpright",Z?1:0),re.setUniform1f("u_level",10*o),re.setUniform1i("u_texture",le.CU),re.setUniform1f("u_antialiasingWidth",oe),re.setUniform1f("u_fadeDuration",Ie.nN/1e3),he&&re.setUniform4fv("u_id",n);let Pe=-1;for(const fe of t){if(!fe.layerData.has(u)||(fe.key.level!==Pe&&(Pe=fe.key.level,E.setDataUniforms(re,o,i,Pe,w)),C=fe.layerData.get(u),0===C.glyphPerPageElementsMap.size))continue;C.prepareForRendering(s),C.updateOpacityInfo();const Ge=C.textVertexArrayObject;if((0,T.Wi)(Ge))continue;s.bindVAO(Ge),re.setUniformMatrix3fv("u_dvsMat3",fe.transforms.dvs),s.setStencilTestEnabled(!0),s.setStencilFunction(_.wb.GREATER,255,255),s.setStencilWriteMask(0);const At=(performance.now()-C.lastOpacityUpdate)/1e3;re.setUniform1f("u_time",At),C.glyphPerPageElementsMap.forEach((Ot,zt)=>{this._renderGlyphRange(s,Ot,zt,h,re,O,k,fe)})}}_renderGlyphRange(e,i,t,n,s,o,l,h){n.bind(e,_.cw.LINEAR,t,le.CU),o&&(s.setUniform1f("u_halo",1),e.drawElements(_.MX.TRIANGLES,i[1],_.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]),h.triangleCount+=i[1]/3),l&&(s.setUniform1f("u_halo",0),e.drawElements(_.MX.TRIANGLES,i[1],_.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]),h.triangleCount+=i[1]/3)}}};var ce=x(919);const gt={background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","background.vert":"precision mediump float;\nattribute vec2 a_pos;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},circle:{"circle.frag":"precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","circle.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},fill:{"fill.frag":"precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","fill.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},icon:{"icon.frag":"precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_tex = a_tex.xy / u_mosaicSize;\n}"},line:{"line.frag":"precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","line.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}","util.glsl":"float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}"}},xt=new class yt{constructor(e){this._readFile=e}resolveIncludes(e){return this._resolve(e)}_resolve(e,i=new Map){if(i.has(e))return i.get(e);const t=this._read(e);if(!t)throw new Error(`cannot find shader file ${e}`);const n=/^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;let s=n.exec(t);const o=[];for(;null!=s;)o.push({path:s[1],start:s.index,length:s[0].length}),s=n.exec(t);let l=0,h="";return o.forEach(c=>{h+=t.slice(l,c.start),h+=i.has(c.path)?"":this._resolve(c.path,i),l=c.start+c.length}),h+=t.slice(l),i.set(e,h),h}_read(e){return this._readFile(e)}}(function vt(m){let e=gt;return m.split("/").forEach(i=>{e&&(e=e[i])}),e});function ue(m){return xt.resolveIncludes(m)}function wt(m){const{options:e,value:i}=m;return"number"==typeof e[i]}function ge(m){let e="";for(const i in m){const t=m[i];if("boolean"==typeof t)t&&(e+=`#define ${i}\n`);else if("number"==typeof t)e+=`#define ${i} ${t.toFixed()}\n`;else if("object"==typeof t)if(wt(t)){const{value:n,options:s,namespace:o}=t,l=o?`${o}_`:"";for(const h in s)e+=`#define ${l}${h} ${s[h].toFixed()}\n`;e+=`#define ${i} ${l}${n}\n`}else{const n=t.options;let s=0;for(const o in n)e+=`#define ${n[o]} ${(s++).toFixed()}\n`;e+=`#define ${i} ${n[t.value]}\n`}}return e}const Le=m=>ge({ID:m.id,PATTERN:m.pattern}),Pt={shaders:m=>({vertexShader:Le(m)+ue("background/background.vert"),fragmentShader:Le(m)+ue("background/background.frag")})},Ae=m=>ge({ID:m.id}),St={shaders:m=>({vertexShader:Ae(m)+ue("circle/circle.vert"),fragmentShader:Ae(m)+ue("circle/circle.frag")})},Oe=m=>ge({ID:m.id,PATTERN:m.pattern}),Tt={shaders:m=>({vertexShader:Oe(m)+ue("fill/fill.vert"),fragmentShader:Oe(m)+ue("fill/fill.frag")})},ze=m=>ge({ID:m.id}),Mt={shaders:m=>({vertexShader:ze(m)+ue("outline/outline.vert"),fragmentShader:ze(m)+ue("outline/outline.frag")})},Ve=m=>ge({ID:m.id,SDF:m.sdf}),bt={shaders:m=>({vertexShader:Ve(m)+ue("icon/icon.vert"),fragmentShader:Ve(m)+ue("icon/icon.frag")})},Fe=m=>ge({ID:m.id,PATTERN:m.pattern,SDF:m.sdf}),It={shaders:m=>({vertexShader:Fe(m)+ue("line/line.vert"),fragmentShader:Fe(m)+ue("line/line.frag")})},Ne=m=>ge({ID:m.id}),Dt={shaders:m=>({vertexShader:Ne(m)+ue("text/text.vert"),fragmentShader:Ne(m)+ue("text/text.frag")})};class Rt{constructor(){this._programByKey=new Map}dispose(){this._programByKey.forEach(e=>e.dispose()),this._programByKey.clear()}getMaterialProgram(e,i,t){const n=i.key<<3|this._getMaterialOptionsValue(i.type,t);if(this._programByKey.has(n))return this._programByKey.get(n);const s=this._getProgramTemplate(i.type),{shaders:o}=s,{vertexShader:l,fragmentShader:h}=o(t),c=i.getShaderHeader(),v=i.getShaderMain(),w=l.replace("#pragma header",c).replace("#pragma main",v),P=e.programCache.acquire(w,h,i.getAttributeLocations());return this._programByKey.set(n,P),P}_getMaterialOptionsValue(e,i){switch(e){case ce._K.BACKGROUND:case ce._K.FILL:return(i.pattern?1:0)<<1|(i.id?1:0);case ce._K.OUTLINE:return i.id?1:0;case ce._K.LINE:return(i.sdf?1:0)<<2|(i.pattern?1:0)<<1|(i.id?1:0);case ce._K.ICON:return(i.sdf?1:0)<<1|(i.id?1:0);case ce._K.CIRCLE:case ce._K.TEXT:return i.id?1:0;default:return 0}}_getProgramTemplate(e){switch(e){case ce._K.BACKGROUND:return Pt;case ce._K.CIRCLE:return St;case ce._K.FILL:return Tt;case ce._K.ICON:return bt;case ce._K.LINE:return It;case ce._K.OUTLINE:return Mt;case ce._K.TEXT:return Dt;default:return null}}}class We{constructor(e,i){this.spriteMosaic=e,this.glyphMosaic=i,this._brushCache=new Map,this._vtlMaterialManager=new Rt}dispose(){this._brushCache&&(this._brushCache.forEach(e=>e.dispose()),this._brushCache=null),this._vtlMaterialManager=(0,T.M2)(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawTile(e,i,t){const{context:n}=e,s=t.layers;t.backgroundBucketIds.length>0&&(e.renderPass="background",t.backgroundBucketIds.forEach(o=>this._renderStyleLayer(t.getLayerById(o),e,i,!0))),n.setBlendingEnabled(!1),n.setDepthTestEnabled(!0),n.setDepthWriteEnabled(!0),n.setDepthFunction(_.wb.LEQUAL),e.renderPass="opaque";for(let o=s.length-1;o>=0;o--)this._renderStyleLayer(s[o],e,i,!1);n.setDepthWriteEnabled(!1),n.setBlendingEnabled(!0),n.setBlendFunctionSeparate(_.zi.ONE,_.zi.ONE_MINUS_SRC_ALPHA,_.zi.ONE,_.zi.ONE_MINUS_SRC_ALPHA),e.renderPass="translucent";for(let o=0;o<s.length;o++)this._renderStyleLayer(s[o],e,i,!1);n.setDepthTestEnabled(!1),n.bindVAO()}_renderStyleLayer(e,i,t,n=!1){if(!(n||e&&t.layerData.has(e.uid)))return;const s=e.getLayoutProperty("visibility");if(s&&s.getValue()===K.EE.NONE)return;const{renderPass:o}=i;let l;switch(e.type){case K.fR.BACKGROUND:if("background"!==o)return;l="vtlBackground";break;case K.fR.FILL:if("opaque"!==o&&"translucent"!==i.renderPass)return;l="vtlFill";break;case K.fR.LINE:if("translucent"!==o)return;l="vtlLine";break;case K.fR.CIRCLE:if("translucent"!==o)return;l="vtlCircle";break;case K.fR.SYMBOL:if("translucent"!==o)return;l="vtlSymbol"}const h=i.displayLevel;void 0!==e.minzoom&&e.minzoom>h+1e-6||void 0!==e.maxzoom&&e.maxzoom<=h-1e-6||(i.styleLayerUID=e.uid,i.styleLayer=e,this._drawWithBrush(i,t,l))}_drawWithBrush(e,i,t){this._brushCache.has(t)||this._brushCache.set(t,new(0,pt[t])),this._brushCache.get(t).drawMany(e,[i])}}var Be=x(78364),Ct=x(19702),Et=x(50916),He=x(61779),Ut=x(45611);let we=class extends((0,Et.r)((0,Ct.A)(Ut.Z))){constructor(){super(...arguments),this._tileHandlerController=null,this.type="vector-tile-3d"}initialize(){if((0,T.Wi)(this.layer.fullExtent))return void this.addResolvingPromise(Promise.reject(new N.Z("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const{basemapTerrain:m,spatialReference:e,state:i,viewingMode:t}=this.view,o="local"===t&&!(0,He.jO)(e)||He.Bu.force512VTL?this.layer.tileInfo:this.layer.tileInfo.getOrCreateCompatible(256,this.layer.tileInfo.spatialReference.isGeographic?1:2),l=this._getTileInfoSupportError(o,this.layer.fullExtent);if((0,T.pC)(l))return this.addResolvingPromise(Promise.reject(l));const h=(0,H.N1)(()=>this.view?.basemapTerrain?.tilingSchemeLocked).then(()=>{const M=m.tilingScheme,C=M.pixelSize;let W;this.schemaHelper=new r(C,(0,T.pC)(m.spatialReference)&&m.spatialReference.isGeographic),W=256===C?this.layer.tileInfo.getOrCreateCompatible(256,this.layer.tileInfo.spatialReference.isGeographic?1:2):this.view.spatialReference?.isGeographic?this.layer.tileInfo.getOrCreateCompatible(512,.5):this.layer.tileInfo;const F=this._getTileInfoCompatibilityError(W,M);if(F)throw F;this.tileInfo=W});this._tileHandlerController=new AbortController;const c=this.view.resourceController;this._memCache=c.memoryController.newCache(this.layer.uid,M=>{M.release()});const v=new Be.Z(this.layer.currentStyleInfo.style),w=m.mapTileRequester;this._tileHandler=new De(this.layer,v,i.contentPixelRatio,this._memCache,w);const P=this._tileHandlerController.signal,u=M=>c.immediate.schedule(M),R=this._tileHandler.start({signal:P,schedule:u}),D=this._tileHandler.spriteMosaic;D.then(M=>{!(0,ne.Hc)(P)&&this._tileHandler&&(this.painter=new We(M,this._tileHandler.glyphMosaic))}),R.then(()=>this._tileHandlerController=null),this.updatingHandles.add(()=>({style:this.layer.currentStyleInfo.style,pixelRatio:this.view.state?.contentPixelRatio}),({style:M,pixelRatio:C})=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const W=new Be.Z(M),F=new De(this.layer,W,C,this._memCache,w),U=F.start({signal:this._tileHandlerController.signal,schedule:u}),k=F.spriteMosaic;U.then(()=>this._tileHandlerController=null),this.updatingHandles.addPromise(Promise.all([U,k]).then(([,A])=>{const L=this._tileHandler,O=this.painter;this.painter=new We(A,F.glyphMosaic),this._tileHandler=F,this.emit("data-changed"),L.destroy(),O&&O.dispose()}))});const E=Promise.all([h,R,D]);this.addResolvingPromise(E)}destroy(){this.painter=(0,T.M2)(this.painter),this._tileHandlerController=(0,T.IM)(this._tileHandlerController),(0,T.SC)(this._tileHandler),this._memCache=(0,T.SC)(this._memCache),this._tileHandler=null}get dataLevelRange(){const m=this.tileInfo.lods,t=this.levelRangeFromScaleRange(m[0].scale,m[m.length-1].scale);return 1===t.minLevel&&256===this.tileInfo.size[0]&&(t.minLevel=0),t}fetchTile(m,e,i,t){var n=this;return(0,j.Z)(function*(){return n._tileHandler.getVectorTile(m,e,i,t)})()}};(0,X._)([(0,J.Cb)()],we.prototype,"layer",void 0),(0,X._)([(0,J.Cb)()],we.prototype,"dataLevelRange",null),(0,X._)([(0,J.Cb)()],we.prototype,"updatingProgressValue",void 0),we=(0,X._)([(0,b.j)("esri.views.3d.layers.VectorTileLayerView3D")],we);const Lt=we},45611:(pe,ae,x)=>{x.d(ae,{Z:()=>g});var j=x(17626),X=x(14517),N=x(61885),T=x(80542),ne=x(61996),H=x(63290),J=x(62208),te=x(60330),Q=x(77712),a=(x(90912),x(85931),x(76898));let d=class extends((0,T.p)((0,ne.IG)((0,te.v)(N.Z.EventedMixin(X.Z))))){constructor(f){super(f),this.layer=null,this.parent=null}initialize(){this.when().catch(f=>{if("layerview:create-error"!==f.name){const y=this.layer&&this.layer.id||"no id",S=this.layer&&this.layer.title||"no title";H.Z.getLogger(this.declaredClass).error("#resolve()",`Failed to resolve layer view (layer title: '${S}', id: '${y}')`,f)}})}get fullOpacity(){return(0,J.Pt)(this.get("layer.opacity"),1)*(0,J.Pt)(this.get("parent.fullOpacity"),1)}get suspended(){return!this.canResume()}get suspendInfo(){return this.getSuspendInfo()}get legendEnabled(){return!this.suspended&&!0===this.layer?.legendEnabled}get updating(){return!(!this.updatingHandles?.updating&&!this.isUpdating())}get updatingProgress(){return this.updating?0:1}get visible(){return!0===this.layer?.visible}set visible(f){this._overrideIfSome("visible",f)}canResume(){return this.visible&&this.layer?.loaded&&!this.parent?.suspended&&this.view?.ready||!1}getSuspendInfo(){const f=this.parent&&this.parent.suspended?this.parent.suspendInfo:{};return this.view&&this.view.ready||(f.viewNotReady=!0),this.layer&&this.layer.loaded||(f.layerNotLoaded=!0),this.visible||(f.layerInvisible=!0),f}isUpdating(){return!1}};(0,j._)([(0,Q.Cb)()],d.prototype,"fullOpacity",null),(0,j._)([(0,Q.Cb)()],d.prototype,"layer",void 0),(0,j._)([(0,Q.Cb)()],d.prototype,"parent",void 0),(0,j._)([(0,Q.Cb)({readOnly:!0})],d.prototype,"suspended",null),(0,j._)([(0,Q.Cb)({readOnly:!0})],d.prototype,"suspendInfo",null),(0,j._)([(0,Q.Cb)({readOnly:!0})],d.prototype,"legendEnabled",null),(0,j._)([(0,Q.Cb)({type:Boolean,readOnly:!0})],d.prototype,"updating",null),(0,j._)([(0,Q.Cb)({readOnly:!0})],d.prototype,"updatingProgress",null),(0,j._)([(0,Q.Cb)()],d.prototype,"visible",null),(0,j._)([(0,Q.Cb)()],d.prototype,"view",void 0),d=(0,j._)([(0,a.j)("esri.views.layers.LayerView")],d);const g=d}}]);