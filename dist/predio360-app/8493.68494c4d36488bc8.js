"use strict";(self.webpackChunkpredio360_app=self.webpackChunkpredio360_app||[]).push([[8493],{44056:(R,Z,v)=>{v.r(Z),v.d(Z,{default:()=>D});var b=v(85931),h=v(55713),A=v(32056),B=v(42722),C=v(79800),P=v(48310),x=v(65234),L=v(39774),I=v(14471),M=v(93394);class T{transform(d){const n=this._transform(d),r=[n.points.buffer,n.rgb.buffer];null!=n.pointIdFilterMap&&r.push(n.pointIdFilterMap.buffer);for(const i of n.attributes)"buffer"in i.values&&(0,h.eP)(i.values.buffer)&&i.values.buffer!==n.rgb.buffer&&r.push(i.values.buffer);return Promise.resolve({result:n,transferList:r})}_transform(d){const n=(0,I.Ym)(d.schema,d.geometryBuffer);let r=n.length/3,i=null;const p=new Array,w=(0,I.dH)(d.primaryAttributeData,n,r);null!=d.primaryAttributeData&&w&&p.push({attributeInfo:d.primaryAttributeData.attributeInfo,values:w});const o=(0,I.dH)(d.modulationAttributeData,n,r);null!=d.modulationAttributeData&&o&&p.push({attributeInfo:d.modulationAttributeData.attributeInfo,values:o});let l=(0,I.aE)(d.rendererInfo,w,o,r);if(d.filterInfo&&d.filterInfo.length>0&&null!=d.filterAttributesData){const c=d.filterAttributesData.filter(b.pC).map(y=>{const e=(0,I.dH)(y,n,r),t={attributeInfo:y.attributeInfo,values:e};return p.push(t),t});i=new Uint32Array(r),r=(0,I.hv)(n,l,i,d.filterInfo,c)}for(const c of d.userAttributesData){const y=(0,I.dH)(c,n,r);p.push({attributeInfo:c.attributeInfo,values:y})}3*r<l.length&&(l=new Uint8Array(l.buffer.slice(0,3*r))),this._applyElevationOffsetInPlace(n,r,d.elevationOffset);const g=this._transformCoordinates(n,r,M.Oo.fromData(d.obbData),x.Z.fromJSON(d.inSR),x.Z.fromJSON(d.outSR));return{obbData:d.obbData,points:g,rgb:l,attributes:p,pointIdFilterMap:i}}_transformCoordinates(d,n,r,i,p){if(!(0,L.projectBuffer)(d,i,0,d,p,0,n))throw new Error("Can't reproject");const w=(0,P.d9)(r.center),o=(0,P.Ue)(),l=(0,P.Ue)(),g=(0,P.d9)(r.halfSize);(0,A.Kx)(z,r.quaternion);const c=new Float32Array(3*n);for(let y=0;y<n;y++){let e=3*y;o[0]=d[e]-w[0],o[1]=d[e+1]-w[1],o[2]=d[e+2]-w[2],(0,C.u)(l,o,z),g[0]=Math.max(g[0],Math.abs(l[0])),g[1]=Math.max(g[1],Math.abs(l[1])),g[2]=Math.max(g[2],Math.abs(l[2])),c[e++]=o[0],c[e++]=o[1],c[e]=o[2]}return r.halfSize=g,c}_applyElevationOffsetInPlace(d,n,r){if(0!==r)for(let i=0;i<n;i++)d[3*i+2]+=r}}const z=(0,B.Ue)();function D(){return new T}},92852:(R,Z,v)=>{v.d(Z,{Es:()=>r,I_:()=>T,W7:()=>n,qM:()=>o});var b=v(26584),h=v(58817),A=v(63290),B=v(61566),C=v(16396);const P=()=>A.Z.getLogger("esri.views.3d.layers.i3s.I3SBinaryReader");function x(e,t,f){let s="",a=0;for(;a<f;){const u=e[t+a];if(u<128)s+=String.fromCharCode(u),a++;else if(u>=192&&u<224){if(a+1>=f)throw new b.Z("utf8-decode-error","UTF-8 Decode failed. Two byte character was truncated.");s+=String.fromCharCode((31&u)<<6|63&e[t+a+1]),a+=2}else if(u>=224&&u<240){if(a+2>=f)throw new b.Z("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");s+=String.fromCharCode((15&u)<<12|(63&e[t+a+1])<<6|63&e[t+a+2]),a+=3}else{if(!(u>=240&&u<248))throw new b.Z("utf8-decode-error","UTF-8 Decode failed. Invalid multi byte sequence.");{if(a+3>=f)throw new b.Z("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");const _=(7&u)<<18|(63&e[t+a+1])<<12|(63&e[t+a+2])<<6|63&e[t+a+3];s+=_>=65536?String.fromCharCode(55296+(_-65536>>10),56320+(1023&_)):String.fromCharCode(_),a+=4}}}return s}function L(e,t){const f={byteOffset:0,byteCount:0,fields:Object.create(null)};let s=0;for(let a=0;a<t.length;a++){const u=t[a],_=u.valueType||u.type;f.fields[u.property]=(0,g[_])(e,s),s+=l[_].BYTES_PER_ELEMENT}return f.byteCount=s,f}function M(e,t,f){const s=[];let a,u,_=0;for(u=0;u<e;u+=1){if(a=t[u],a>0){if(s.push(x(f,_,a-1)),0!==f[_+a-1])throw new b.Z("string-array-error","Invalid string array: missing null termination.")}else s.push(null);_+=a}return s}function T(e,t){return new l[t.valueType](e,t.byteOffset,t.count*t.valuesPerElement)}function F(e,t,f){if(t!==e&&P().error(`Invalid ${f} buffer size\n expected: ${e}, actual: ${t})`),t<e)throw new b.Z("buffer-too-small","Binary buffer is too small",{expectedSize:e,actualSize:t})}function n(e,t){const f=L(e,t&&t.header);let s=f.byteCount;const a={isDraco:!1,header:f,byteOffset:f.byteCount,byteCount:0,vertexAttributes:{}},u=f.fields,_=null!=u.vertexCount?u.vertexCount:u.count;for(const U of t.ordering){if(!t.vertexAttributes[U])continue;const O={...t.vertexAttributes[U],byteOffset:s,count:_};a.vertexAttributes[w[U]||"_"+U]=O,s+=y(O.valueType)*O.valuesPerElement*_}const E=u.faceCount;if(t.faces&&E){a.faces={};for(const U of t.ordering){if(!t.faces[U])continue;const O={...t.faces[U],byteOffset:s,count:E};a.faces[U]=O,s+=y(O.valueType)*O.valuesPerElement*E}}const m=u.featureCount;if(t.featureAttributes&&t.featureAttributeOrder&&m){a.featureAttributes={};for(const U of t.featureAttributeOrder){if(!t.featureAttributes[U])continue;const O={...t.featureAttributes[U],byteOffset:s,count:m};a.featureAttributes[U]=O,s+=("UInt64"===O.valueType?8:y(O.valueType))*O.valuesPerElement*m}}return F(s,e.byteLength,"geometry"),a.byteCount=s-a.byteOffset,a}function r(e,t){return e&&e.compressedAttributes&&"draco"===e.compressedAttributes.encoding?function p(e){const t={isDraco:!0,isLegacy:!1,color:!1,normal:!1,uv0:!1,uvRegion:!1,featureIndex:!1};for(const f of e)switch(f){case"position":break;case"normal":t.normal=!0;break;case"uv0":t.uv0=!0;break;case"color":t.color=!0;break;case"uv-region":t.uvRegion=!0;break;case"feature-index":t.featureIndex=!0}return t}(e.compressedAttributes.attributes):e?function d(e){return{isDraco:!1,isLegacy:!1,color:null!=e.color,normal:null!=e.normal,uv0:null!=e.uv0,uvRegion:null!=e.uvRegion,featureIndex:null!=e.faceRange&&null!=e.featureId}}(e):function i(e){const t={isDraco:!1,isLegacy:!0,color:!1,normal:!1,uv0:!1,uvRegion:!1,featureIndex:!1};for(const f of e.ordering)if(e.vertexAttributes[f])switch(f){case"position":break;case"normal":t.normal=!0;break;case"color":t.color=!0;break;case"uv0":t.uv0=!0;break;case"region":t.uvRegion=!0}return e.featureAttributes&&e.featureAttributeOrder&&(t.featureIndex=!0),t}(t)}const w={position:C.T.POSITION,normal:C.T.NORMAL,color:C.T.COLOR,uv0:C.T.UV0,region:C.T.UVREGION};function o(e,t,f){if("lepcc-rgb"===e.encoding)return(0,B.IT)(t);if("lepcc-intensity"===e.encoding)return(0,B.ti)(t);if(null!=e.encoding&&""!==e.encoding)throw new b.Z("unknown-attribute-storage-info-encoding","Unknown Attribute Storage Info Encoding");e["attributeByteCounts "]&&!e.attributeByteCounts&&(P().warn("Warning: Trailing space in 'attributeByteCounts '."),e.attributeByteCounts=e["attributeByteCounts "]),"ObjectIds"===e.ordering[0]&&e.hasOwnProperty("objectIds")&&(P().warn("Warning: Case error in objectIds"),e.ordering[0]="objectIds");const s=function D(e,t,f){const s=null!=t.header?L(e,t.header):{byteOffset:0,byteCount:0,fields:{count:f}},a={header:s,byteOffset:s.byteCount,byteCount:0,entries:Object.create(null)};let u=s.byteCount;for(let _=0;_<t.ordering.length;_++){const E=t.ordering[_],m=(0,h.d9)(t[E]);if(m.count=s.fields.count??0,"String"===m.valueType){if(m.byteOffset=u,m.byteCount=s.fields[E+"ByteCount"],"UTF-8"!==m.encoding)throw new b.Z("unsupported-encoding","Unsupported String encoding.",{encoding:m.encoding});if(m.timeEncoding&&"ECMA_ISO8601"!==m.timeEncoding)throw new b.Z("unsupported-time-encoding","Unsupported time encoding.",{timeEncoding:m.timeEncoding})}else{if(!c(m.valueType))throw new b.Z("unsupported-value-type","Unsupported binary valueType",{valueType:m.valueType});{const U=y(m.valueType);u+=u%U!=0?U-u%U:0,m.byteOffset=u,m.byteCount=U*m.valuesPerElement*m.count}}u+=m.byteCount??0,a.entries[E]=m}return a.byteCount=u-a.byteOffset,a}(t,e,f);F(s.byteOffset+s.byteCount,t.byteLength,"attribute");const a=s.entries.attributeValues||s.entries.objectIds;if(a){if("String"===a.valueType){const u=s.entries.attributeByteCounts,_=T(t,u),E=function z(e,t){return new Uint8Array(e,t.byteOffset,t.byteCount)}(t,a);return a.timeEncoding?function I(e,t,f){return M(e,t,f).map(s=>{const a=s?Date.parse(s):null;return a&&!Number.isNaN(a)?a:null})}(u.count,_,E):M(u.count,_,E)}return T(t,a)}throw new b.Z("bad-attribute-storage-info","Bad attributeStorageInfo specification.")}const l={Float32:Float32Array,Float64:Float64Array,UInt8:Uint8Array,Int8:Int8Array,UInt16:Uint16Array,Int16:Int16Array,UInt32:Uint32Array,Int32:Int32Array},g={Float32:(e,t)=>new DataView(e,0).getFloat32(t,!0),Float64:(e,t)=>new DataView(e,0).getFloat64(t,!0),UInt8:(e,t)=>new DataView(e,0).getUint8(t),Int8:(e,t)=>new DataView(e,0).getInt8(t),UInt16:(e,t)=>new DataView(e,0).getUint16(t,!0),Int16:(e,t)=>new DataView(e,0).getInt16(t,!0),UInt32:(e,t)=>new DataView(e,0).getUint32(t,!0),Int32:(e,t)=>new DataView(e,0).getInt32(t,!0)};function c(e){return l.hasOwnProperty(e)}function y(e){return c(e)?l[e].BYTES_PER_ELEMENT:0}},61566:(R,Z,v)=>{v.d(Z,{Gi:()=>x,IT:()=>z,ti:()=>d});var b=v(26584);const h=!0,A={identifierOffset:0,identifierLength:10,versionOffset:10,checksumOffset:12,byteCount:16};function B(n,r,i){return{identifier:String.fromCharCode.apply(null,new Uint8Array(n,i+A.identifierOffset,A.identifierLength)),version:r.getUint16(i+A.versionOffset,h),checksum:r.getUint32(i+A.checksumOffset,h)}}const C={sizeLo:0,sizeHi:4,minX:8,minY:16,minZ:24,maxX:32,maxY:40,maxZ:48,errorX:56,errorY:64,errorZ:72,count:80,reserved:84,byteCount:88};function x(n){const r=new DataView(n,0);let i=0;const{identifier:p,version:w}=B(n,r,i);if(i+=A.byteCount,"LEPCC     "!==p)throw new b.Z("lepcc-decode-error","Bad identifier");if(w>1)throw new b.Z("lepcc-decode-error","Unknown version");const o=function P(n,r){return{sizeLo:n.getUint32(r+C.sizeLo,h),sizeHi:n.getUint32(r+C.sizeHi,h),minX:n.getFloat64(r+C.minX,h),minY:n.getFloat64(r+C.minY,h),minZ:n.getFloat64(r+C.minZ,h),maxX:n.getFloat64(r+C.maxX,h),maxY:n.getFloat64(r+C.maxY,h),maxZ:n.getFloat64(r+C.maxZ,h),errorX:n.getFloat64(r+C.errorX,h),errorY:n.getFloat64(r+C.errorY,h),errorZ:n.getFloat64(r+C.errorZ,h),count:n.getUint32(r+C.count,h),reserved:n.getUint32(r+C.reserved,h)}}(r,i);if(i+=C.byteCount,o.sizeHi*2**32+o.sizeLo!==n.byteLength)throw new b.Z("lepcc-decode-error","Bad size");const l=new Float64Array(3*o.count),g=[],c=[],y=[],e=[];if(i=L(n,i,g),i=L(n,i,c),i=L(n,i,y),i=L(n,i,e),i!==n.byteLength)throw new b.Z("lepcc-decode-error","Bad length");let t=0,f=0;for(let s=0;s<g.length;s++){f+=g[s];let a=0;for(let u=0;u<c[s];u++){a+=y[t];const _=e[t];l[3*t]=Math.min(o.maxX,o.minX+2*o.errorX*a),l[3*t+1]=Math.min(o.maxY,o.minY+2*o.errorY*f),l[3*t+2]=Math.min(o.maxZ,o.minZ+2*o.errorZ*_),t++}}return{errorX:o.errorX,errorY:o.errorY,errorZ:o.errorZ,result:l}}function L(n,r,i){const p=[];r=I(n,r,p);const w=[];for(let o=0;o<p.length;o++){w.length=0,r=I(n,r,w);for(let l=0;l<w.length;l++)i.push(w[l]+p[o])}return r}function I(n,r,i){const p=new DataView(n,r),w=p.getUint8(0),o=31&w,l=!!(32&w),g=(192&w)>>6;let c=0;if(0===g)c=p.getUint32(1,h),r+=5;else if(1===g)c=p.getUint16(1,h),r+=3;else{if(2!==g)throw new b.Z("lepcc-decode-error","Bad count type");c=p.getUint8(1),r+=2}if(l)throw new b.Z("lepcc-decode-error","LUT not implemented");const y=Math.ceil(c*o/8),e=new Uint8Array(n,r,y);let t=0,f=0,s=0;const a=-1>>>32-o;for(let u=0;u<c;u++){for(;f<o;)t|=e[s]<<f,f+=8,s+=1;i[u]=t&a,t>>>=o,f-=o,f+o>32&&(t|=e[s-1]>>8-f)}return r+s}const M={sizeLo:0,sizeHi:4,count:8,colorMapCount:12,lookupMethod:14,compressionMethod:15,byteCount:16};function z(n){const r=new DataView(n,0);let i=0;const{identifier:p,version:w}=B(n,r,i);if(i+=A.byteCount,"ClusterRGB"!==p)throw new b.Z("lepcc-decode-error","Bad identifier");if(w>1)throw new b.Z("lepcc-decode-error","Unknown version");const o=function T(n,r){return{sizeLo:n.getUint32(r+M.sizeLo,h),sizeHi:n.getUint32(r+M.sizeHi,h),count:n.getUint32(r+M.count,h),colorMapCount:n.getUint16(r+M.colorMapCount,h),lookupMethod:n.getUint8(r+M.lookupMethod),compressionMethod:n.getUint8(r+M.compressionMethod)}}(r,i);if(i+=M.byteCount,o.sizeHi*2**32+o.sizeLo!==n.byteLength)throw new b.Z("lepcc-decode-error","Bad size");if((2===o.lookupMethod||1===o.lookupMethod)&&0===o.compressionMethod){if(3*o.colorMapCount+o.count+i!==n.byteLength||o.colorMapCount>256)throw new b.Z("lepcc-decode-error","Bad count");const l=new Uint8Array(n,i,3*o.colorMapCount),g=new Uint8Array(n,i+3*o.colorMapCount,o.count),c=new Uint8Array(3*o.count);for(let y=0;y<o.count;y++){const e=g[y];c[3*y]=l[3*e],c[3*y+1]=l[3*e+1],c[3*y+2]=l[3*e+2]}return c}if(0===o.lookupMethod&&0===o.compressionMethod){if(3*o.count+i!==n.byteLength||0!==o.colorMapCount)throw new b.Z("lepcc-decode-error","Bad count");return new Uint8Array(n,i).slice()}if(o.lookupMethod<=2&&1===o.compressionMethod){if(i+3!==n.byteLength||1!==o.colorMapCount)throw new b.Z("lepcc-decode-error","Bad count");const l=r.getUint8(i),g=r.getUint8(i+1),c=r.getUint8(i+2),y=new Uint8Array(3*o.count);for(let e=0;e<o.count;e++)y[3*e]=l,y[3*e+1]=g,y[3*e+2]=c;return y}throw new b.Z("lepcc-decode-error","Bad method "+o.lookupMethod+","+o.compressionMethod)}const D={sizeLo:0,sizeHi:4,count:8,scaleFactor:12,bitsPerPoint:14,reserved:15,byteCount:16};function d(n){const r=new DataView(n,0);let i=0;const{identifier:p,version:w}=B(n,r,i);if(i+=A.byteCount,"Intensity "!==p)throw new b.Z("lepcc-decode-error","Bad identifier");if(w>1)throw new b.Z("lepcc-decode-error","Unknown version");const o=function F(n,r){return{sizeLo:n.getUint32(r+D.sizeLo,h),sizeHi:n.getUint32(r+D.sizeHi,h),count:n.getUint32(r+D.count,h),scaleFactor:n.getUint16(r+D.scaleFactor,h),bitsPerPoint:n.getUint8(r+D.bitsPerPoint),reserved:n.getUint8(r+D.reserved)}}(r,i);if(i+=D.byteCount,o.sizeHi*2**32+o.sizeLo!==n.byteLength)throw new b.Z("lepcc-decode-error","Bad size");const l=new Uint16Array(o.count);if(8===o.bitsPerPoint){if(o.count+i!==n.byteLength)throw new b.Z("lepcc-decode-error","Bad size");const g=new Uint8Array(n,i,o.count);for(let c=0;c<o.count;c++)l[c]=g[c]*o.scaleFactor}else if(16===o.bitsPerPoint){if(2*o.count+i!==n.byteLength)throw new b.Z("lepcc-decode-error","Bad size");const g=new Uint16Array(n,i,o.count);for(let c=0;c<o.count;c++)l[c]=g[c]*o.scaleFactor}else{const g=[];if(I(n,i,g)!==n.byteLength)throw new b.Z("lepcc-decode-error","Bad size");for(let c=0;c<o.count;c++)l[c]=g[c]*o.scaleFactor}return l}}}]);