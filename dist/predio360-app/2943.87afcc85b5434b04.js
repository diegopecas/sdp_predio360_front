"use strict";(self.webpackChunkpredio360_app=self.webpackChunkpredio360_app||[]).push([[2943],{8549:(Je,ge,L)=>{L.d(ge,{C:()=>B,b:()=>ee});var P=L(10109),ne=L(33726),_=L(2166),D=L(95285),be=L(69960),Re=L(17625),q=L(22355),Ge=L(44835),ue=L(16396);function ee(T){const I=new q.kG;I.extensions.add("GL_OES_standard_derivatives");const{vertex:oe,fragment:W}=I;return(0,_.Sv)(oe,T),I.attributes.add(ue.T.POSITION,"vec3"),I.attributes.add(ue.T.UV0,"vec2"),I.varyings.add("vUV","vec2"),T.hasMultipassTerrain&&I.varyings.add("depth","float"),oe.code.add(Re.H`
    void main(void) {
      vUV = uv0;
      ${T.hasMultipassTerrain?"depth = (view * vec4(position, 1.0)).z;":""}
      gl_Position = proj * view * vec4(position, 1.0);
    }
  `),I.include(P.l,T),W.uniforms.add(new D.A("size",Z=>Z.size)),W.uniforms.add(new be.N("color1",Z=>Z.color1)),W.uniforms.add(new be.N("color2",Z=>Z.color2)),W.include(ne.Y),W.code.add(Re.H`
    void main() {
      ${T.hasMultipassTerrain?"terrainDepthTest(gl_FragCoord, depth);":""}
      vec2 uvScaled = vUV / (2.0 * size);

      vec2 uv = fract(uvScaled - 0.25);
      vec2 ab = clamp((abs(uv - 0.5) - 0.25) / fwidth(uvScaled), -0.5, 0.5);
      float fade = smoothstep(0.25, 0.5, max(fwidth(uvScaled.x), fwidth(uvScaled.y)));
      float t = mix(abs(ab.x + ab.y), 0.5, fade);

      gl_FragColor = mix(color2, color1, t);
      ${T.transparencyPassType===Ge.A.Color?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
    }
  `),I}const B=Object.freeze(Object.defineProperty({__proto__:null,build:ee},Symbol.toStringTag,{value:"Module"}))},32943:(Je,ge,L)=>{L.r(ge),L.d(ge,{default:()=>kt});var P=L(17626),ne=L(14517),_=L(62208),D=L(77712),q=(L(90912),L(85931),L(76898)),Ge=L(39691),ue=L(1437),ee=L(74554),B=L(32917),T=L(55915),I=L(81863),oe=L(21286),W=L(15572),Z=L(67831),pe=L(99770),b=L(84161),R=L(28093),ae=L(4794),ke=L(92383),ze=L(65234),qe=L(78172),xe=L(11519),et=L(11544),tt=L(44766),st=L(37118),me=L(10049),ve=L(98943);function ht(h,n,d){const v=new me._q;return(0,me.cA)(v,[h[0],h[1]],[n[0],n[1]],d),v.distance}function lt(h,n,d,v){const y=ct;return(0,T.ke)(h,v,X)&&(0,T.ke)(n,v,$)&&(0,T.ke)(d,v,we)?(y.setPoint(0,0,X),y.setPoint(0,1,$),y.setPoint(0,2,we),Math.abs((0,tt.geodesicArea)(y,"square-meters"))):0}const X=(0,R.c)(),$=(0,R.c)(),we=(0,R.c)(),ct=new st.Z({rings:[[X,$,we]],spatialReference:ze.Z.WGS84}),F=(0,R.c)();var Te=L(495),gt=L(53929),Ie=L(37187),he=L(16730),ut=L(11915);function Ee(h){return(0,ut.e)(function vt(h){const n=new Float64Array(2*h.length);for(let d=0;d<h.length;++d){const v=h[d],y=2*d;n[y+0]=v[0],n[y+1]=v[1]}return n}(h),[],2)}L(90014),L(66601),(0,R.c)(),(0,R.c)();class ft{constructor(n,d){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.areaCentroidWorldCoords=(0,R.c)(),this.areaCentroidRenderCoords=(0,R.c)(),this.geodesicAreaCentroidRenderCoords=(0,R.c)(),this.area=null,this.geodesicArea=null,this.pathLength=null,this.geodesicPathLength=null,this.perimeterLength=null,this._length=0,this._centroidRenderCoords=(0,R.c)(),this._planeWorldCoords=(0,ae.c)(),this._worldUp=(0,R.c)(),this._worldTangent=(0,R.c)(),this._frame=[(0,R.c)(),(0,R.c)(),(0,R.c)()],this._pathVersion=-1,this._validMeasurement=!1,this._hasCursorPoint=!1,this._mode=null,this._tempU=(0,R.c)(),this._tempV=(0,R.c)(),this._tempVec3=(0,R.c)(),this._tempSphere={center:(0,R.c)(),radius:0},this._sceneView=n,this.unitNormalizer=d}update(n,d,v,y,C,S,M){const A=this.unitNormalizer,V=this._sceneView.renderSpatialReference,G=this.unitNormalizer.spatialReference,w=(0,_.pC)(d);if(this._pathVersion===n.version&&this._validMeasurement===y&&!M&&this._hasCursorPoint===w&&this._mode===S)return!n.isValidPolygon&&(this._updateCursorSegmentLength(n,d),!0);this._pathVersion=n.version,this._validMeasurement=y,this._hasCursorPoint=w,this._resize(n.numVertices);const z=(0,I.rS)(v.spatialReference),j=(0,T.Up)(v.spatialReference,z)&&(0,T.jF)(v.spatialReference),{positionsGeographic:E,positionsWorldCoords:Ae,positionsRenderCoords:Y,positionsSpherical:re}=this;n.forEachVertexPosition((x,N)=>{(function yt(h,n){n.hasZ||(n.z=(0,_.Pt)((0,gt.KO)(h,n,"ground"),0))})(v.elevationProvider,x),(0,T.KC)(x,Ae[N],G),(0,T.KC)(x,Y[N],V),j&&((0,T.UY)(x,E[N]),(0,T.KC)(x,re[N],z),(0,b.n)(re[N],re[N]))});const Ve=this._updatePathLengths(y);if(this.pathLength=this._length>1?(0,W.yG)(A.normalizeDistance(Ve),"meters"):null,j){const x=this._updateGeodesicPathLengths(y,G);this.geodesicPathLength=this._length>1?(0,W.yG)(x,"meters"):null}else this.geodesicPathLength=null;return this._updateCursorSegmentLength(n,d),this._updateMode(n,S),y?(this._updateArea(v,A,V,G,C),j&&this._updateGeodesicArea(v),!0):(this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),!0)}getData(){return{positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,cursorSegmentLength:this.cursorSegmentLength,geodesicCursorSegmentLength:this.geodesicCursorSegmentLength,unitNormalizer:this.unitNormalizer,actualMeasurementMode:this.actualMeasurementMode}}_resize(n){for(n<this._length&&(this.positionsWorldCoords.length=n,this.positionsRenderCoords.length=n,this.positionsProjectedWorldCoords.length=n,this.positionsFittedRenderCoords.length=n,this.positionsGeographic.length=n,this.positionsSpherical.length=n,this.positionsStereographic.length=n,this.pathSegmentLengths.length=n,this.geodesicPathSegmentLengths.length=n,this.perimeterSegmentLengths.length=n,this._length=n);this._length<n;)this.positionsWorldCoords.push((0,R.c)()),this.positionsRenderCoords.push((0,R.c)()),this.positionsProjectedWorldCoords.push((0,pe.a)()),this.positionsFittedRenderCoords.push((0,R.c)()),this.positionsGeographic.push((0,R.c)()),this.positionsSpherical.push((0,R.c)()),this.positionsStereographic.push((0,pe.a)()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(n){const d=this.positionsWorldCoords,v=this.pathSegmentLengths;let y=0;for(let C=0;C<this._length;++C){const S=v[C]=(0,b.i)(d[C],d[(C+1)%this._length]);(C<this._length-1||n)&&(y+=S)}return y}_updateGeodesicPathLengths(n,d){const v=this.positionsGeographic,y=this.geodesicPathSegmentLengths;let C=0;for(let S=0;S<this._length;++S){const M=y[S]=ht(v[S],v[(S+1)%this._length],d??void 0);(S<this._length-1||n)&&(C+=M)}return C}_updateArea(n,d,v,y,C){const S=n.renderCoordsHelper,M=this.positionsWorldCoords,A=this.positionsRenderCoords,V=this.positionsProjectedWorldCoords,G=this.positionsFittedRenderCoords,w=this._planeWorldCoords,O=this._centroidRenderCoords;(0,Te.H)(A,O),S.worldUpAtPosition(O,this._worldUp),S.worldBasisAtPosition(O,qe.R.X,this._worldTangent),(0,T.Qr)(O,this._worldUp,v,this._worldUp,y),(0,T.Qr)(O,this._worldTangent,v,this._worldTangent,y),M.length>2&&function rt(h,n){if(h.length<3)throw new Error("need at least 3 points to fit a plane");(0,ve.pG)(h[0],h[1],h[2],n)}(M,w),this.fittingMode=this._selectFittingMode(w,M,this._worldUp,C);let z=0;if("horizontal"===this.fittingMode){let x=-1/0;A.forEach((N,De)=>{const Qe=S.getAltitude(A[De]);Qe>x&&(x=Qe,z=De)})}const j=M[z];let E=w,Ae=this._worldTangent;"horizontal"===this.fittingMode?E=this._worldUp:"vertical"===this.fittingMode&&(E=this._tempVec3,Ae=this._worldUp,(0,ve.T)(w,this._worldUp,E)),(0,b.c)(this._frame[2],E),(0,ve.T)(Ae,E,this._frame[0]),(0,b.f)(this._frame[1],this._frame[0],this._frame[2]),(0,b.o)(this._frame[1],this._frame[1]);const Y=this._tempVec3,re=this._tempU,Ve=this._tempV;for(let x=0;x<this._length;++x){const N=V[x],De=G[x];(0,b.b)(Y,M[x],j),(0,Z.s)(N,(0,b.e)(this._frame[0],Y),(0,b.e)(this._frame[1],Y)),(0,b.g)(re,this._frame[0],N[0]),(0,b.g)(Ve,this._frame[1],N[1]),(0,b.a)(Y,re,Ve),(0,b.a)(Y,Y,j),(0,T.SH)(Y,y,De,v)}this.perimeterLength=this._length>0?(0,W.yG)(d.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,(0,Te.H)(G,this.areaCentroidRenderCoords),(0,T.SH)(this.areaCentroidRenderCoords,v,this.areaCentroidWorldCoords,y),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?(0,W.ne)(d.normalizeArea(this._computeArea()),"square-meters"):null}_updateGeodesicArea(n){const{renderCoordsHelper:d,spatialReference:v}=n,{positionsSpherical:y,positionsStereographic:C}=this,S=this._tempVec3,M=function dt(h,n=null,d=!0){const y=(C,S)=>{if(0===S[0]&&0===S[1]&&0===S[2])return!1;for(let M=0;M<C.length;++M)if((0,b.e)(S,C[M])<-1e-6)return!1;return!0};if(0===h.length)return!1;if(1===h.length)return n&&(0,b.c)(n,h[0]),!0;(0,b.s)(F,0,0,0);for(let C=0;C<h.length;++C)(0,b.a)(F,F,h[C]);if((0,b.n)(F,F),y(h,F))return n&&(0,b.c)(n,F),!0;if(!d)return!1;for(let C=0;C<h.length;++C)for(let S=0;S<h.length;++S)if(C!==S&&((0,b.f)(F,h[C],h[S]),(0,b.n)(F,F),y(h,F)))return n&&(0,b.c)(n,F),!0;return!1}(y,S);if(!M)return void(this.geodesicArea=null);const A=this._tempU,V=this._tempV;(0,ve._F)(S,A,V);for(let G=0;G<this._length;++G){const w=(0,b.e)(y[G],A),O=(0,b.e)(y[G],V),z=(0,b.e)(y[G],S);(0,Z.s)(C[G],w/z,O/z)}(0,b.g)(S,S,(0,ke.Iu)(v).radius),d.toRenderCoords(S,(0,I.rS)(v),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=M&&0===this.geodesicIntersectingSegments.size?(0,W.ne)(this._computeGeodesicArea(),"square-meters"):null}_updatePerimeterLengths(){const n=this.positionsProjectedWorldCoords,d=this.perimeterSegmentLengths;let v=0;for(let y=0;y<this._length;++y)v+=d[y]=(0,Z.d)(n[y],n[(y+1)%this._length]);return v}_updateIntersectingSegments(){const n=this.positionsProjectedWorldCoords,d=this.intersectingSegments;d.clear();for(let v=0;v<this._length;++v)for(let y=v+2;y<this._length;++y)(y+1)%this._length!==v&&(0,xe.UT)(n[v],n[(v+1)%this._length],n[y],n[(y+1)%this._length])&&(d.add(v),d.add(y))}_computeArea(){const n=this.positionsProjectedWorldCoords,d=this.triangleIndices=(0,Ie.mi)(Ee(n));let v=0;for(let y=0;y<d.length;y+=3)v+=(0,et.wu)(n[d[y]],n[d[y+1]],n[d[y+2]]);return v}_updateGeodesicIntersectingSegments(){const n=this.positionsStereographic,d=this.geodesicIntersectingSegments;d.clear();for(let v=0;v<this._length;++v)for(let y=v+2;y<this._length;++y)(y+1)%this._length!==v&&(0,xe.UT)(n[v],n[(v+1)%this._length],n[y],n[(y+1)%this._length])&&(d.add(v),d.add(y))}_computeGeodesicArea(){const n=this.positionsGeographic,v=this.geodesicTriangleIndices=(0,Ie.mi)(Ee(this.positionsStereographic));let y=0;for(let C=0;C<v.length;C+=3)y+=lt(n[v[C]],n[v[C+1]],n[v[C+2]],ze.Z.WGS84);return y}_selectFittingMode(n,d,v,y){const C=d.map(G=>Math.abs(function nt(h,n){return(0,b.e)(h,n)+h[3]}(n,G))).reduce((G,w)=>Math.max(G,w),0);!function it(h,n){const d=n.center;(0,b.s)(d,0,0,0);for(let y=0;y<h.length;++y)(0,b.a)(d,d,h[y]);(0,b.g)(d,d,1/h.length);let v=0;for(let y=0;y<h.length;++y)v=Math.max(v,(0,b.d)(d,h[y]));n.radius=Math.sqrt(v)}(d,this._tempSphere);const S=C/(2*this._tempSphere.radius);let V="horizontal";return S<y.maxRelativeErrorCoplanar?V="oblique":S<y.maxRelativeErrorAlmostCoplanar&&(V=Math.abs((0,b.e)(v,n))>Math.cos((0,oe.Vl)(y.verticalAngleThreshold))?"horizontal":"vertical"),V}_updateCursorSegmentLength(n,d){const v=n.lastPoint;!n.isValidPolygon&&(0,_.pC)(v)&&(0,_.pC)(d)?(this.geodesicCursorSegmentLength=(0,W.yG)(function at(h,n){if(!(0,T.UY)(h,X)||!(0,T.UY)(n,$))return 0;const d=new me._q;return(0,me.cA)(d,[X[0],X[1]],[$[0],$[1]]),d.distance}(v,d),"meters"),this.cursorSegmentLength=(0,W.yG)(this.unitNormalizer.normalizeDistance(function ot(h,n,d){return(0,T.KC)(h,X,d)&&(0,T.KC)(n,$,d)?(0,b.i)(X,$):0}(v,d,this.unitNormalizer.spatialReference)),"meters")):(this.geodesicCursorSegmentLength=null,this.cursorSegmentLength=null)}_updateMode(n,d){if(d===ee.e.Auto){this.actualMeasurementMode="euclidean";let v=0;null!=this.geodesicPathLength&&(v+=this.geodesicPathLength.value),!n.isValidPolygon&&(0,_.pC)(this.geodesicCursorSegmentLength)&&(v+=this.geodesicCursorSegmentLength.value),v>Lt&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=d===ee.e.Euclidean?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean"),this._mode=d}}const Lt=1e5;var Ct=L(68);let te=class extends ne.Z{constructor(h){super(h)}initialize(){const h=this.view.spatialReference,n=(0,I.rS)(h),d=n===I.GG?I.wY:n,v=!h||(0,T.Up)(h,d)?d:h,y=new Ct.D(v);this._measurementDataManager=new ft(this.view,y),this.addHandles([this.analysisViewData.path.on("change",()=>this._update()),(0,B.YP)(()=>this.analysisViewData.cursorPoint,()=>this._update(),B.Z_),(0,B.YP)(()=>this.analysisViewData.mode,()=>this._update(),B.Z_)]),this._update()}_update(h=!1){const{analysisViewData:n,view:d}=this;this._measurementDataManager.update(n.path,n.cursorPoint,d,n.validMeasurement,{maxRelativeErrorCoplanar:.005,maxRelativeErrorAlmostCoplanar:.01,verticalAngleThreshold:80},n.mode,h)&&(n.measurementData=this._measurementDataManager.getData())}};(0,P._)([(0,D.Cb)({constructOnly:!0})],te.prototype,"view",void 0),(0,P._)([(0,D.Cb)({constructOnly:!0})],te.prototype,"analysis",void 0),(0,P._)([(0,D.Cb)({constructOnly:!0})],te.prototype,"analysisViewData",void 0),te=(0,P._)([(0,q.j)("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementController")],te);var St=L(61885),Be=L(72392),_t=L(63290),Pt=L(72642),Oe=L(65401),Mt=L(54865),At=L(50017),Fe=L(466),He=L(97737);const Ne="esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurement3DPathHelper",Vt=_t.Z.getLogger(Ne);let K=class extends St.Z.EventedAccessor{constructor(h={}){super(h),this._handles=new Be.Z,this._version=0,this._internalGeometryChange=!1,this._extent=(0,Oe.cS)()}destroy(){this._handles=(0,_.SC)(this._handles)}set areaMeasurement(h){this._set("areaMeasurement",h),(0,_.pC)(h)&&(0,_.pC)(this.view)&&this._initialize(h,this.view)}set view(h){this._set("view",h),(0,_.pC)(h)&&(0,_.pC)(this.areaMeasurement)&&this._initialize(this.areaMeasurement,h)}get constructed(){return(0,_.pC)(this.areaMeasurement)&&(0,_.pC)(this.view)}get version(){return this._version}get isValidPolygon(){return this.constructed&&this._editGeometry.components.length>0&&this._editGeometry.components[0].isClosed()}get extent(){if(this.constructed&&this._editGeometry.components.length>0&&this._editGeometry.components[0].vertices.length>0){const h=(0,Oe.cS)(this._extent);return this.forEachVertex(n=>{(0,Oe.Ho)(h,n.pos)}),h}return null}get spatialReference(){return this.constructed?this._editGeometry.coordinateHelper.spatialReference:null}_initialize(h,n){this._handles.removeAll(),this._handles.add((0,B.YP)(()=>h.geometry,()=>{this._updateEditGeometryFromModelGeometry(h,n)},B.tX)),this._makeDirty(!0)}_makeDirty(h=!1){this.notifyChange("isValidPolygon"),this.notifyChange("initialized"),this.notifyChange("extent"),h&&this.notifyChange("numVertices")}_updateEditGeometryFromModelGeometry(h,n){if(this._version++,this._internalGeometryChange)return;this._handles.remove("EditGeometry");let d=h.geometry;if((0,_.pC)(d)){const v=(0,T.fM)(d,n.spatialReference);(0,_.Wi)(v)&&(0,Mt.e)(h,d.spatialReference,Vt),d=v}this._editGeometryOperations=(0,_.pC)(d)?He.c.fromGeometry(d,n.state.viewingMode):new He.c(new Fe.XE("polygon",(0,At.Y6)(!0,!1,n.spatialReference))),this._makeDirty(!0),this.emit("change"),this._handles.add(this._editGeometry.on("change",v=>{this._makeDirty(null!=v.addedVertices||null!=v.removedVertices),this._internalGeometryChange=!0,h.geometry=this.numVertices>0?this._editGeometry.geometry:null,this._internalGeometryChange=!1}),"EditGeometry")}get _editGeometry(){return this._editGeometryOperations.data}get vertices(){const h=[];return this.forEachVertex(n=>{h.push(n)}),h}get numVertices(){return this.constructed&&this._editGeometry.components.length>0?this._editGeometry.components[0].vertices.length:0}get lastPoint(){if(this.constructed&&this._editGeometry.components.length>0){const h=this._editGeometry.components[0].getLastVertex();if((0,_.pC)(h))return this._editGeometry.coordinateHelper.vectorToPoint(h.pos)}return null}getVertex(h){if(!this.constructed||0===this._editGeometry.components.length||0===this._editGeometry.components[0].vertices.length)return null;const n=this._editGeometry.components[0].vertices[0];let d=n;do{if(d.index===h)return d;d=d.rightEdge.rightVertex}while(d!==n&&null!=d);return null}getVertexPositionAsPoint(h){return this._editGeometry.coordinateHelper.vectorToPoint(h.pos)}getVertexPositionAsPointFromIndex(h){return this._editGeometry.coordinateHelper.vectorToPoint(this.getVertex(h).pos)}forEachVertex(h){this.constructed&&this._editGeometry.components.length>0&&this._editGeometry.components[0].iterateVertices(h)}forEachVertexPosition(h){const n=this._editGeometry.coordinateHelper;this.forEachVertex((d,v)=>{n.vectorToPoint(d.pos,Ze),h(Ze,v)})}clear(){(0,_.pC)(this.areaMeasurement)&&(this.areaMeasurement.geometry=null)}add(h){if(!this.constructed)return null;if(0===this._editGeometry.components.length){const d=(0,_.Wg)(this.view);this._editGeometry.components.push(new Fe.wA(d.spatialReference,d.state.viewingMode))}const n=this._editGeometryOperations.appendVertex(this._editGeometry.coordinateHelper.pointToVector(h));return this.emit("change"),n}close(){if(!this.constructed||0===this._editGeometry.components.length)return null;const h=this._editGeometryOperations.closeComponent(this._editGeometry.components[0]);return this.emit("change"),h}ensureContains(h,n=""){let d=!1;if(this._editGeometry.components.forEach(v=>{v.iterateVertices(y=>{y===h&&(d=!0)})}),!d)throw new Error(`vertex doesnt exist ${n}`);return d}setVertexPosition(h,n){if(!this.constructed)return null;const d=this._editGeometryOperations.setVertexPosition(h,this._editGeometry.coordinateHelper.pointToVector(n));return this.emit("change"),d}equals(h){if(this.numVertices!==h.numVertices)return!1;let n=!0;return this.forEachVertexPosition((d,v)=>{const y=h.getVertexPositionAsPointFromIndex(v);d.equals(y)||(n=!1)}),!!n}};(0,P._)([(0,D.Cb)({value:null})],K.prototype,"areaMeasurement",null),(0,P._)([(0,D.Cb)({value:null})],K.prototype,"view",null),(0,P._)([(0,D.Cb)()],K.prototype,"isValidPolygon",null),(0,P._)([(0,D.Cb)()],K.prototype,"extent",null),(0,P._)([(0,D.Cb)()],K.prototype,"spatialReference",null),(0,P._)([(0,D.Cb)()],K.prototype,"numVertices",null),K=(0,P._)([(0,q.j)(Ne)],K);const Ze=new Pt.Z;var le=L(91558),J=(L(52515),L(51819)),Ke=(L(8314),L(84600)),Ye=L(28347),Dt=L(43703),fe=L(68063),de=L(87469),ye=L(993),bt=L(53928),Xe=L(94255),Rt=L(41120),Q=L(40723),Le=L(16396),$e=L(13934),Gt=L(60881),Ce=L(5894),wt=L(2770),Tt=L(66131),Et=L(15842),Ot=L(651),Ut=L(91056),zt=L(39114),Ue=L(88569),xt=L(12407),Se=L(44835),It=L(8549),_e=L(67969),Pe=L(2078);class Me extends Ut.A{initializeProgram(n){return new xt.$(n.rctx,Me.shader.get().build(this.configuration),zt.i)}_setPipelineState(n){const d=this.configuration,v=n===Se.A.NONE,y=n===Se.A.FrontFace;return(0,Pe.sm)({blending:d.transparent?v?jt:(0,Ue.j7)(n):null,depthTest:{func:(0,Ue.Bh)(n)},depthWrite:v?d.writeDepth?Pe.LZ:null:(0,Ue.K5)(n),colorWrite:Pe.BK,polygonOffset:v||y?d.polygonOffset?Wt:null:{factor:-1,units:-25}})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}}Me.shader=new Ot.J(It.C,()=>L.e(2558).then(L.bind(L,2558)));const Wt={factor:0,units:-25},jt=(0,Pe.wK)(_e.zi.SRC_ALPHA,_e.zi.ONE,_e.zi.ONE_MINUS_SRC_ALPHA,_e.zi.ONE_MINUS_SRC_ALPHA);var se=L(87601),Bt=L(41528);class k extends Bt.W{constructor(){super(...arguments),this.transparencyPassType=Se.A.NONE,this.transparent=!1,this.writeDepth=!0,this.polygonOffset=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1}}(0,P._)([(0,se.o)({count:Se.A.COUNT})],k.prototype,"transparencyPassType",void 0),(0,P._)([(0,se.o)()],k.prototype,"transparent",void 0),(0,P._)([(0,se.o)()],k.prototype,"writeDepth",void 0),(0,P._)([(0,se.o)()],k.prototype,"polygonOffset",void 0),(0,P._)([(0,se.o)()],k.prototype,"hasMultipassTerrain",void 0),(0,P._)([(0,se.o)()],k.prototype,"cullAboveGround",void 0);class Ft extends Et.c{constructor(n){super(n,new Nt),this._configuration=new k}dispose(){}getConfiguration(n,d){return this._configuration.transparent=this.parameters.transparent,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.polygonOffset=this.parameters.polygonOffset,this._configuration.transparencyPassType=d.transparencyPassType,this._configuration.hasMultipassTerrain=d.multipassTerrain.enabled,this._configuration.cullAboveGround=d.multipassTerrain.cullAboveGround,this._configuration}requiresSlot(n,d){return!(d!==$e.H.Color&&d!==$e.H.Alpha||n!==(this.parameters.transparent?this.parameters.writeDepth?Ce.r.TRANSPARENT_MATERIAL:Ce.r.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL:Ce.r.OPAQUE_MATERIAL)&&n!==Ce.r.DRAPED_MATERIAL)}createGLMaterial(n){return new Ht(n)}createBufferWriter(){return new wt.G(Tt.W1)}}class Ht extends Gt.Z{beginSlot(n){return this.ensureTechnique(Me,n)}}class Nt extends Q.Mt{constructor(){super(...arguments),this.size=(0,pe.f)(1,1),this.color1=(0,ae.f)(.75,.75,.75,1),this.color2=(0,ae.f)(.5,.5,.5,1),this.transparent=!1,this.writeDepth=!0,this.polygonOffset=!1}}class Zt extends bt._{constructor(n){super(n),this._checkerBoardMaterial=null,this._renderOccluded=Q.yD.OccludeAndTransparent,this._geometry=null,this._size=(0,pe.f)(1,1),this._color1=(0,ae.f)(1,.5,0,.5),this._color2=(0,ae.f)(1,1,1,.5),this.applyProps(n)}get renderOccluded(){return this._renderOccluded}set renderOccluded(n){n!==this._renderOccluded&&(this._renderOccluded=n,this._updateMaterial())}get geometry(){return this._geometry}set geometry(n){this._geometry=n,this._geometryChanged()}get size(){return this._size}set size(n){(0,Z.c)(this._size,n),this._updateMaterial()}get color1(){return this._color1}set color1(n){(0,ye.g)(n,this._color1)||((0,ye.c)(this._color1,n),this._updateMaterial())}get color2(){return this._color2}set color2(n){(0,ye.g)(n,this._color2)||((0,ye.c)(this._color2,n),this._updateMaterial())}_updateMaterial(){(0,_.pC)(this._checkerBoardMaterial)&&this._checkerBoardMaterial.setParameters({size:this._size,color1:this._color1,color2:this._color2,renderOccluded:this._renderOccluded})}createExternalResources(){this._checkerBoardMaterial=new Ft({size:this._size,color1:this._color1,color2:this._color2,transparent:!0,writeDepth:!1,polygonOffset:!0,renderOccluded:Q.yD.OccludeAndTransparent})}destroyExternalResources(){this._checkerBoardMaterial=null}forEachExternalMaterial(n){(0,_.pC)(this._checkerBoardMaterial)&&n(this._checkerBoardMaterial)}createGeometries(n){if((0,_.Wi)(this._geometry)||(0,_.Wi)(this._checkerBoardMaterial))return;const d=Kt;(0,Ye.D)(d,this.transform);const v=this._geometry,y=[],C=(0,R.c)();v.position.forEach(A=>{(0,b.b)(C,A,d),y.push(C[0],C[1],C[2])});const S=[];v.uv.forEach(A=>{S.push(A[0],A[1])});const M=new Rt.Z(this._checkerBoardMaterial,[[Le.T.POSITION,new Xe.a(y,3,!0)],[Le.T.UV0,new Xe.a(S,2,!0)]],[[Le.T.POSITION,v.triangleIndices],[Le.T.UV0,v.triangleIndices]]);n.addGeometry(M)}_geometryChanged(){this.recreateGeometry()}}const Kt=(0,R.c)();var ce=L(64770),Yt=L(54889),Xt=L(56683),$t=L(41840);let H=class extends ne.Z{get visible(){return this.analysisViewData.visible}get testData(){return{labels:{area:this._areaLabel,pathLength:this._pathLengthLabel,cursorSegmentLength:this._cursorSegmentLengthLabel,perimeterLength:this._perimeterLengthLabel}}}constructor(h){super(h),this._handles=new Be.Z,this._params={pathLineColor:le.Z.toUnitRGBA((0,J.e9)()),pathLineWidth:3,intersectingLineColor:[1,.2,0,1],perimeterLineColor:le.Z.toUnitRGBA((0,J.e9)()),perimeterLineWidth:2,projectionLineColor:le.Z.toUnitRGBA((0,J.e9)()),projectionLineWidth:2,projectionLineStippleSize:5,areaColor1:le.Z.toUnitRGBA((0,J.e9)(.5)),areaColor2:le.Z.toUnitRGBA((0,J.RN)(.5)),labelDistance:25},this._path=null,this._intersectedPath=null,this._perimeter=null,this._intersectedPerimeter=null,this._projectionLines=null,this._measurementArea=null,this._areaLabel=null,this._pathLengthLabel=null,this._cursorSegmentLengthLabel=null,this._perimeterLengthLabel=null,this._pathSegments=[],this._perimeterSegments=[],this._cursorSegment=null,this._origin=(0,R.c)(),this._originTransform=(0,Dt.c)(),this._cursorPositionRenderSpace=(0,R.c)(),this.messages=null,this.viewData=Qt,this.areaLabel=null,this.perimeterLengthLabel=null,this.loadingMessages=!0}initialize(){const{analysisViewData:h,_params:n,view:d}=this;this._path=new de.r({view:d,attached:!0,width:n.pathLineWidth,color:n.pathLineColor,polygonOffset:!0,renderOccluded:Q.yD.OccludeAndTransparent}),this._intersectedPath=new de.r({view:d,attached:!0,width:n.pathLineWidth,color:n.intersectingLineColor,polygonOffset:!0,renderOccluded:Q.yD.OccludeAndTransparent}),this._perimeter=new de.r({view:d,attached:!0,width:n.perimeterLineWidth,color:n.perimeterLineColor,polygonOffset:!0,renderOccluded:Q.yD.OccludeAndTransparent}),this._intersectedPerimeter=new de.r({view:d,attached:!0,width:n.perimeterLineWidth,color:n.intersectingLineColor,polygonOffset:!0,renderOccluded:Q.yD.OccludeAndTransparent}),this._projectionLines=new de.r({view:d,attached:!0,width:n.projectionLineWidth,color:n.projectionLineColor,stipplePattern:(0,Yt.z5)(n.projectionLineStippleSize),polygonOffset:!0,renderOccluded:Q.yD.OccludeAndTransparent}),this._measurementArea=new Zt({view:d,attached:!0,color1:n.areaColor1,color2:n.areaColor2});const v={attached:!0,backgroundColor:(0,J.hU)(.6),textColor:(0,J.uu)(),view:d};this._areaLabel=new fe.Kc({...v,fontSize:ie.Large}),this._pathLengthLabel=new fe.Kc({...v,fontSize:ie.Small}),this._cursorSegmentLengthLabel=new fe.Kc({...v,fontSize:ie.Small}),this._perimeterLengthLabel=new fe.Kc({...v,fontSize:ie.Small}),this._handles.add([(0,B.YP)(()=>[h.mode,this.visible,h.unit,h.measurementData,h.cursorPoint],()=>this._update(),B.tX),(0,B.YP)(()=>d.state?.camera,()=>this._updateLabels(),B.tX),(0,Xt.qe)(()=>this._updateMessageBundle())]),this._updateMessageBundle()}destroy(){this._measurementArea=(0,_.SC)(this._measurementArea),this._path=(0,_.SC)(this._path),this._intersectedPath=(0,_.SC)(this._intersectedPath),this._perimeter=(0,_.SC)(this._perimeter),this._intersectedPerimeter=(0,_.SC)(this._intersectedPerimeter),this._areaLabel=(0,_.SC)(this._areaLabel),this._pathLengthLabel=(0,_.SC)(this._pathLengthLabel),this._cursorSegmentLengthLabel=(0,_.SC)(this._cursorSegmentLengthLabel),this._perimeterLengthLabel=(0,_.SC)(this._perimeterLengthLabel),this._projectionLines=(0,_.SC)(this._projectionLines),this._handles=(0,_.SC)(this._handles),this.set("view",null)}_update(){if(this.destroyed||!this.view.ready||!this.view.renderCoordsHelper)return;const{analysisViewData:{measurementData:h},analysisViewData:n}=this;(0,_.Wi)(h)||(this._updateViewData(h,n.path,n.cursorPoint),this._updateOrigin(),this._updatePathSegments(),this._updatePerimeterSegments(),this._updateArea(),this._updateProjectionLines(),this._updateLabels())}_updateViewData(h,n,d){const v=n.isValidPolygon,y="geodesic"===h.actualMeasurementMode,C=y?h.geodesicArea:h.area;let S=1;if(C){const A=this._toPreferredAreaUnit(C,this.analysisViewData.unit);S=(0,oe.sk)(Math.sqrt(A.value)/Math.sqrt(300)),S*=Math.sqrt((0,he.En)(1,A.unit,"square-meters")),S/=h.unitNormalizer.normalizeDistance(1)}this._set("viewData",{validMeasurement:v,path:n,pathVersion:n.version,cursorPoint:d,measurementData:h,mode:h.actualMeasurementMode,positionsGeographic:h.positionsGeographic,positionsRenderCoords:h.positionsRenderCoords,positionsProjected:h.positionsProjectedWorldCoords,positionsFittedRenderCoords:h.positionsFittedRenderCoords,intersectingSegments:y?h.geodesicIntersectingSegments:h.intersectingSegments,triangleIndices:y?h.geodesicTriangleIndices:h.triangleIndices,fittingMode:h.fittingMode,areaCentroid:y?h.geodesicAreaCentroidRenderCoords:h.areaCentroidRenderCoords,pathLengthLabelSegmentIndex:v?0:n.numVertices-2,perimeterLengthLabelSegmentIndex:0,checkerSize:S})}_updateOrigin(){(0,Te.H)(this.viewData.positionsRenderCoords,this._origin),(0,Ye.f)(this._originTransform,this._origin),this._measurementArea.transform=this._originTransform,this._projectionLines.transform=this._originTransform}_createSegments(h){const n=this.viewData,d=n.path,v=this.view.renderCoordsHelper.spatialReference,y=n.mode,C=[],S=[],M=[],A=n.validMeasurement?d.numVertices:d.numVertices-1;for(let V=0;V<A;++V){const G=n[h][V],w=n[h][(V+1)%d.numVertices];let O=null;switch(y){case"euclidean":O=new ce.y(G,w);break;case"geodesic":O=new ce.u(G,w,v)}n.intersectingSegments.has(V)?M.push(O):S.push(O),C.push(O)}return{all:C,nonIntersecting:S,intersecting:M}}_updatePathSegments(){const{view:{renderCoordsHelper:h},viewData:n,visible:d}=this,v=this._createSegments("positionsRenderCoords"),{cursorPoint:y,mode:C,path:S}=n,M=!S.isValidPolygon,A=h.spatialReference;if(this._cursorSegment=null,S.numVertices>0&&M&&(0,_.pC)(y)&&h.toRenderCoords(y,this._cursorPositionRenderSpace)){const V=n.positionsRenderCoords[S.numVertices-1],G=this._cursorPositionRenderSpace;let w=null;switch(C){case"euclidean":w=new ce.y(V,G);break;case"geodesic":w=new ce.u(V,G,A)}v.nonIntersecting.push(w),this._cursorSegment=w}this._path.setGeometryFromSegments(v.nonIntersecting,this._origin),this._path.visible=d,this._intersectedPath.setGeometryFromSegments(v.intersecting,this._origin),this._intersectedPath.visible=d,this._pathSegments=v.all}_updatePerimeterSegments(){const h=this.visible&&"euclidean"===this.viewData.mode,n=this._createSegments("positionsFittedRenderCoords");this._perimeter.setGeometryFromSegments(n.nonIntersecting,this._origin),this._perimeter.visible=h,this._intersectedPerimeter.setGeometryFromSegments(n.intersecting,this._origin),this._intersectedPerimeter.visible=h,this._perimeterSegments=n.all}_updateArea(){const h=this.viewData;switch(h.mode){case"euclidean":this._updateAreaEuclidean(h);break;case"geodesic":this._updateAreaGeodesic()}}_updateAreaEuclidean(h){const n=this.visible;h.validMeasurement&&0===h.intersectingSegments.size&&h.triangleIndices?(this._measurementArea.geometry={uv:h.positionsProjected,position:h.positionsFittedRenderCoords,triangleIndices:h.triangleIndices},this._measurementArea.size=[h.checkerSize,h.checkerSize],this._measurementArea.visible=n):this._measurementArea.visible=!1}_updateAreaGeodesic(){this._measurementArea.visible=!1}_updateProjectionLines(){const h=this.viewData,n=this.visible,d=h.path;if(d.numVertices>0&&h.validMeasurement&&"euclidean"===h.mode){const y=[];for(let C=0;C<d.numVertices;++C){const S=(0,R.c)();(0,b.b)(S,h.positionsRenderCoords[C],this._origin);const M=(0,R.c)();(0,b.b)(M,h.positionsFittedRenderCoords[C],this._origin),y.push([S,M])}this._projectionLines.geometry=y,this._projectionLines.visible=n}else this._projectionLines.geometry=null,this._projectionLines.visible=!1}_updateLabels(){if(this.destroyed)return;const{viewData:h}=this,{measurementData:n,mode:d,path:v}=h;if(!v)return;const y=!v.isValidPolygon,C=this.visible,S=this._formatAreaLabel(this.messages,"geodesic"===d?n.geodesicArea:n.area,this.analysisViewData.unit);(0,_.pC)(S)?(this._areaLabel.geometry={type:"point",point:h.areaCentroid},this._areaLabel.text=S,this._areaLabel.visible=h.validMeasurement&&0===h.intersectingSegments.size&&C):this._areaLabel.visible=!1,this._set("areaLabel",(0,_.Wg)(S));const M=this._formatLengthLabel(this.messages,"geodesic"===d?n.geodesicPathLength:n.pathLength,this.analysisViewData.unit);if((0,_.pC)(M)&&h.pathLengthLabelSegmentIndex>=0&&h.pathLengthLabelSegmentIndex<this._pathSegments.length){const O=this._pathSegments[h.pathLengthLabelSegmentIndex],z=(0,_.pC)(this._cursorSegment)?this._cursorSegment:Jt;this._pathLengthLabel.distance=this._params.labelDistance,this._pathLengthLabel.geometry={type:"corner",left:O,right:z},this._pathLengthLabel.text=M,this._pathLengthLabel.visible=y&&v.numVertices>0&&C}else this._pathLengthLabel.visible=!1;const A="geodesic"===d?h.measurementData.geodesicCursorSegmentLength:h.measurementData.cursorSegmentLength;if((0,_.pC)(A)){const O=this._formatLengthLabel(this.messages,A,this.analysisViewData.unit);this._cursorSegmentLengthLabel.distance=this._params.labelDistance,this._cursorSegmentLengthLabel.geometry=(0,_.pC)(this._cursorSegment)?{type:"segment",segment:this._cursorSegment,sampleLocation:"end"}:null,this._cursorSegmentLengthLabel.anchor="bottom",this._cursorSegmentLengthLabel.text=(0,_.Wg)(O),this._cursorSegmentLengthLabel.visible=y&&0!==A.value&&C}else this._cursorSegmentLengthLabel.visible=!1;this._cursorSegmentLengthLabel.overlaps(this._pathLengthLabel)&&(this._cursorSegmentLengthLabel.visible=!1),this._pathLengthLabel.overlaps(this._areaLabel)&&(this._pathLengthLabel.visible=!1);const V="geodesic"===h.mode,w=this._formatLengthLabel(this.messages,V?n.geodesicPathLength:n.perimeterLength,this.analysisViewData.unit);if(this._set("perimeterLengthLabel",(0,_.Wg)(w)),h.validMeasurement&&0===h.intersectingSegments.size){this._perimeterLengthLabel.distance=this._params.labelDistance,this._perimeterLengthLabel.anchor="top",this._perimeterLengthLabel.text=(0,_.Wg)(w),this._perimeterLengthLabel.visible=!0;let O=!0;for(let z=0;z<h.path.numVertices;++z){const j=(h.perimeterLengthLabelSegmentIndex+z)%h.path.numVertices;if(O=!0,this._perimeterLengthLabel.geometry={type:"segment",segment:V?this._pathSegments[j]:this._perimeterSegments[j],sampleLocation:"center"},!this._perimeterLengthLabel.overlaps(this._areaLabel))break;O=!1}this._perimeterLengthLabel.visible=O&&C}else this._perimeterLengthLabel.visible=!1}_toPreferredAreaUnit(h,n){return(0,W.nn)(h,this._preferredAreaUnit(h,n))}_preferredAreaUnit(h,n){switch(n){case"metric":return(0,he.tQ)(h.value,h.unit);case"imperial":return(0,he.Yl)(h.value,h.unit);default:return n}}_preferredLengthUnit(h,n){const d=this._deriveLengthUnitFromAreaUnit(n);switch(d){case"metric":return(0,he.KU)(h.value,h.unit);case"imperial":return(0,he.FN)(h.value,h.unit);default:return d}}_deriveLengthUnitFromAreaUnit(h){switch(h){case"metric":case"ares":case"hectares":return"metric";case"imperial":case"acres":return"imperial";case"square-inches":return"inches";case"square-feet":return"feet";case"square-yards":return"yards";case"square-miles":return"miles";case"square-us-feet":return"us-feet";case"square-millimeters":return"millimeters";case"square-centimeters":return"centimeters";case"square-decimeters":return"decimeters";case"square-meters":return"meters";case"square-kilometers":return"kilometers"}throw new Error("unhandled area unit")}_formatAreaLabel(h,n,d){return h&&n&&(0,Ke.VG)(h,n,this._preferredAreaUnit(n,d))}_formatLengthLabel(h,n,d){return h&&n&&(0,Ke.VG)(h,n,this._preferredLengthUnit(n,d))}_updateMessageBundle(){this.loadingMessages=!0,(0,$t.ME)("esri/core/t9n/Units").then(h=>{this.messages=h,this.view&&this._update()}).finally(()=>{this.loadingMessages=!1})}};var ie,h;(0,P._)([(0,D.Cb)()],H.prototype,"view",void 0),(0,P._)([(0,D.Cb)()],H.prototype,"messages",void 0),(0,P._)([(0,D.Cb)()],H.prototype,"analysis",void 0),(0,P._)([(0,D.Cb)()],H.prototype,"viewData",void 0),(0,P._)([(0,D.Cb)()],H.prototype,"analysisViewData",void 0),(0,P._)([(0,D.Cb)({readOnly:!0})],H.prototype,"areaLabel",void 0),(0,P._)([(0,D.Cb)({readOnly:!0})],H.prototype,"perimeterLengthLabel",void 0),(0,P._)([(0,D.Cb)()],H.prototype,"loadingMessages",void 0),(0,P._)([(0,D.Cb)()],H.prototype,"visible",null),H=(0,P._)([(0,q.j)("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementVisualization")],H),(h=ie||(ie={}))[h.Small=12]="Small",h[h.Large=16]="Large";const Qt={validMeasurement:!1,path:null,pathVersion:-1,cursorPoint:null,measurementData:null,mode:null,positionsGeographic:null,positionsRenderCoords:null,positionsProjected:null,positionsFittedRenderCoords:null,intersectingSegments:null,triangleIndices:null,fittingMode:null,areaCentroid:null,pathLengthLabelSegmentIndex:null,perimeterLengthLabelSegmentIndex:null,checkerSize:null},Jt=new ce.y((0,R.c)(),(0,R.c)());let U=class extends((0,ue.p)(ne.Z)){constructor(h){super(h),this.type="area-measurement-view-3d",this.analysis=null,this.measurementData=null,this.lastDraggedVertex=null,this.cursorPoint=null,this.mode=ee.e.Auto}initialize(){const{analysis:h,view:n}=this;this.path=new K({view:n,areaMeasurement:h}),this.analysisVisualization=new H({view:n,analysis:h,analysisViewData:this}),this.analysisController=new te({view:n,analysis:h,analysisViewData:this})}destroy(){this.analysisController=(0,_.SC)(this.analysisController),this.analysisVisualization=(0,_.SC)(this.analysisVisualization),this.path.destroy()}get updating(){return!!this.analysisVisualization?.loadingMessages}get result(){const{measurementData:h}=this;return(0,_.Wi)(h)?{area:null,mode:null,perimeter:null}:"euclidean"===h.actualMeasurementMode?{area:h.area,perimeter:h.perimeterLength,mode:"euclidean"}:{area:h.geodesicArea,perimeter:h.pathLength,mode:"geodesic"}}get viewData(){return this.analysisVisualization.viewData}get validMeasurement(){return this.path.isValidPolygon}get unit(){return(0,_.Pt)(this.analysis.unit,this._defaultUnit)}get testData(){return{visualization:this.analysisVisualization,controller:this.analysisController}}};(0,P._)([(0,D.Cb)({readOnly:!0})],U.prototype,"type",void 0),(0,P._)([(0,D.Cb)({constructOnly:!0,nonNullable:!0})],U.prototype,"analysis",void 0),(0,P._)([(0,D.Cb)()],U.prototype,"updating",null),(0,P._)([(0,D.Cb)()],U.prototype,"analysisVisualization",void 0),(0,P._)([(0,D.Cb)()],U.prototype,"analysisController",void 0),(0,P._)([(0,D.Cb)()],U.prototype,"result",null),(0,P._)([(0,D.Cb)()],U.prototype,"measurementData",void 0),(0,P._)([(0,D.Cb)()],U.prototype,"viewData",null),(0,P._)([(0,D.Cb)()],U.prototype,"validMeasurement",null),(0,P._)([(0,D.Cb)()],U.prototype,"path",void 0),(0,P._)([(0,D.Cb)()],U.prototype,"lastDraggedVertex",void 0),(0,P._)([(0,D.Cb)()],U.prototype,"cursorPoint",void 0),(0,P._)([(0,D.Cb)()],U.prototype,"mode",void 0),(0,P._)([(0,D.Cb)()],U.prototype,"unit",null),(0,P._)([(0,D.Cb)(Ge.Y)],U.prototype,"_defaultUnit",void 0),U=(0,P._)([(0,q.j)("esri.views.3d.analysis.AreaMeasurementAnalysisView3D")],U);const kt=U}}]);